<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Yehh</title>
    <link>https://blog.yehaohui.com/zh-cn/</link>
    <description>Recent content on Yehh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 27 May 2023 10:01:23 +0800</lastBuildDate>
    
    <atom:link href="https://blog.yehaohui.com/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://blog.yehaohui.com/zh-cn/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/about/</guid>
      <description>Hi! 我是叶浩辉 华南理工大学 软件学院二年级本科生, 兴趣集中在Computer Vision 和 Trustworthy Machine Learning。 希望不断学习，不断进步，通过深度阅读提升思</description>
      <content:encoded><![CDATA[<h2 id="hi-我是叶浩辉httpsblogyehaohuicom">Hi! 我是<a href="https://blog.yehaohui.com/">叶浩辉</a></h2>
<p><a href="https://www.scut.edu.cn/new/">华南理工大学</a> 软件学院二年级本科生, <del>兴趣集中在Computer Vision 和 Trustworthy Machine Learning。</del></p>
<p>希望不断学习，不断进步，通过深度阅读提升思考能力。</p>
<h2 id="关于本站">关于本站</h2>
<blockquote>
<p>本站灵感来自<a href="https://www.pseudoyu.com/zh/">pseudoyou</a>,真诚、自省的文字和开源的精神是我建站的目标。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>大二下 13-14周</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/05/27/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-13-14%E5%91%A8/</link>
      <pubDate>Sat, 27 May 2023 10:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/05/27/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-13-14%E5%91%A8/</guid>
      <description>《你比从前快乐》 不知不觉就到了13周！！！ 概览 总得来说，这两个月过得不咸不淡。力扣力扣没刷多少八股八股也没做多少，公开课lab也没做完。算是</description>
      <content:encoded><![CDATA[<figure >
    <audio controls preload="metadata">
        
        <source src="/audios/happier%20than%20past.mp3" type="audio/mpeg">
    </audio>
    <i><figcaption>《你比从前快乐》</figcaption></i>
</figure>
<h1 id="不知不觉就到了13周">不知不觉就到了13周！！！</h1>
<h2 id="概览">概览</h2>
<p>总得来说，这两个月过得不咸不淡。力扣力扣没刷多少八股八股也没做多少，公开课lab也没做完。算是各有涉猎但是还是没有完成。</p>
<p>离开科研后生活似乎也没有我想得轻松，完成课业再做点自己的事情已经有点让我喘不过气。</p>
<h3 id="学业">学业</h3>
<p>这学期课其实不算多:
<img src="https://s2.loli.net/2023/05/27/GOrELnhM59TmPQv.png" alt="kebiao.png">
而且课程基本上是大一的课，难度不算大，基本上上课认真听讲基本都没问题。近一个月的时间主要是花在了C++实训上。</p>
<p>C++实训是做一个俄罗斯方块，用Qt完成，本来还以为要学很多东西。但是郭老师找到了一个南大的大作业里面用到的技术基本足够解决这次的问题了，我把他的看懂抄抄改改就完成基本要求了。</p>
<h3 id="生活">生活</h3>
<p>最近总是感觉生活很紧绷，对未来很焦虑。以前觉得成绩好能保研就好了，现在发现保研也就那么回事。以前觉得找一份体面的工作很简单，虽然说是受限于形式，但是不可否认的是越来越难了。而且就算能找到大厂工作又怎么样呢？996的工作不过从研究生这个粪坑跳入另一个粪坑罢了。</p>
<h3 id="relation">relation</h3>
<p>无(XXXXXXXXXXX)
开启一段新的relation实在是太难了。</p>
<h3 id="运动与健康">运动与健康</h3>
<p>值得一提的是开始健身了，但是最近出现一个问题就是每次健完之后晚上就睡不着。而且最近睡觉都会有胀气，比较难入睡。</p>
<h3 id="阅读与思考">阅读与思考</h3>
<p>最近没有新读什么书，重读《挪威的森林》还是不禁感慨渡边20岁就已经经历过这么多事情了，而我21岁却还像在温室里读书学习，做什么都畏手畏脚。是啊，相比18岁我到底学到了什么。</p>
<p>重读《潮骚》，那是多美的一个世界啊。三岛由纪夫的桃花源真是令人向往。只要读一页就能闻到咸咸的海风，质朴的男孩，天真的爱情。一下子就置身上世纪90年代的古朴海边村落，那是多好一个世界啊。
下次抄录几句话上来。</p>
<p>希望21岁的这剩下的日子里能越来越好。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/05/27/category/leetcode_day13/</link>
      <pubDate>Sat, 27 May 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/05/27/category/leetcode_day13/</guid>
      <description>发现好久没有写刷题记录了(博客也好久没有更新了) leetcode 135 分发糖果</description>
      <content:encoded><![CDATA[<h1 id="发现好久没有写刷题记录了博客也好久没有更新了">发现好久没有写刷题记录了(博客也好久没有更新了)</h1>
<p><a href="https://leetcode.cn/problems/candy/">leetcode 135 分发糖果</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>贪心(2)</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/04/23/category/leetcode_day12/</link>
      <pubDate>Sun, 23 Apr 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/04/23/category/leetcode_day12/</guid>
      <description>贪心算法(2) leetcode 135 分发糖果 这题我本来根据题目意思，三个三个来看一步一步来赋值，但是还是不对。原因在于:上一个山，你从左边上山是不知道山顶距离</description>
      <content:encoded><![CDATA[<h2 id="贪心算法2">贪心算法(2)</h2>
<p><a href="https://leetcode.cn/problems/candy/">leetcode 135 分发糖果</a></p>
<p>这题我本来根据题目意思，三个三个来看一步一步来赋值，但是还是不对。原因在于:上一个山，你从左边上山是不知道山顶距离右边的山底多高，只有都走一遍才知道山顶相对于谁来说最高。</p>
<p>根据代码随想录写了一版:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">candy</span><span class="p">(</span><span class="nx">ratings</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sum</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">ratings</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">ratings</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">ratings</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ratings</span><span class="p">[</span><span class="nx">i</span><span class="p">]&gt;</span><span class="nx">ratings</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">ratings</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span><span class="o">+=</span><span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">ratings</span><span class="p">[</span><span class="nx">i</span><span class="p">]&gt;</span><span class="nx">ratings</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nf">max</span><span class="p">(</span><span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sum</span><span class="o">+=</span><span class="nx">record</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span><span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">a</span><span class="p">&gt;</span><span class="nx">b</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>贪心</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/03/27/category/leetcode_day11/</link>
      <pubDate>Mon, 27 Mar 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/03/27/category/leetcode_day11/</guid>
      <description>贪心算法 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元</description>
      <content:encoded><![CDATA[<h2 id="贪心算法">贪心算法</h2>
<h4 id="摆动序列httpsleetcodecnproblemswiggle-subsequence"><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></h4>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 摆动序列 ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</p>
<p>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<blockquote>
<p>不得不说我这个实现实在是太优美</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">wiggleMaxLength</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">length</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span> <span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">middle</span><span class="o">:=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">right</span> <span class="o">:=</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">right</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">middle</span><span class="p">]</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">middle</span><span class="p">])&lt;</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">right</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="nx">middle</span><span class="p">=</span><span class="nx">right</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="nx">left</span><span class="p">=</span><span class="nx">middle</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="nx">length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">middle</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nx">right</span><span class="o">++</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">middle</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">length</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">length</span><span class="o">+</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>充分理解题目摆动序列的思想: 判断摆动至少需要三个数字，一旦不符合就把中间的删除(具体操作是middle和right右移，left不动)</li>
<li>贪心思想: 把连续增加的剔除掉，剩下的就都是连续的。</li>
<li>滑动窗口思想: 窗口大小是三，每次移动右边，只有条件满足才移动左边的。这样每次窗口左边移动都是判断最左边是不是满足条件的。 而且在移动左侧的时候不要思维定势，每次加一，移动会要跳过剔除的，所以直接移动到middle左边。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Raft implementation</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/03/08/category/raft_implementation/</link>
      <pubDate>Wed, 08 Mar 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/03/08/category/raft_implementation/</guid>
      <description>本文记录一下搭建MiT6.824 lab2 Raft的实现过程 Raft的原理见: 一些有用的links:</description>
      <content:encoded><![CDATA[<h2 id="本文记录一下搭建mit6824-lab2-raft的实现过程">本文记录一下搭建MiT6.824 lab2 Raft的实现过程</h2>
<p>Raft的原理见:</p>
<p>一些有用的links:</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>大二下 3-4周</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/03/05/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-3-4%E5%91%A8/</link>
      <pubDate>Sun, 05 Mar 2023 16:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/03/05/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-3-4%E5%91%A8/</guid>
      <description>平淡的两周 这段时间心里总是很急躁，可能是外界(身边的负能量)也可能是自己的原因。希望借周记和自己对话的机会让自己平静下来。 Polyv 前几个月报名的保</description>
      <content:encoded><![CDATA[<h2 id="平淡的两周">平淡的两周</h2>
<p>这段时间心里总是很急躁，可能是外界(身边的负能量)也可能是自己的原因。希望借周记和自己对话的机会让自己平静下来。</p>
<h2 id="polyv">Polyv</h2>
<p>前几个月报名的保利威直播+比赛在第四周的周六答辩，经过秋科和郭老师的临阵磨枪算是能交出一份答辩。但是郭老师答辩的问答部分表现得微微怯场了一点，加上后面几个答辩都很不错，我认为我们只能拿个优胜奖了。没想到最后竟然能拿个三等奖。</p>
<p>其实我是觉得比较愧疚的，当时想搞科研所以这边没有怎么帮上忙。</p>
<p><img src="https://s2.loli.net/2023/03/20/1FxZQ84a2j9zKcX.jpg" alt="33d9a024d9e59d19001d9e1fae417df.jpg"></p>
<h2 id="mit6824">mit6.824</h2>
<p>这算是这两周的重点，比较多时间都花在了lab2和lab3上。lab2目前是bug-free，lab3还在努力。同时lab2和raft的博文也提上日程了。</p>
<h2 id="记一次相遇">记一次相遇</h2>
<p>去小姨家那天的晚上，走到c9的时候遇到了聂昀和小贤。小贤倒是见过几次，聂昀的话见得比较少。围着c10，c9逛了一圈又一圈，也许是蕴含着对过去生活的怀念，聊到初中的同学时心里总是兴奋不已。</p>
<p>男生的话题无非是最近有没谈女朋友，以前的女同学怎么样，分享知道的逆天事迹。话题本身没多大意思，我也不是很在乎。相遇的魔力在我们身边流转，初三的同学在几乎没有联系的高中以及两年大学后再次获得来之不易的闲聊机会。</p>
<h2 id="birthday">birthday</h2>
<p>差点忘记了生日的事情，算是一个平淡的生日吧。</p>
<p>郭老师送的礼物，算是近年来比较喜欢的礼物了。
<img src="https://s2.loli.net/2023/03/20/xoYEIRqekmHjKfO.jpg" alt="f1bfa4865411039f5be0fa013789c9a.jpg"></p>
<p>还有秋科的蛋糕，祥睿的饼干。</p>
<h2 id="输入">输入</h2>
<p>无。。。
希望能看看书。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>大二下 1-2周</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/03/02/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-1-2%E5%91%A8/</link>
      <pubDate>Thu, 02 Mar 2023 16:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/03/02/category/%E5%A4%A7%E4%BA%8C%E4%B8%8B-1-2%E5%91%A8/</guid>
      <description>概览 第一周主要是复习和考试，要考的科目有Java，计概，还有雅思英语。这几门课都不难，浅浅复习都足以解决考试。 有意思的是：Java考试的时候</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>第一周主要是复习和考试，要考的科目有Java，计概，还有雅思英语。这几门课都不难，浅浅复习都足以解决考试。
有意思的是：Java考试的时候题目有个错误的地方，把comparaTo的函数签名写错了，我记得应该是泛型接口的实现方法，但是没有和老师说()，后面竟然也没人提hhh。</p>
<p>后续的话白天的主要时间都基本在刷题，刷的题基本也有记录下来。对我来说，刷题倒不是非常难的事，见过了差不多类型的题目之后类似的题目基本都能AC。</p>
<p>MiT6.824: 在上学期完成lab1后便中断了，寒假断断续续地捡起来。最近算是第二遍看Raft论文，结合<a href="http://thesecretlivesofdata.com/raft/">visualization</a>第二遍看对实现的很多细节都理解得比较好了。</p>
<p>但是对于lab2，其中的模拟网络和labgob包我还希望先看明白再去写。</p>
<h2 id="运动">运动⛹️</h2>
<p>基本会每天保持一定量的运动，无论是basketball还是和郭老师打Pingpong或者是去跑跑步。</p>
<h2 id="其他">其他</h2>
<p>开学两周出去的次数还是很多(钱包都空了)。</p>
<ul>
<li>
<p>首先是周五，郭老师和祥睿考完PM，大家的考试基本都告一段落，机缘巧合下，黎根廷和顾伟正都一起去了北京路。
<img src="https://s2.loli.net/2023/03/02/eA14aRqsNoFQlrp.jpg" alt="由于图床服务器在国外所以可能需要时间"></p>
</li>
<li>
<p>然后是机械的朋友们也考完试，王导也刚刚生日完。我想着以前出来聚都只是吃个饭，要么唱个K或者打打台球，这次不如去趟华农，也算一次春游了。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/02/ptFfxLlh4z7B1iU.jpg" alt="微信图片_20230302232656.jpg"></p>
<p><img src="https://s2.loli.net/2023/03/02/FTCMVYv9GBse4qm.jpg" alt="微信图片_20230302232713.jpg"></p>
<p><img src="https://s2.loli.net/2023/03/02/G1fZqCJdPoLKTnc.jpg" alt="微信图片_20230302232708.jpg"></p>
<p><img src="https://s2.loli.net/2023/03/02/E7vn1UhMNepSmZt.jpg" alt="微信图片_20230302232701.jpg"></p>
<ul>
<li>接着周日又去了小姨家，陪他们逛了下广州的高中,让琪琪看看高中，确立一下目标。</li>
</ul>
<blockquote>
<p>图片正在来的路上</p>
</blockquote>
<p>八十六中:听说是办学20来年，直到最近黄冈来的欧阳校长上任之后成绩才比较有起色。22年的话大约有30个985，60个600+这样。算不上特别顶尖的学校，但是就“加工”能力而言在生源较差的基础上能取得这样的成绩作为学校来说不能算失败。</p>
<p>有点感悟就是，在大城市读书所谓的好的教育资源到底指的是什么？</p>
<p>好的高中(/初中)？ 从我的视角看，大城市有好高中，但不一定是你有好高中。对于顶尖的资源来说，大城市的竞争也大，而同时在小县城，就拿我来说，成绩好你依然可以获得好的资源，至少上升的渠道并没有完全阻断。而对于上了高中之后的高考，大城市的补习班确实琳琅满目，就补习的效果而言我认为只要是你人是想学的，并且钱到位了，效果是肯定有的。但是在小地方，很多家庭并不一定能支撑补习班的费用，学习的过程可能会走一些弯路，但是毕竟是自己走过来的，对于学习方法什么的会逐渐形成自己的一套体系。无法论孰优孰劣，毕竟在考试这件事上，个体差异占主导因素。(回过头来看，这一段似乎有点既得利益者的看法。如果看中下段的学生的话，两个地方的资源是天差地别的)</p>
<p>或者我们把格局打开，不局限于高考。</p>
<p>好的教育资源在于什么？</p>
<blockquote>
<p><em>TODO&hellip;</em></p>
</blockquote>
<h3 id="heading"></h3>
<h2 id="输入">输入</h2>
<h3 id="书">书</h3>
<p>《被讨厌的勇气》: 娓娓道来阿德勒心理学，教你如何活得不那么累。30%</p>
<h3 id="影视剧">影视剧</h3>
<p>只有芸知道: 冯小刚的青春电影，值得一提的是改编自真实事件。</p>
<p>其实这部电影似乎是高中的时候看《看天下》的时候有瞥过一眼。前段时间刷题刷累了看B站的时候，无意中看到有这部电影的解说，看解说的时候被解说的叙述节奏和大部分时候恰到好处的BGM感到到了，立马去下了原片。结果，原片通过回忆和倒叙的方式展开反而显得情感的发展不那么自然。感觉就是男女主的颜值以及异国他乡的美丽风景在硬撑。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>回溯[上]</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/03/01/category/leetcode_day10/</link>
      <pubDate>Wed, 01 Mar 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/03/01/category/leetcode_day10/</guid>
      <description>回溯 思想 回溯其实就是穷举的一种方式，但是这种穷举可以把之前举过的信息保存(传递)给后面使用。 适用范围 组合问题：N个数里面按一定规则找出k个数</description>
      <content:encoded><![CDATA[<h1 id="回溯">回溯</h1>
<h2 id="思想">思想</h2>
<p>回溯其实就是穷举的一种方式，但是这种穷举可以把之前举过的信息保存(传递)给后面使用。</p>
<h2 id="适用范围">适用范围</h2>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="理解">理解</h2>
<p>把他当成数形结构的遍历</p>
<p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="err">参数</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="err">终止条件</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="err">存放结果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="err">选择：本层集合中元素（树中节点孩子的数量就是集合的大小）</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="err">处理节点</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">backtracking</span><span class="p">(</span><span class="err">路径，选择列表</span><span class="p">);</span> <span class="c1">// 递归
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="err">回溯，撤销处理结果</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>基本上图片加这个模板就可以</p>
<h4 id="77-组合httpsleetcodecnproblemscombinations"><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4>
<blockquote>
<p><em>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</em></p>
</blockquote>
<blockquote>
<p><em>你可以按 任何顺序 返回答案。</em></p>
</blockquote>
<p>我的方法是：将6取3 降低规模到 (6+5取2) + (5取3)</p>
<p>但是这样的话，会有很多重复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">k</span><span class="o">==</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">n</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subAns</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">subAns</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subAns</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">subAns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nf">combine</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subAns</span><span class="o">:=</span><span class="nf">combine</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">subAns</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subAns</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subAns</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">subAns</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>好的做法：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123195242899.png" alt=""></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 存放符合条件结果的集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span> <span class="c1">// 用来存放符合条件结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 处理节点 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">backtracking</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 递归
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// 回溯，撤销处理的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">combine</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// 可以不写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>   <span class="c1">// 可以不写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt=""></p>
<h3 id="组合">组合</h3>
<h4 id="组合总和httpsleetcodecnproblemscombination-sum"><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></h4>
<h4 id="组合总和iihttpsleetcodecnproblemscombination-sum-ii"><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a></h4>
<h4 id="216组合总和iiihttpsleetcodecnproblemscombination-sum-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216.组合总和III</a></h4>
<h4 id="17电话号码的字母组合httpsleetcodecnproblemsletter-combinations-of-a-phone-number"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17.电话号码的字母组合</a></h4>
<h3 id="分割">分割</h3>
<h4 id="分割回文字符串httpsleetcodecnproblemspalindrome-partitioning"><a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文字符串</a></h4>
<h4 id="93复原ip地址httpsleetcodecnproblemsrestore-ip-addresses"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93.复原IP地址</a></h4>
<p>这几题用上面的方法都是比较简单的。</p>
<h3 id="子集">子集</h3>
<blockquote>
<p>代码随想录总结得比较好:
求子集问题和77.组合 和131.分割回文串 又不一样了。</p>
</blockquote>
<blockquote>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</p>
</blockquote>
<blockquote>
<p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>
</blockquote>
<blockquote>
<p>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</p>
</blockquote>
<blockquote>
<p>有同学问了，什么时候for可以从0开始呢？</p>
</blockquote>
<blockquote>
<p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p>
</blockquote>
<p>具体的区别在于，组合和分割是在终止的时候把这次的添加到集合，而集合问题是每次开始前都添加到集合也就是所有的节点不止叶子节点。</p>
<p>之前我的写法是添加递归一遍，不添加递归一遍，所以会很多重复。(很别扭)</p>
<blockquote>
<p><em>比较重要的一道题</em></p>
</blockquote>
<h4 id="90子集iihttpsleetcodecnproblemssubsets-ii"><a href="https://leetcode.cn/problems/subsets-ii/">90.子集II</a></h4>
<p>重要的点在于“数层剪枝”</p>
<p>首先讲讲<a href="https://leetcode.cn/problems/combination-sum-ii/">40.组合总和II</a></p>
<blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
</blockquote>
<blockquote>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
</blockquote>
<blockquote>
<p>说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。</p>
</blockquote>
<p>这里面也是树层剪枝
<img src="https://img-blog.csdnimg.cn/20201123202736384.png" alt=""></p>
<p>我的方法是对排序后在层间的for循环时先找到相同的最后一个,然后再跳过。其实是一样的只是之前没有总结成方法论。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">index</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nx">subAns</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subAns</span><span class="p">,</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span><span class="o">+=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nf">combination</span><span class="p">(</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subAns</span><span class="p">=</span><span class="nx">subAns</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subAns</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span><span class="o">-=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>现在总结一下，树层剪枝其实是因为，同样深度的同一个值的情况其实已经被第一次遇到的那个节点的子树包括了。所以只需要第一个子树的情况就可以。</p>
<p>回到<a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">res</span>  <span class="p">[][]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">subRes</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">subsetsWithDup</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">=[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subRes</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nf">IntSlice</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sub</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slice</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span><span class="nx">subRes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">:=</span><span class="nx">index</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">length</span><span class="o">:=</span><span class="nx">i</span><span class="o">-</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fmt.Println(length)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// fmt.Println(&#34;===&#34;,subRes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">length</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">k</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">k</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">subRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// fmt.Println(subRes)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sub</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subRes</span><span class="p">=</span><span class="nx">subRes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="nx">length</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">length</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我使用length记录，同样的数字的长度然后递减再递归只能说重复太多，没有理解到子集。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">backtracking</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">used</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 而我们要对同一树层使用过的元素进行跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">subsetsWithDup</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 去重需要排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>这是好的做法</p>
<h4 id="491-递增子序列httpsleetcodecnproblemsnon-decreasing-subsequences"><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h4>
<p>这题算是比较难</p>
<blockquote>
<p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
</blockquote>
<blockquote>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
</blockquote>
<p>我一开始用层间剪枝的方法，必须要用一个hash map或者数组来保存同一层中见过的其他数字。
这是因为他这里是不能排序的，很难知道是否见过了相同的。</p>
<p>力扣官方题解有个比较好的去重思路。其实总的来说这类重复问题其实都是说，有n个重复的数字，在你的集合中你要用n，n-1,n-2&hellip;.1个来进行递归。</p>
<p>之前代码随想录是把这种选择单放到一个树的深度来考虑。</p>
<p>这里官方题解是把他n个放到第一个棵子树，n-1放到第二颗。。。</p>
<p>这样就必须让子树中相同数值都选中，</p>
<blockquote>
<p>那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：</p>
</blockquote>
<blockquote>
<ul>
<li>前者被选择，后者被选择</li>
<li>前者被选择，后者不被选择</li>
<li>前者不被选择，后者被选择</li>
<li>前者不被选择，后者不被选择
其中第二种情况和第三种情况其实是等价的，我们这样限制之后，舍弃了第二种，保留了第三种，于是达到了去重的目的。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">temp</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="n">ans</span> <span class="p">[][]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span> <span class="n">findSubsequences</span><span class="p">(</span><span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ans</span> <span class="o">=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="p">.</span><span class="n">MinInt32</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">last</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nl">t</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">copy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">last</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">],</span> <span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="o">:</span><span class="n">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">!=</span> <span class="n">last</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意他这里选的方法是和我之前那个一样，一个函数里面push的递归一次，不push的递归一次。模拟选和不选</p>
<h4 id="全排列httpsleetcodecnproblemspermutations"><a href="https://leetcode.cn/problems/permutations/">全排列</a></h4>
<p>排列和组合比较像，同样是取叶子节点。不同点在于：全排列的i是从0开始选没有被选过的。
这样的话需要一个数组记录是否被选过。
而不需要额外空间的方法是，每次选了之后做一个划分，划分后变成两部分，一部分是已经被选过，一部分是还没有被选。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">subRes</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">=[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subRes</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">subFunc</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">subFunc</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slice</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span><span class="nx">subRes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nums</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nf">subFunc</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nums</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subRes</span><span class="p">=</span><span class="nx">subRes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="47-全排列"><a href="">47. 全排列</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">subRes</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">state</span> <span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">=[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subRes</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nf">IntSlice</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">state</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slice</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span><span class="nx">subRes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nx">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">subRes</span><span class="p">=</span><span class="nx">subRes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">state</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意，一开始我把</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>写在前面是不行的
写在前面的写法是和前面的比较而不是和后面的比较
写在前面的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="332-重新安排行程httpsleetcodecnproblemsreconstruct-itinerary"><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4>
<p>这题是能写出来，但是有点曲折。</p>
<p>先贴代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span>  <span class="nx">res</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">subRes</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findItinerary</span><span class="p">(</span><span class="nx">tickets</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">list</span><span class="p">,</span><span class="nx">table</span><span class="o">:=</span><span class="nf">makeList</span><span class="p">(</span><span class="nx">tickets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subRes</span><span class="p">=[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;JFK&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">=[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="o">:=</span><span class="s">&#34;JFK&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">find</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">table</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">tickets</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">find</span><span class="p">(</span><span class="nx">list</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span> <span class="p">,</span><span class="nx">table</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">bool</span> <span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span><span class="nx">length</span> <span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">==</span><span class="nx">length</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slice</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="nx">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span><span class="nx">subRes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">res</span><span class="p">=</span><span class="nx">slice</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span><span class="nx">s</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">target</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">table</span><span class="p">[</span><span class="nx">target</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="kc">false</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">subRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">list</span><span class="p">[</span><span class="nx">target</span><span class="p">][</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="nx">table</span><span class="p">[</span><span class="nx">target</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="nf">find</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">table</span><span class="p">,</span><span class="nx">s</span><span class="p">,</span><span class="nx">length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">subRes</span><span class="p">=</span><span class="nx">subRes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">table</span><span class="p">[</span><span class="nx">target</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="kc">false</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeList</span><span class="p">(</span><span class="nx">tickets</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">,</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">bool</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">list</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">tickets</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">list</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span><span class="nx">ok</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">list</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]=</span><span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="nx">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">list</span><span class="p">[</span><span class="nx">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]=[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">table</span> <span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">list</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nf">StringSlice</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">k</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">        <span class="nx">table</span><span class="p">[</span><span class="nx">k</span><span class="p">]=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">[</span><span class="nx">k</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">list</span><span class="p">,</span><span class="nx">table</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>比较好的做法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="c1">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">targets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">backtracking</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticketNum</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">ticketNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="nl">target</span> <span class="p">:</span> <span class="n">targets</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 记录到达机场是否飞过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">target</span><span class="p">.</span><span class="n">second</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">backtracking</span><span class="p">(</span><span class="n">ticketNum</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">target</span><span class="p">.</span><span class="n">second</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findItinerary</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tickets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">targets</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="nl">vec</span> <span class="p">:</span> <span class="n">tickets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">targets</span><span class="p">[</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 记录映射关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;JFK&#34;</span><span class="p">);</span> <span class="c1">// 起始机场
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">tickets</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>学到的几点:</p>
<ul>
<li>当只需要遍历找到某一个叶子节点时，可以设置递归函数的返回值，一旦条件满足就返回标志，这样就可以向上不断返回。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>二叉树（下）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/28/category/leetcode_day9/</link>
      <pubDate>Tue, 28 Feb 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/28/category/leetcode_day9/</guid>
      <description>二叉树(下) 二叉搜索树 二叉搜索树的话最重要就是中序遍历，普通的中序遍历用stack存值，然后用pointer遍历，每次pop的时候存入然后p</description>
      <content:encoded><![CDATA[<h1 id="二叉树下">二叉树(下)</h1>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>二叉搜索树的话最重要就是中序遍历，普通的中序遍历用stack存值，然后用pointer遍历，每次pop的时候存入然后push右子树。但是在二叉搜索树很多时候会涉及到比较，如果像上面那样的话，没有办法比较，所以一般会有一个pre指针，这个如其名就是存上一个pointer，这样的话才不会在回溯的时候丢弃父节点。</p>
<h4 id="98-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4>
<p>方法一: 统一写法的中序遍历，然后判断这个数组是不是有序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stack</span><span class="o">:=</span><span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">list</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="o">:=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span><span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">pointer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span><span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pointer</span><span class="p">=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">list</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">isAscend</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isAscend</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而实际上中序遍历本来就是一个判断前后的过程，可以在这个过程中加上判断逻辑。</p>
<p><strong>方法二</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 用来记录前一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">left</span> <span class="o">=</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span> <span class="c1">// 记录前一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">right</span> <span class="o">=</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>迭代法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 记录前一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>                <span class="c1">// 左
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>                 <span class="c1">// 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span> <span class="c1">//保存前一个访问的结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>               <span class="c1">// 右
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h4 id="501-二叉搜索树中的众数httpsleetcodecnproblemsfind-mode-in-binary-search-tree"><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4>
<p>其实也就是中序遍历BST，但是要注意的是，在处理单个的逻辑的时候，要分成pre==nil 和else的情况，分别对应首个节点和后续节点。</p>
<p>然后对于这题的话，要把不同情况分开操作，然后再统一判断</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//递归
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">MaxTimes</span> <span class="kt">int</span> <span class="p">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">curTimes</span> <span class="kt">int</span><span class="p">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">pre</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">=</span><span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ans</span> <span class="p">[]</span><span class="kt">int</span><span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findMode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">findLastMode</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findLastMode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">findLastMode</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">val</span><span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">pre</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pre</span><span class="p">).</span><span class="nx">Val</span><span class="o">==</span><span class="nx">val</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">curTimes</span><span class="o">+=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">curTimes</span><span class="p">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">curTimes</span><span class="p">&gt;</span><span class="nx">MaxTimes</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span> <span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">MaxTimes</span><span class="p">=</span><span class="nx">curTimes</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">curTimes</span><span class="o">==</span><span class="nx">MaxTimes</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">MaxTimes</span><span class="p">=</span><span class="nx">curTimes</span>
</span></span><span class="line"><span class="cl">                <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pre</span><span class="p">=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">    <span class="nf">findLastMode</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4>
<p>这题最重要就是回溯，也就是找到了一个要的点之后不断回溯寻找下一个点。</p>
<p>我的方法是符合直觉的中序遍历，因为这样的话找到第一个，那么现在栈里面的就是祖先。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="kd">func</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nx">stack</span><span class="o">:=</span><span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">     <span class="nx">cur</span><span class="o">:=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">     <span class="nx">oneDone</span><span class="o">:=</span><span class="kc">false</span>
</span></span><span class="line"><span class="cl">     <span class="nx">ancestor</span><span class="o">:=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">     <span class="nx">numAncestir</span><span class="o">:=-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="o">||</span><span class="nx">cur</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="nx">cur</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="nx">cur</span><span class="p">=</span><span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nx">cur</span><span class="p">=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">             <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">             
</span></span><span class="line"><span class="cl">             <span class="k">if</span> <span class="p">!</span><span class="nx">oneDone</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                 <span class="k">if</span> <span class="nx">cur</span><span class="o">==</span><span class="nx">p</span><span class="o">||</span><span class="nx">cur</span><span class="o">==</span><span class="nx">q</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">if</span> <span class="nx">cur</span><span class="o">==</span><span class="nx">q</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                         <span class="nx">q</span><span class="p">=</span><span class="nx">p</span>
</span></span><span class="line"><span class="cl">                     <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">oneDone</span><span class="p">=</span><span class="kc">true</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">numAncestir</span><span class="p">=</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">ancestor</span><span class="p">=</span><span class="nx">cur</span>
</span></span><span class="line"><span class="cl">                 <span class="p">}</span>
</span></span><span class="line"><span class="cl">             <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">==</span><span class="nx">numAncestir</span><span class="o">-</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                 <span class="nx">ancestor</span><span class="p">=</span><span class="nx">cur</span>
</span></span><span class="line"><span class="cl">                 <span class="nx">numAncestir</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                 <span class="k">if</span> <span class="nx">cur</span><span class="o">==</span><span class="nx">q</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                     <span class="k">return</span> <span class="nx">ancestor</span>
</span></span><span class="line"><span class="cl">                 <span class="p">}</span>
</span></span><span class="line"><span class="cl">             <span class="p">}</span>
</span></span><span class="line"><span class="cl">             
</span></span><span class="line"><span class="cl">             <span class="nx">cur</span><span class="p">=(</span><span class="o">*</span><span class="nx">cur</span><span class="p">).</span><span class="nx">Right</span>
</span></span><span class="line"><span class="cl">             
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="nx">ancestor</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而代码随想录使用的是后序遍历的方法，这首先需要你了解一个前提: 第一次遇到左右节点都找到某个值的时候那这个节点就是就深的祖先节点。</p>
<p>他是在返回和处理的时候有一些特别的方法，就像上面的一旦左右都返回！nil 那这个就是target 就一路返回(回溯)
单边有那就是那边找到了一路回溯上来的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">q</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>  <span class="p">{</span> <span class="c1">//  (left == NULL &amp;&amp; right == NULL)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h4 id="235-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4>
<p>这题简单不少，原因是可以利用二叉树的性质，基本不需要回溯。不断自顶向下遍历再根据根节点判断（利用上一题说的那个前提，很快就能写出正确的代码）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val   int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left  *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">min</span><span class="p">,</span><span class="nx">max</span><span class="o">:=</span><span class="nf">minMax</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="nx">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">findAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findAncestor</span><span class="p">(</span><span class="nx">root</span> <span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">max</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">val</span> <span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="nx">maxVal</span><span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="nx">max</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="nx">minVal</span><span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="nx">min</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">maxVal</span><span class="o">==</span><span class="nx">val</span><span class="o">||</span><span class="nx">minVal</span><span class="o">==</span><span class="nx">val</span><span class="o">||</span><span class="nx">maxVal</span><span class="p">&gt;</span><span class="nx">val</span><span class="o">&amp;&amp;</span><span class="nx">minVal</span><span class="p">&lt;</span><span class="nx">val</span><span class="p">{</span><span class="k">return</span> <span class="nx">root</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">maxVal</span><span class="p">&lt;</span><span class="nx">val</span><span class="p">{</span><span class="k">return</span> <span class="nf">findAncestor</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">max</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">findAncestor</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">max</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">).</span><span class="nx">Val</span><span class="p">&lt;(</span><span class="o">*</span><span class="nx">q</span><span class="p">).</span><span class="nx">Val</span><span class="p">{</span><span class="k">return</span> <span class="nx">p</span> <span class="p">,</span><span class="nx">q</span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">q</span><span class="p">,</span><span class="nx">p</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="450-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bsts"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/s">450. 删除二叉搜索树中的节点</a></h4>
<p>这个题算是BST中比较难的题目了，难点在于递归还有要分析的条件很多</p>
<ul>
<li>首先，题目只给了一个值，所以要先find，同时记录pre</li>
<li>找到tar 和 pre之后正式进入delete的逻辑</li>
<li>条件判断
<ul>
<li>没有右孩子:把左孩子提上来（根据parent 判断如何提)</li>
<li>有右孩子:初始化 pre和min 递归删除min然后把这个min提到tar的位置</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">pre</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">=</span><span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pre</span><span class="p">=</span><span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tar</span><span class="o">:=</span><span class="nf">find</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">tar</span><span class="o">!=</span><span class="nx">root</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">deleteNodeWithPre</span><span class="p">(</span><span class="nx">pre</span><span class="p">,</span><span class="nx">tar</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">root</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">deleteNodeWithPre</span><span class="p">(</span><span class="nx">pre</span><span class="p">,</span><span class="nx">tar</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deleteNodeWithPre</span><span class="p">(</span><span class="nx">pre</span><span class="p">,</span><span class="nx">tar</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">parent</span><span class="o">:=</span><span class="nx">pre</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">tar</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="nx">parent</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//without right son
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">parent</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//left or right son of parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Val</span><span class="p">&gt;(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Val</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Left</span><span class="p">=(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Right</span><span class="p">=(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">parent</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//with right son
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="nx">min</span><span class="o">:=</span><span class="p">(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Right</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pre</span><span class="p">=</span><span class="nx">tar</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="o">*</span><span class="nx">min</span><span class="p">).</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pre</span><span class="p">=</span><span class="nx">min</span>
</span></span><span class="line"><span class="cl">        <span class="nx">min</span><span class="p">=(</span><span class="o">*</span><span class="nx">min</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//delete right min
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">deleteNodeWithPre</span><span class="p">(</span><span class="nx">pre</span><span class="p">,</span><span class="nx">min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">*</span><span class="nx">min</span><span class="p">).</span><span class="nx">Left</span><span class="p">=(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nf">Left</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">*</span><span class="nx">min</span><span class="p">).</span><span class="nx">Right</span><span class="p">=(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Right</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">parent</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Val</span><span class="p">&gt;(</span><span class="o">*</span><span class="nx">tar</span><span class="p">).</span><span class="nx">Val</span><span class="p">{(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Left</span><span class="p">=</span><span class="nx">min</span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="nx">parent</span><span class="p">).</span><span class="nx">Right</span><span class="p">=</span><span class="nx">min</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">parent</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">min</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">find</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span><span class="o">==</span><span class="nx">key</span><span class="p">{</span><span class="k">return</span> <span class="nx">root</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pre</span><span class="p">=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">key</span><span class="p">{</span><span class="k">return</span> <span class="nf">find</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">,</span><span class="nx">key</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">find</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="669-修剪二叉搜索树httpsleetcodecnproblemstrim-a-binary-search-tree"><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4>
<p>这题也比较简单,判断然后递归自上而下就行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">low</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">trim</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">trim</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">low</span><span class="p">{</span><span class="k">return</span> <span class="nf">trim</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">high</span><span class="p">{</span><span class="k">return</span> <span class="nf">trim</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">=</span><span class="nf">trim</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">=</span><span class="nf">trim</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">root</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="538把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree"><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转换为累加树</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"> <span class="c1">//reversed inorder travesal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">// recursion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kd">var</span> <span class="nx">cur</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">convertBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cur</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reversedInorder</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">root</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reversedInorder</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reversedInorder</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span><span class="o">+=</span><span class="nx">cur</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cur</span> <span class="p">=(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reversedInorder</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其实就是从大到小遍历，注意要么参数和返回值构造回溯，要么使用全局变量。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>net/rpc</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/25/category/net/rpc/</link>
      <pubDate>Sat, 25 Feb 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/25/category/net/rpc/</guid>
      <description>glance at net/rpc 简介: 远程过程调用 (Remote Procedure Call，RPC) 是一种计算机通信协议。允许运行在一台计算机的程序调用另一个地址空间的子程序（一般是开放网络中的</description>
      <content:encoded><![CDATA[<h1 id="glance-at-netrpc">glance at net/rpc</h1>
<h2 id="简介">简介:</h2>
<p>远程过程调用 (Remote Procedure Call，RPC) 是一种计算机通信协议。允许运行在一台计算机的程序调用另一个地址空间的子程序（一般是开放网络中的一台计算机），而程序员就像调用调用本地程序一样，无需额外做交互编程。RPC 是一种 CS (Client-Server) 架构的模式，通过发送请求-接收响应的方式进行信息的交互<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<h2 id="heading"></h2>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://cloud.tencent.com/developer/article/1662215">Go net/rpc 包的深度解读和学习</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>二叉树（中）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/23/category/leetcode_day8/</link>
      <pubDate>Thu, 23 Feb 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/23/category/leetcode_day8/</guid>
      <description>二叉树(中) 层序遍历 和广度优先差不多 需要注意的是：要判断这层什么时候结束 我的方法是通过置一个nil作为结束，其实可以一趟一趟地看，先获取qu</description>
      <content:encoded><![CDATA[<h1 id="二叉树中">二叉树(中)</h1>
<h4 id="层序遍历">层序遍历</h4>
<p>和广度优先差不多</p>
<p>需要注意的是：要判断这层什么时候结束 我的方法是通过置一个nil作为结束，其实可以一趟一趟地看，先获取queue目前的长度这就是这一层的数量，然后按照这个size遍历就好。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">record</span> <span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">,</span><span class="kc">nil</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subAns</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="o">:=</span><span class="nx">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">=</span><span class="nx">record</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">            <span class="nx">subAns</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subAns</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span><span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span><span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">subAns</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">subAns</span><span class="p">=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>     
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相关题目：</p>
<ul>
<li>102.二叉树的层序遍历</li>
<li>107.二叉树的层次遍历II</li>
<li>199.二叉树的右视图</li>
<li>637.二叉树的层平均值</li>
<li>429.N叉树的层序遍历</li>
<li>515.在每个树行中找最大值</li>
<li>116.填充每个节点的下一个右侧节点指针</li>
<li>117.填充每个节点的下一个右侧节点指针II</li>
<li>104.二叉树的最大深度</li>
<li>111.二叉树的最小深度</li>
</ul>
<h4 id="反转二叉树">反转二叉树</h4>
<ul>
<li>一开始的想法是用层序遍历然后把每一层内的值reverse，然后发现有可能有不存在左子树但是有右子树的情况。
后改成把遍历到的每一个点的左节点和右节点交换，后pass。</li>
<li>问题是为什么可以，其实可以自己画图，最下层叶子节点是否成功可以转化成一个个小一点规模的问题，最后得以解决。</li>
</ul>
<h4 id="101-对称二叉树httpsleetcodecnproblemssymmetric-tree"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4>
<p>这题的话其实一开始想的是通过中序遍历遍历左子树，用先遍历右子树的中序遍历遍历右子树然后判断两个slice相等不相等的，但是理论证明还是比较困难。</p>
<p>这种题还是按照正常的流程来一个个遍历然后判断，其实递归的写法倒是不能写出来主要是要往那个方向去想。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">true</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">ifSymmetric</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ifSymmetric</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">right</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">||</span> <span class="nx">left</span><span class="o">!=</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">left</span><span class="p">).</span><span class="nx">Val</span><span class="o">!=</span><span class="p">(</span><span class="o">*</span><span class="nx">right</span><span class="p">).</span><span class="nx">Val</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">outside</span><span class="o">:=</span><span class="nf">ifSymmetric</span><span class="p">((</span><span class="o">*</span><span class="nx">left</span><span class="p">).</span><span class="nx">Left</span><span class="p">,(</span><span class="o">*</span><span class="nx">right</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">inside</span><span class="o">:=</span><span class="nf">ifSymmetric</span><span class="p">((</span><span class="o">*</span><span class="nx">left</span><span class="p">).</span><span class="nx">Right</span><span class="p">,(</span><span class="o">*</span><span class="nx">right</span><span class="p">).</span><span class="nx">Left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">outside</span><span class="o">&amp;&amp;</span><span class="nx">inside</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4>
<p>这题的话，一下就能感觉出来可以层序遍历这比较符合直觉。
但是，还是需要学习树的深度和高度怎么求</p>
<p>深度：
一般是前序遍历</p>
<p>高度：
通过后序遍历，主要的代码就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">getdepth</span><span class="p">(</span><span class="n">treenode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">leftdepth</span> <span class="o">=</span> <span class="n">getdepth</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>       <span class="c1">// 左
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rightdepth</span> <span class="o">=</span> <span class="n">getdepth</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>     <span class="c1">// 右
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">leftdepth</span><span class="p">,</span> <span class="n">rightdepth</span><span class="p">);</span> <span class="c1">// 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">maxdepth</span><span class="p">(</span><span class="n">treenode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">getdepth</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>求深度的话一般来说是会和层序遍历有关的，所以要多想层序遍历。</p>
<h4 id="222-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes"><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">pointer</span><span class="o">:=</span><span class="nx">root</span><span class="p">;</span><span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">;{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="p">=(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span> <span class="nf">getNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getNodes</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pointer</span><span class="o">:=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">h</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="p">=(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">h</span><span class="p">&lt;</span><span class="nx">height</span><span class="p">{</span><span class="k">return</span> <span class="nf">getCompleteNodes</span><span class="p">(</span><span class="nx">h</span><span class="p">),</span><span class="nx">h</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">right</span><span class="p">,</span><span class="nx">rightH</span><span class="o">:=</span><span class="nf">getNodes</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">,</span><span class="nx">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">rightH</span><span class="p">&gt;</span><span class="nx">height</span><span class="o">-</span><span class="mi">2</span><span class="p">{</span><span class="nx">left</span><span class="p">=</span><span class="nf">getCompleteNodes</span><span class="p">(</span><span class="nx">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">left</span><span class="p">,</span><span class="nx">_</span><span class="p">=</span><span class="nf">getNodes</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">,</span><span class="nx">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">left</span><span class="o">+</span><span class="nx">right</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">h</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getCompleteNodes</span><span class="p">(</span><span class="nx">height</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">float64</span><span class="p">(</span><span class="nx">height</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个题的话，自己的这个方法我感觉还是很不错的。
利用了完全二叉树的性质，从右边开始算高度，如果高度匹配，说明左子树一定是满二叉树，如果高度不匹配那么自己肯定是满二叉树。利用这个性质就能很快写出。</p>
<h4 id="110-平衡二叉树httpsleetcodecnproblemsbalanced-binary-tree"><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span><span class="p">,</span><span class="nx">balance</span><span class="o">:=</span><span class="nf">getHeightNBalance</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">balance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getHeightNBalance</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">bool</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="kc">true</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">leftHeight</span><span class="p">,</span><span class="nx">leftBalance</span><span class="o">:=</span><span class="nf">getHeightNBalance</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rightHeight</span><span class="p">,</span><span class="nx">rightBalance</span><span class="o">:=</span><span class="nf">getHeightNBalance</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!(</span><span class="nx">leftBalance</span><span class="o">&amp;&amp;</span><span class="nx">rightBalance</span><span class="p">){</span><span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="kc">false</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">balance</span><span class="o">:=</span><span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Abs</span><span class="p">(</span><span class="kt">float64</span> <span class="p">(</span><span class="nx">leftHeight</span><span class="o">-</span><span class="nx">rightHeight</span><span class="p">)))&gt;</span><span class="mi">1</span> <span class="p">{</span><span class="nx">balance</span><span class="p">=</span><span class="kc">false</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="nx">leftHeight</span><span class="p">,</span><span class="nx">rightHeight</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">balance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">a</span><span class="p">&gt;</span><span class="nx">b</span><span class="p">{</span><span class="k">return</span> <span class="nx">a</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这题不难，注意求高度，后序遍历注意一下递归的三条件就ok</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>二叉树（上）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/22/category/leetcode_day7/</link>
      <pubDate>Wed, 22 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/22/category/leetcode_day7/</guid>
      <description>二叉树(上) 二叉树的递归遍历: 这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递</description>
      <content:encoded><![CDATA[<h1 id="二叉树上">二叉树(上)</h1>
<h3 id="二叉树的递归遍历">二叉树的递归遍历:</h3>
<blockquote>
<p>这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</p>
</blockquote>
<blockquote>
<ol>
<li>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
</blockquote>
<p>理解下来就是:</p>
<ul>
<li>终止条件</li>
<li>返回(其实也是循环入口)</li>
<li>单层的处理</li>
</ul>
<h4 id="前序遍历">前序遍历</h4>
<p>递归法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type TreeNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Left *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Right *TreeNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span><span class="o">:=</span><span class="nf">preorderTraversal</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">right</span><span class="o">:=</span><span class="nf">preorderTraversal</span><span class="p">((</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]=(</span><span class="o">*</span><span class="nx">root</span><span class="p">).</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="nb">copy</span><span class="p">(</span><span class="nx">ans</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="nx">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">copy</span><span class="p">(</span><span class="nx">ans</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="nx">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>迭代法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stack</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="o">:=*</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">pointer</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span> <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">pointer</span><span class="p">.</span><span class="nx">Right</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span> <span class="nx">stack</span><span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">pointer</span><span class="p">.</span><span class="nx">Left</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于迭代法来说，重要的是找到如何入栈和出栈。</p>
<ul>
<li>一开始想的是不断把遍历到的节点入栈，但其实只要把右节点和左节点先后入就可以了。这样每次遇到新的节点都是一样的处理逻辑，而不用考虑是新节点还是回溯的节点。</li>
<li>代码随想录里面的理解是:插入节点的值（插入ans）和处理节点（记录左右子节点的地址）都可以一起完成。</li>
</ul>
<h4 id="中序遍历">中序遍历:</h4>
<ul>
<li>这个就很不一样了，因为他就是不符合上面说的插入值和处理节点同时完成。</li>
<li>也像我说的，新遇到一个节点还是回溯遇到节点是不一样的，所以我们要把他的这两步分开处理,而且可能回溯遇到两次同一个节点。</li>
</ul>
<p>具体来说，也就是一直入栈的时候处理，出栈的时候记录值，并且这个时候把这个根出栈了就不会再遇到了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>  <span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stack</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pointer</span><span class="o">:=</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="o">||</span><span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">pointer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pointer</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="nx">pointer</span><span class="p">=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">pointer</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">((</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="nx">pointer</span><span class="p">=(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="后序遍历">后序遍历</h4>
<p>后序遍历的话符合我们之前说的要求，所以第一次遇到的时候就可以处理并记录。
但是要注意记录的时候本来应该把它放在最后面的，但是具体实现起来不好从后向前append，所以采用从前向后然后reverse</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="o">:=</span><span class="nx">record</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">=</span> <span class="nx">record</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span> <span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span> <span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reverse</span><span class="p">(</span><span class="nx">ans</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nx">j</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">in</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">in</span><span class="p">[</span><span class="nx">j</span><span class="p">]=</span><span class="nx">in</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">in</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nx">j</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="三种遍历的统一写法">三种遍历的统一写法:</h4>
<ul>
<li>核心思想是标记法: 实际上人在遍历的回溯的时候会下意识的辨别出这个节点是新的还是已经见过的。</li>
<li>所以在stack中我们就是要把上面的两种操作分开，没有标记的是新节点，前面有个null标记的就是只存值的节点。(和转义的思想差不多)</li>
</ul>
<p>浅浅模仿写了个中序遍历的，不同的遍历只需要在遇到新节点后改变左中右的插入顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pointer</span><span class="o">:=</span><span class="nx">record</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pointer</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">record</span><span class="p">=</span><span class="nx">record</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span> <span class="nx">record</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Right</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nx">record</span><span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,</span><span class="nx">pointer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">record</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span><span class="nx">record</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Left</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pointer</span><span class="p">=</span><span class="nx">record</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,(</span><span class="o">*</span><span class="nx">pointer</span><span class="p">).</span><span class="nx">Val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">record</span><span class="p">=</span><span class="nx">record</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>栈与队列</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/17/category/leetcode_day6/</link>
      <pubDate>Fri, 17 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/17/category/leetcode_day6/</guid>
      <description>栈与队列 用栈实现队列 用两个栈实现队列 比较简单，就是一个输入一个输出。可以理解为负负得正(先进后出*2=先进先出) 用队列实现栈 用队列实现栈 这个</description>
      <content:encoded><![CDATA[<h2 id="栈与队列">栈与队列</h2>
<h4 id="用栈实现队列">用栈实现队列</h4>
<blockquote>
<p>用两个栈实现队列
比较简单，就是一个输入一个输出。可以理解为负负得正(先进后出*2=先进先出)</p>
</blockquote>
<h4 id="用队列实现栈">用队列实现栈</h4>
<blockquote>
<p>用队列实现栈
这个的话复杂一点，我的方法会比较麻烦，是在每次push后把之前的push进这个队列，然后交换。这样的话每次push都会O(n)，时间复杂度比较高。</p>
</blockquote>
<p>优化的话应该是每次pop的时候更新。</p>
<p>其实这样还是会pop时间复杂度O(n)，但是一般pop的次数比push少</p>
<p>那最简化就是，不作任何存储上的简化，只用一个队列并且一直pop再push到最后一个然后pop出去就行。</p>
<h4 id="20-有效的括号httpsleetcodecnproblemsvalid-parentheses"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4>
<p>也比较简单，就是用栈就行了。一遍过</p>
<h4 id="1047-删除字符串中的所有相邻重复项httpsleetcodecnproblemsremove-all-adjacent-duplicates-in-string"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4>
<p>也比较简单，和上面的题目差不多。</p>
<p>这种题主要是要辨别出使用栈</p>
<ul>
<li>需要记录最近使用过的元素，并且带有删除现在的，找之前可能是最近使用过的。</li>
</ul>
<h4 id="逆波兰表达式httpsleetcodecnproblemsevaluate-reverse-polish-notation"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式</a></h4>
<p>也比较简单吧，可能是以前做过，但是字符串和int转换的库函数不熟悉。
趁这个题多了解了解。</p>
<p>学习一下别人的写法
我的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evalRPN</span><span class="p">(</span><span class="nx">tokens</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">number</span><span class="o">:=</span><span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokens</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="nx">tokens</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;+&#34;</span><span class="p">:</span> <span class="k">fallthrough</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;-&#34;</span><span class="p">:</span> <span class="k">fallthrough</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;*&#34;</span><span class="p">:</span> <span class="k">fallthrough</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;/&#34;</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">            <span class="nx">operandA</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">number</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="p">=</span><span class="nx">number</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">operandB</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">number</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="p">=</span><span class="nx">number</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">number</span><span class="p">,</span><span class="nf">calculate</span><span class="p">(</span><span class="nx">tokens</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">operandA</span><span class="p">,</span><span class="nx">operandB</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">number</span><span class="p">,</span><span class="nx">tokens</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">number</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calculate</span><span class="p">(</span><span class="nx">operator</span> <span class="kt">string</span><span class="p">,</span><span class="nx">operandA</span> <span class="kt">int</span><span class="p">,</span><span class="nx">operandB</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">ans</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">operator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;+&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">operandB</span><span class="o">+</span><span class="nx">operandA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;-&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">operandB</span><span class="o">-</span><span class="nx">operandA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;*&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">operandB</span><span class="o">*</span><span class="nx">operandA</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;/&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">operandB</span><span class="o">/</span><span class="nx">operandA</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>好的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">evalRPN</span><span class="p">(</span><span class="nx">tokens</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">token</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tokens</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">val</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>   <span class="c1">// 如果err不为nil说明不是数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="nx">stack</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="k">switch</span> <span class="nx">token</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="s">&#34;+&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">num1</span><span class="o">+</span><span class="nx">num2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="s">&#34;-&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">num1</span><span class="o">-</span><span class="nx">num2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="s">&#34;*&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">num1</span><span class="o">*</span><span class="nx">num2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="s">&#34;/&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">num1</span><span class="o">/</span><span class="nx">num2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>学到的写法:</p>
<ul>
<li>go出栈可以一次出两个</li>
<li>可以利用strconv.Atoi的err判断是否为数字</li>
<li>存在栈的最好是int</li>
</ul>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值 hard</a></p>
<blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
</blockquote>
<blockquote>
<p>返回 滑动窗口中的最大值 。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">maxSlidingWindow</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">window</span><span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">k</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">window</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]&lt;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">window</span><span class="p">=</span><span class="nx">window</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">window</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">window</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="nx">k</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">window</span><span class="p">=</span><span class="nx">window</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">window</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]&lt;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">k</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">window</span><span class="p">=</span><span class="nx">window</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">window</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">window</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">window</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这题还是比较难的，主要是每次移动窗口的时候保存需要的信息不知道用什么数据结构。
这题引入了单调队列，非常适合。</p>
<p>单调队列：
队列中的数据有序排列，这主要通过push时候的不断检查来达到。</p>
<h4 id="347-前-k-个高频元素httpsleetcodecnproblemstop-k-frequent-elements"><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4>
<blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Iheap</span> <span class="p">[][</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span> <span class="nx">h</span> <span class="nx">Iheap</span> <span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span><span class="p">{</span><span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Iheap</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span> <span class="k">return</span> <span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]&lt;</span><span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">Iheap</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">){</span><span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">]=</span><span class="nx">h</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">h</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Iheap</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span><span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">)[</span><span class="nb">len</span><span class="p">((</span><span class="o">*</span><span class="nx">h</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">h</span><span class="p">=(</span><span class="o">*</span><span class="nx">h</span><span class="p">)[:</span><span class="nb">len</span><span class="p">((</span><span class="o">*</span><span class="nx">h</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">Iheap</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">h</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">,</span><span class="nx">i</span><span class="p">.([</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">iHeap</span><span class="o">:=&amp;</span><span class="nx">Iheap</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">heap</span><span class="p">.</span><span class="nf">Init</span><span class="p">(</span><span class="nx">iHeap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">record</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">heap</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="nx">iHeap</span><span class="p">,[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">iHeap</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="nx">k</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">heap</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">iHeap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span> <span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">k</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">heap</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="nx">iHeap</span><span class="p">).([</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这题也是比较经典的题目了:</p>
<ul>
<li>考察优先队列(堆)</li>
<li>golang实现(实现sort.Interface和heap.Interface)注意的是Push和Pop需要pointer receiver。</li>
<li>求最大的k个需要建立最小堆，vice versa。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022  年终总结</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/15/category/2022_review/</link>
      <pubDate>Wed, 15 Feb 2023 16:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/15/category/2022_review/</guid>
      <description>2022 年终总结 学业&amp;amp;科研 学业 目前rank:19/270+ 一些课程: DB(数据库系统):93 Network(计算机网络):92 OS(操作系</description>
      <content:encoded><![CDATA[<h2 id="2022-年终总结">2022 年终总结</h2>
<h3 id="学业科研">学业&amp;科研</h3>
<h4 id="学业">学业</h4>
<p>目前rank:19/270+</p>
<p>一些课程:</p>
<ul>
<li>DB(数据库系统):93</li>
<li>Network(计算机网络):92</li>
<li>OS(操作系统): 87</li>
<li>UML(软件分析设计与建模):86
&hellip;</li>
</ul>
<p>大一下: 由于降级的原因, 大一下上了大二下的课, 但实际上感觉load也不是很重(华工的课懂得都懂, 负责的老师也就是ppt讲得好, 课程质量不行)。</p>
<p>暑假: 抽空做了个简陋的<a href="http://119.29.53.176:8080/">ERP</a>(努力了半个月),</p>
<p>大二上: 同样由于降级，大一上把大二上的课上完了，导致我这学期其实就只有概论和JAVA课,下学期的重心主要放在了科研上，成天泡在实验室里面。</p>
<h4 id="科研">科研</h4>
<p>在勋龙的指导下，选择进mk的实验室实习，时间节点大概是大一下的期末。</p>
<p>开始的时候是看CS231n，学习DL和CV的基础。做了下里面的lab掌握了</p>
<p>TODO&hellip;</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/15/category/leetcode_day5/</link>
      <pubDate>Wed, 15 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/15/category/leetcode_day5/</guid>
      <description>字符串 剑指offer 5 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。 题目不难 要注意首先拓展长度,必须遍历,无论</description>
      <content:encoded><![CDATA[<h2 id="字符串">字符串</h2>
<p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指offer 5</a></p>
<blockquote>
<p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p>
</blockquote>
<p>题目不难</p>
<ol>
<li>要注意首先拓展长度,必须遍历,无论怎么样都是O(n),所以不要怕,大胆遍历</li>
<li>双指针从后往前替换，这样不会覆盖，因为新的空间是在后面的。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">spaceCount</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算空格数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">spaceCount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 扩展原有切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">resizeCount</span> <span class="o">:=</span> <span class="nx">spaceCount</span> <span class="o">*</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">resizeCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">tmp</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">i</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;0&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;2&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;%&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">i</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/">151 反转单词</a></p>
<blockquote>
<p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
</blockquote>
<blockquote>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
</blockquote>
<blockquote>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
</blockquote>
<blockquote>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">=</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Trim</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="s">&#34; &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cnt</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39; &#39;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">cnt</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39; &#39;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">cnt</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">str</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">cnt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="p">=</span><span class="nx">j</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39; &#39;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">str</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">str</span><span class="p">,[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">str</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39; &#39;</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">i</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">j</span><span class="p">=</span><span class="nx">i</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">str</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>我的方法是去首尾空格，然后从后遍历填入新字符串。</li>
<li>但是如果考虑O(1)的空间复杂的话，还是应该像题解那样全部反转然后再每个每个单词反转。</li>
</ul>
<p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">leetcode 剑指offer 58</a></p>
<blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
</blockquote>
<p>我的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reverseLeftWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">str</span><span class="o">:=</span><span class="p">[]</span><span class="kt">byte</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subStr</span><span class="o">:=</span><span class="nx">str</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">str</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">n</span><span class="p">:],</span><span class="nx">subStr</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>进阶:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reverseLeftWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 反转前n个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. 反转第n到end字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3. 反转整个字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">reverse</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reverse</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">reverse</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 切片是引用传递
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">left</span> <span class="p">&lt;</span> <span class="nx">right</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span> <span class="nx">b</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">right</span><span class="p">],</span><span class="nx">b</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nx">left</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="nx">right</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样就不会浪费空间，都是inplace的操作，但是我的队列的方法其实也不错的。</p>
<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28 找出字符串中第一个匹配项的下标</a></p>
<blockquote>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
</blockquote>
<p>实在是有点难的,KMP算法。</p>
<ul>
<li>核心思想：通过挖掘needle本身的信息，在遍历到不符合的情况的时候回退到下一个匹配的地方。</li>
<li>实现:
<ul>
<li>前缀表<em>next</em>:与needle长度一样的数组记录当i的下一个不匹配的时候回退到哪里。</li>
</ul>
</li>
</ul>
<p>在理解了以后自己写的解法，next以-1为不匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span><span class="o">:=-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="nx">j</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">needle</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">!=</span><span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="p">=</span><span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">needle</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">           <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">j</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">j</span><span class="p">,</span><span class="nx">i</span><span class="o">:=-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">!=</span><span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="p">=</span><span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">j</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">i</span><span class="o">-</span><span class="nx">j</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://s2.loli.net/2023/02/16/CPxoeJkuLG7R2Zn.jpg" alt="527ea3ee04f0d1ef5b88088320d65de.jpg">
<img src="https://s2.loli.net/2023/02/16/ACrvs562eY1SxbK.jpg" alt="f20512dd15e285cb0ec1406892710ce.jpg"></p>
<p>差不多也是用KMP的一道题:
<a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span><span class="o">:=-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="p">=</span><span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">next</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">j</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">next</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="nb">len</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="nx">next</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>学到的东西</p>
<ul>
<li>在这里KMP的next数组在遇到true的情况下一般是
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>可以发现的在第一个重复之后后面的都是不断增加，因为前后缀都是一样的，所以如果是true的情况，最后一个的next[len(next)-1]后面的就是最小子字符串。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>正确性分析:
一些数学的验证在<a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#kmp">代码随想录</a></li>
<li>我说说我的理解:
<ul>
<li>next[len(next)-1]==-1:直接否定</li>
<li>next[len(next)-1]&lt;len(next): 按照上面的假设(next[len(next)-1]后面的就是最小子字符串)这样的话len(s)整除不了这个最小子字符串</li>
<li>next[len(next)-1]&gt;=len(next):  按照上面的假设(next[len(next)-1]后面的就是最小子字符串)
<img src="https://s2.loli.net/2023/02/17/xh5u2AebFYisyaV.jpg" alt="0797d040c71e6efcf263347f4aa37cc.jpg"></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/12/category/leetcode_day4/</link>
      <pubDate>Sun, 12 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/12/category/leetcode_day4/</guid>
      <description>哈希表 哈希碰撞的两个解决方法: 拉链法 线性探测 常见的哈希表: 数组 set map 有关红黑树，见红黑树深入剖析及Java实现 RBTree的定义 RBTree的</description>
      <content:encoded><![CDATA[<h2 id="哈希表">哈希表</h2>
<p>哈希碰撞的两个解决方法:</p>
<ol>
<li>拉链法
<img src="https://img-blog.csdnimg.cn/20210104235015226.png" alt=""></li>
<li>线性探测
<img src="https://img-blog.csdnimg.cn/20210104235109950.png" alt=""></li>
</ol>
<p>常见的哈希表:</p>
<ol>
<li>
<p>数组</p>
</li>
<li>
<p>set</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/02/12/y6YRtcNObwFrE3j.jpg" alt="23-02-12-set.JPG"></p>
<ol start="3">
<li>map
<img src="https://s2.loli.net/2023/02/13/LYFdkshWVyco84P.png" alt="xiaz.png"></li>
</ol>
<p>有关红黑树，见<a href="https://tech.meituan.com/2016/12/02/redblack-tree.html">红黑树深入剖析及Java实现</a></p>
<p>RBTree的定义
RBTree的定义如下:</p>
<ul>
<li>任何一个节点都有颜色，黑色或者红色。</li>
<li>根节点是黑色的。</li>
<li>父子节点之间不能出现两个连续的红节点。</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。</li>
<li>空节点被认为是黑色的。</li>
</ul>
<p><a href="https://juejin.cn/post/6972535873971847204">golang 字典的底层</a></p>
<h3 id="例题">例题</h3>
<h4 id="leetcode-242-easyhttpsleetcodecnproblemsvalid-anagramsubmissions"><a href="https://leetcode.cn/problems/valid-anagram/submissions/">leetcode 242 easy</a></h4>
<blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
</blockquote>
<blockquote>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
my version</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sMap</span><span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">i</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">i</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">t</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">tMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sMap</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="nx">tMap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">sMap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">v</span><span class="o">==</span><span class="nx">tMap</span><span class="p">[</span><span class="nx">k</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>better version</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">[</span><span class="nx">r</span><span class="o">-</span><span class="nb">rune</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">[</span><span class="nx">r</span><span class="o">-</span><span class="nb">rune</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)]</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">record</span> <span class="o">==</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>   <span class="c1">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>把数组看出hash map，同时只用一个hash表就完成比较，最后的判断比较零也很巧妙(因为数组的每个元素都是可以比较的所以可以直接用等于。)</p>
<p>相关题目:</p>
<ul>
<li>383.赎金信</li>
<li>49.字母异位词分组</li>
<li>438.找到字符串中所有字母异位词</li>
</ul>
<h4 id="383-赎金信httpsleetcodecnproblemsransom-note"><a href="https://leetcode.cn/problems/ransom-note/">383 赎金信.</a></h4>
<p>也是需要优化，不能直接用map(要维护一个哈希表或者红黑树),面对这种单词的出现的哈希，要注意用26字母的数组来代替。</p>
<blockquote>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
</blockquote>
<blockquote>
<p>如果可以，返回 true ；否则返回 false 。</p>
</blockquote>
<blockquote>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">canConstruct</span><span class="p">(</span><span class="nx">ransomNote</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">magazine</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">magazine</span> <span class="p">{</span>   <span class="c1">// 通过recode数据记录 magazine里各个字符出现次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">record</span><span class="p">[</span><span class="nx">v</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ransomNote</span> <span class="p">{</span> <span class="c1">// 遍历ransomNote，在record里对应的字符个数做--操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">record</span><span class="p">[</span><span class="nx">v</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">record</span><span class="p">[</span><span class="nx">v</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>     <span class="c1">// 如果小于零说明ransomNote里出现的字符，magazine没有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从优秀的解法中可以学到:</p>
<ul>
<li>利用固定数组代替map(set)</li>
<li>首先把有的用数组记录下来, 然后遍历需要的然后一个个减，这样的话小于零就是不满足。我的是反过来，这样的话要记录目标==0，然后记录次数与length相比。这样是比较麻烦的。</li>
</ul>
<h4 id="leetcode-49字母异位词分组httpsleetcodecnproblemsgroup-anagrams"><a href="https://leetcode.cn/problems/group-anagrams/">leetcode 49.字母异位词分组</a></h4>
<blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
</blockquote>
<blockquote>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
</blockquote>
<p>这题也是有点难</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">record</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">][]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">strs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cnt</span><span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">i</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">cnt</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">record</span><span class="p">[</span><span class="nx">cnt</span><span class="p">]=</span><span class="nb">append</span><span class="p">(</span><span class="nx">record</span><span class="p">[</span><span class="nx">cnt</span><span class="p">],</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">record</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">record</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>总结:</p>
<ul>
<li>这个哈希我其实有想到，但是对于key和value的数据结构还是不是很了解，key: [26]int value []string, 所以没有写出来</li>
</ul>
<h4 id="leetcode-438-找到字符串中所有字母异位词httpsleetcodecnproblemsfind-all-anagrams-in-a-string"><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">leetcode 438. 找到字符串中所有字母异位词</a></h4>
<blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
</blockquote>
<blockquote>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">findAnagrams</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">p</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">target</span><span class="p">[</span><span class="nx">v</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">source</span><span class="o">:=</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">right</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">right</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">source</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">right</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">source</span><span class="o">==</span><span class="nx">target</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span><span class="nx">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">right</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">right</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nx">source</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                <span class="nx">source</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                <span class="nx">left</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>总结:</p>
<ul>
<li>第一次错误: 写了一步特殊的 source[s[left]-&lsquo;a&rsquo;]这样不具有普遍性,应该把添加节点的操作放进for 用right来加入。</li>
<li>第二次错误: 在第一个for 的if 里面处理第二个for，没有考虑第一个<em>for</em>退出的时候也需要处理第二个for，正确的做法是：第一个<em>for</em>+在第二个<em>for</em>中统一考虑第一个for结束的两种情况。</li>
</ul>
<h4 id="leetcode-15-三数之和httpsleetcodecnproblems3sum"><a href="https://leetcode.cn/problems/3sum/">leetcode 15. 三数之和</a></h4>
<blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
</blockquote>
<blockquote>
<p>你返回所有和为 0 且不重复的三元组。</p>
</blockquote>
<blockquote>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<ul>
<li>确实很难，如果用2sum的哈希表方法去重逻辑非常复杂，就是不会去重。</li>
<li>注意到是可以排序的，不管用什么方法都要排序。可见在去重中，排序的很重要的手段。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">threeSum</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ans</span><span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">i</span><span class="p">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">j</span><span class="o">:=</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="nx">k</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">k</span><span class="p">&gt;</span><span class="nx">j</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">k</span><span class="p">]&gt;</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">k</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">k</span><span class="p">]&lt;</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">ans</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">k</span><span class="p">]})</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="nx">k</span><span class="p">&gt;</span><span class="nx">j</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">break</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="nx">k</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="nx">k</span><span class="p">&gt;</span><span class="nx">j</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">==</span><span class="nx">nums</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">break</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ans</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>四数之和就是建立在三数之和的基础上的了。
还要注意的是，开头可以剪枝，就是排序之后判断第一个。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>链表(下)</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/09/category/leetcode_day3/</link>
      <pubDate>Thu, 09 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/09/category/leetcode_day3/</guid>
      <description>链表(下) leetcode 206. 简单一遍过 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head==nil || head.Next==nil{ return</description>
      <content:encoded><![CDATA[<h2 id="链表下">链表(下)</h2>
<p>leetcode 206. 简单一遍过</p>
<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type ListNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Next *ListNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reverseList</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">head</span><span class="o">==</span><span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">first</span> <span class="o">*</span><span class="nx">ListNode</span>
</span></span><span class="line"><span class="cl">    <span class="nx">second</span> <span class="o">:=</span> <span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="nx">third</span> <span class="o">:=</span> <span class="nx">second</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">third</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">second</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">first</span>
</span></span><span class="line"><span class="cl">        <span class="nx">first</span><span class="p">=</span><span class="nx">second</span>
</span></span><span class="line"><span class="cl">        <span class="nx">second</span><span class="p">=</span><span class="nx">third</span>
</span></span><span class="line"><span class="cl">        <span class="nx">third</span><span class="p">=</span><span class="nx">second</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">second</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">first</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">second</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">leetcode 24</a></p>
<blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type ListNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Next *ListNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dommy</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="nx">head</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">first</span><span class="o">:=</span> <span class="nx">dommy</span>
</span></span><span class="line"><span class="cl">    <span class="nx">second</span> <span class="o">:=</span> <span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">second</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">second</span><span class="p">.</span><span class="nx">Next</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">first</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">second</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="nx">second</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">first</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="nx">first</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">second</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">first</span><span class="p">=</span><span class="nx">second</span>
</span></span><span class="line"><span class="cl">        <span class="nx">second</span><span class="p">=</span><span class="nx">second</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">dommy</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>不算难，用虚拟头节点模拟就行。</p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">leetcode 19.</a></p>
<blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type ListNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Next *ListNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">nodeB</span><span class="o">:=</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dommy</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="nx">head</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nodeA</span><span class="o">:=</span><span class="nx">dommy</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nodeB</span><span class="p">=</span><span class="nx">nodeB</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">nodeB</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nodeB</span><span class="p">=</span><span class="nx">nodeB</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nodeA</span><span class="p">=</span><span class="nx">nodeA</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nodeA</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">nodeA</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">dommy</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">leetcode 面试题 02.07</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type ListNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Next *ListNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getIntersectionNode</span><span class="p">(</span><span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">headA</span><span class="o">==</span><span class="kc">nil</span> <span class="o">||</span> <span class="nx">headB</span> <span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">pa</span> <span class="p">,</span><span class="nx">pb</span><span class="o">:=</span> <span class="nx">headA</span><span class="p">,</span><span class="nx">headB</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">pa</span><span class="o">!=</span><span class="nx">pb</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pa</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pa</span><span class="p">=</span><span class="nx">pa</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pa</span> <span class="p">=</span> <span class="nx">headB</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">pb</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pb</span><span class="p">=</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">pb</span> <span class="p">=</span> <span class="nx">headA</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">pa</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>本来的想法也是，双指针一起移动，但是两个的长度不一样，可能移动的过程中并不能相遇到一起，但是利用等差数列求和的思想，补齐就可以。详情见<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solution/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/">题解</a></p>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">leetcode 142. 环形链表 II</a></p>
<p><em>Crazy 的一题</em></p>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for singly-linked list.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * type ListNode struct {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Val int
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     Next *ListNode
</span></span></span><span class="line"><span class="cl"><span class="cm"> * }
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">slow</span><span class="p">,</span> <span class="nx">fast</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">,</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">fast</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fast</span><span class="p">=</span><span class="nx">fast</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slow</span><span class="p">=</span> <span class="nx">slow</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">slow</span><span class="o">==</span><span class="nx">fast</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">cur</span><span class="o">:=</span> <span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">cur</span><span class="o">!=</span><span class="nx">slow</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cur</span><span class="p">=</span><span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">        <span class="nx">slow</span><span class="p">=</span><span class="nx">slow</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">cur</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>建议直接看<a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">神级题解</a></p>
<p>看完题解之后的感受是:</p>
<ul>
<li>这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。</li>
<li>要对数量关系进行建模理解</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>模拟，链表(上)</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/07/category/leetcode_day2/</link>
      <pubDate>Tue, 07 Feb 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/07/category/leetcode_day2/</guid>
      <description>模拟，链表(上) 模拟 以leetcode 59.螺旋矩阵为例: 相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。 结果运行的时候各种问题</description>
      <content:encoded><![CDATA[<h2 id="模拟链表上">模拟，链表(上)</h2>
<h3 id="模拟">模拟</h3>
<p>以leetcode 59.螺旋矩阵为例:</p>
<blockquote>
<p>相信很多同学刚开始做这种题目的时候，上来就是一波判断猛如虎。</p>
</blockquote>
<blockquote>
<p>结果运行的时候各种问题，然后开始各种修修补补，最后发现改了这里那里有问题，改了那里这里又跑不起来了。</p>
</blockquote>
<p>说的就是我了(捂脸)</p>
<p>题目：</p>
<blockquote>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
</blockquote>
<p>我的answer</p>
<p>值得注意的是二维切片的创建与初始化</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//golang
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">generateMatrix</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">number</span><span class="o">:=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out</span><span class="o">:=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="k">range</span><span class="p">(</span><span class="nx">out</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">terms</span><span class="o">:=</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">t</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">t</span><span class="p">&lt;</span><span class="nx">terms</span><span class="p">;</span><span class="nx">t</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">t</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">n</span><span class="o">-</span><span class="nx">t</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="nx">out</span><span class="p">[</span><span class="nx">t</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="nx">number</span>
</span></span><span class="line"><span class="cl">           <span class="nx">number</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">           
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">out</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">]=</span><span class="nx">number</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">n</span><span class="o">-</span><span class="nx">t</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="nx">t</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">number</span><span class="o">==</span><span class="nx">n</span><span class="o">*</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">out</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">][</span><span class="nx">i</span><span class="p">]=</span><span class="nx">number</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">           
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="nx">t</span><span class="p">;</span><span class="nx">j</span><span class="o">&gt;=</span><span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">out</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">t</span><span class="p">]=</span><span class="nx">number</span>
</span></span><span class="line"><span class="cl">            <span class="nx">number</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>和我的思路一样但是更清晰的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// 使用vector定义一个二维数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">startx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">starty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 定义每循环一个圈的起始位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用来给矩阵中每一个空格赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">loop</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">=</span> <span class="n">startx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">=</span> <span class="n">starty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 下面开始的四个for就是模拟转了一圈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 模拟填充上行从左到右(左闭右开)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">starty</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="p">[</span><span class="n">startx</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模拟填充右列从上到下(左闭右开)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">startx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模拟填充下行从右到左(左闭右开)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">starty</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 模拟填充左列从下到上(左闭右开)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">startx</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">startx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">starty</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// offset 控制每一圈里每一条边遍历的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><hr>
<p>从这个可以学到的：</p>
<ul>
<li>对角线遍历来等价一圈一圈。</li>
<li>起点和终点都有收缩，对应到代码就是startx,starty, offset。</li>
<li>利用左闭右开，上下和左右等价对待。</li>
</ul>
<p>顶级c++</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// top
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// bottom
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// left
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="n">ans</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">t</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">b</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">--</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">l</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">,</span><span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="n">ans</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">--</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">b</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">t</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">,</span><span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="链表">链表</h3>
<p>套路：</p>
<p>构造单链表</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//cpp
</span></span></span><span class="line"><span class="cl"><span class="c1">// 单链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// 节点上存储的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// 指向下一个节点的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 节点的构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//golang
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ListNode</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Val</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Next</span> <span class="o">*</span><span class="nx">ListNode</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>删除的话一般需要知道这个节点的前一个节点添加节点的话几乎也是</p>
<p>所以遇到添加或者删除一般要提前一个删除，但是这样的话head没有判断，所以最后判断一次就ok</p>
<p>然而后面又学到一个骚方法</p>
<p>设置一个虚假的头节点，那么真head就是中间节点了(亏贼)</p>
<p><strong>一般要先判断链表是否没有元素，没有元素不能next，而就算有一个也能next</strong></p>
<p>leetcode 707.</p>
<blockquote>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
</blockquote>
<blockquote>
<p>在链表类中实现这些功能：</p>
</blockquote>
<blockquote>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Length</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Head</span>   <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Tail</span>   <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Val</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Next</span> <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Prev</span> <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">list</span> <span class="o">:=</span> <span class="nx">MyLinkedList</span><span class="p">{</span><span class="nx">Length</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nx">Head</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span><span class="nx">Tail</span><span class="p">:</span><span class="kc">nil</span><span class="p">,}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">list</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">GetOne</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">cursor</span> <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">index</span><span class="o">&gt;=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">/</span><span class="mi">2</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">gap</span><span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">index</span>
</span></span><span class="line"><span class="cl">            <span class="nx">cursor</span><span class="p">=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">gap</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">cursor</span><span class="p">=</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">Prev</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">gap</span><span class="o">:=</span> <span class="nx">index</span><span class="o">-</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="nx">cursor</span><span class="p">=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Head</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">gap</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">cursor</span><span class="p">=</span><span class="nx">cursor</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">cursor</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span><span class="o">&gt;=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cursor</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nf">GetOne</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">cursor</span><span class="p">.</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nodeP</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span><span class="nx">Prev</span><span class="p">:</span><span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">=</span><span class="nx">nodeP</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">=</span><span class="nx">nodeP</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">node</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">,</span><span class="nx">Prev</span><span class="p">:</span><span class="kc">nil</span><span class="p">,}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">.</span><span class="nx">Prev</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nodeP</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span><span class="nx">Prev</span><span class="p">:</span><span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">=</span><span class="nx">nodeP</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">=</span><span class="nx">nodeP</span>
</span></span><span class="line"><span class="cl">        <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">node</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span><span class="nx">Prev</span><span class="p">:</span><span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">,}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">    <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span><span class="p">&gt;</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">index</span><span class="o">==</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">this</span><span class="p">.</span><span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">index</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">nodeP</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nf">GetOne</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevP</span> <span class="o">:=</span> <span class="nx">nodeP</span><span class="p">.</span><span class="nx">Prev</span>
</span></span><span class="line"><span class="cl">                <span class="nx">newNode</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">,</span><span class="nx">Next</span><span class="p">:</span><span class="nx">nodeP</span><span class="p">,</span><span class="nx">Prev</span><span class="p">:</span><span class="nx">nodeP</span><span class="p">.</span><span class="nx">Prev</span><span class="p">,}</span>
</span></span><span class="line"><span class="cl">                <span class="nx">nodeP</span><span class="p">.</span><span class="nx">Prev</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">newNode</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevP</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">newNode</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span><span class="p">&lt;</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">&amp;&amp;</span> <span class="nx">index</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">index</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">            <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nx">Head</span><span class="p">.</span><span class="nx">Prev</span><span class="p">=</span><span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">index</span><span class="o">==</span><span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">-</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">=</span><span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Prev</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">this</span><span class="p">.</span><span class="nx">Tail</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="kc">nil</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">nodeP</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nf">GetOne</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevP</span><span class="o">:=</span><span class="nx">nodeP</span><span class="p">.</span><span class="nx">Prev</span>
</span></span><span class="line"><span class="cl">                <span class="nx">nextP</span><span class="o">:=</span><span class="nx">nodeP</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">                <span class="nx">prevP</span><span class="p">.</span><span class="nx">Next</span><span class="p">=</span><span class="nx">nextP</span>
</span></span><span class="line"><span class="cl">                <span class="nx">nextP</span><span class="p">.</span><span class="nx">Prev</span><span class="p">=</span><span class="nx">prevP</span>
</span></span><span class="line"><span class="cl">                <span class="nx">this</span><span class="p">.</span><span class="nx">Length</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Your MyLinkedList object will be instantiated and called as such:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj := Constructor();
</span></span></span><span class="line"><span class="cl"><span class="cm"> * param_1 := obj.Get(index);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj.AddAtHead(val);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj.AddAtTail(val);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj.AddAtIndex(index,val);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj.DeleteAtIndex(index);
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span></code></pre></div><p>官方实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span>
</span></span><span class="line"><span class="cl">    <span class="nx">size</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">MyLinkedList</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{},</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span><span class="p">.</span><span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">index</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pred</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pred</span> <span class="p">=</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">toAdd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">toAdd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">l</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pred</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pred</span> <span class="p">=</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">b</span> <span class="p">&gt;</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>总结起来(虽然一个是单链表一个是双链表):</p>
<ol>
<li>
<p>构造函数给后面的处理带来了麻烦,没有真正用到虚拟头节点(虚拟尾节点)</p>
</li>
<li>
<p>虚拟头节点不是你在add的时候创建一个，而是这个链表一直就有的。在这里就是</p>
<p>head-&gt;index[0]-&gt;&hellip;-&gt;inde [length-1]-&gt;tail</p>
</li>
<li>
<p>而且这样遍历的时候可以左闭右开，也就是遍历的时候可以从第一个开始遍历。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>二分查找，双指针，滑动窗口</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/02/05/category/leetcode_day1/</link>
      <pubDate>Sun, 05 Feb 2023 16:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/02/05/category/leetcode_day1/</guid>
      <description>23-02-05 刷题记录 基本是跟着代码随想录刷的，day1刷了二分查找，滑窗还有双指针。记录一下当时的思路。 二分查找 二分查找突出的是一个熟练，针对已有的两</description>
      <content:encoded><![CDATA[<h2 id="23-02-05-刷题记录">23-02-05 刷题记录</h2>
<p>基本是跟着<a href="https://programmercarl.com/">代码随想录</a>刷的，day1刷了二分查找，滑窗还有双指针。记录一下当时的思路。</p>
<h3 id="二分查找">二分查找</h3>
<p>二分查找突出的是一个<strong>熟练</strong>，针对已有的两种写法: 开区间与闭区间我选择的是闭区间的写法。抄录我的写法如下:</p>
<blockquote>
<p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。</p>
</blockquote>
<blockquote>
<p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p>
</blockquote>
<blockquote>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
</blockquote>
<p>例题都比较简单，不做展示。值得注意的是，边界条件为left==right，遇到变体的时候直接考虑这个以及之后的情况作为边界条件。</p>
<h3 id="双指针">双指针</h3>
<p>双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<ul>
<li>快指针: 遍历原始数组，根据条件寻找新数组的元素。</li>
<li>慢指针: 按序更新新数组</li>
</ul>
<h4 id="例题">例题</h4>
<blockquote>
<p>leetcode 27.
给你一个数组 nums 和一个值 val，你需要<em>原地</em> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span> <span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">val</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="nx">j</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nums</span><span class="p">=</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">j</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>类似题目：</p>
<ul>
<li>26.删除排序数组中的重复项</li>
<li>283.移动零</li>
<li>844.比较含退格的字符串</li>
<li>977.有序数组的平方</li>
</ul>
<h3 id="滑动窗口">滑动窗口</h3>
<p>这类问题基本都和连续最短/最长子串相关，这种问题可以看成以数组中的任一个结尾满足条件的最短/最长。滑动窗口的思想就是利用连续的思想，窗口右侧在向右移动的过程中，左侧也不断移动，这样一般是O(2n)既O(n)而不是 ${O(n^2)}$。 而且一般会要在移动过程中记录下一min/max。</p>
<p>在使用滑窗时要注意:</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>以leetcode 209. 为例:</p>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
</blockquote>
<blockquote>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, &hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="nx">target</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sum</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">min</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">flag</span><span class="o">:=</span><span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span><span class="o">+=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">sum</span><span class="o">&gt;=</span><span class="nx">target</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="nx">sum</span><span class="o">-</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">&gt;=</span> <span class="nx">target</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">sum</span><span class="o">-=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">&lt;</span><span class="nx">min</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">min</span> <span class="p">=</span> <span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">flag</span><span class="p">=</span><span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">flag</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">min</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>窗口内是以窗口最右为最末时当前的最短的和超过target的子串(如果能超过)</li>
<li>移动起始位置一般是比较难的，需要根据条件移动(比如这个里的如果少了这个还能大于target那就是可以移动)</li>
<li>末尾移动还是比较简单，暂时没有遇到什么困难的。</li>
</ul>
<p>leetcode 76.最小覆盖子串:</p>
<blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">minWindow</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out</span><span class="o">:=</span><span class="nx">s</span>
</span></span><span class="line"><span class="cl">    <span class="nx">target</span><span class="o">:=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dict</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span> <span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">targetDict</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span> <span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">ch</span><span class="o">:=</span> <span class="k">range</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">t</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">targetDict</span><span class="p">[</span><span class="nx">ch</span><span class="p">];</span><span class="nx">ok</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">targetDict</span><span class="p">[</span><span class="nx">ch</span><span class="p">]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">targetDict</span><span class="p">[</span><span class="nx">ch</span><span class="p">]=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">_</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]];</span><span class="nx">ok</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]]=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">t</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">targetDict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]];</span><span class="nx">ok</span><span class="o">&amp;&amp;</span><span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span><span class="o">==</span><span class="nx">t</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">target</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">target</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">targetDict</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">j</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">t</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">targetDict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]];!</span><span class="nx">ok</span><span class="o">||</span><span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">-</span><span class="nx">t</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">dict</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nx">out</span><span class="p">=</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">target</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="nx">targetDict</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意：在每次判断左边界是否右移的时候，本来是需要比较旧dict和targetDict是否相等(每个元素都比较),但是其实只需要把满足条件的次数记录下来就可，就是需要出现的字符刚好相等的时候(target++)，这样到target等于len(targetdict)就必定可以满足条件。而且滑窗一般都会有设置flag这种操作。</p>
<p>相关例题：</p>
<ul>
<li>904.水果成篮</li>
<li>76.最小覆盖子串</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>