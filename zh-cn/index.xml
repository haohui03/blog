<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Yehh</title>
    <link>https://blog.yehaohui.com/zh-cn/</link>
    <description>Recent content on Yehh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Jan 2024 09:01:23 +0800</lastBuildDate>
    
    <atom:link href="https://blog.yehaohui.com/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://blog.yehaohui.com/zh-cn/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/about/</guid>
      <description>Hi! 我是叶浩辉 华南理工大学 软件学院三年级本科生, 兴趣集中在Computer Vision 和 Trustworthy Machine Learning。 Key/Value Engine(RocksDB), distributed system, cloud native, golang, linux, k8s, docker, etc. 希望不断学习，不断进</description>
      <content:encoded><![CDATA[<h2 id="hi-我是叶浩辉httpsblogyehaohuicom">Hi! 我是<a href="https://blog.yehaohui.com/">叶浩辉</a></h2>
<p><a href="https://www.scut.edu.cn/new/">华南理工大学</a> 软件学院三年级本科生, <del>兴趣集中在Computer Vision 和 Trustworthy Machine Learning。</del> Key/Value Engine(RocksDB), distributed system, cloud native, golang, linux, k8s, docker, etc.</p>
<p>希望不断学习，不断进步，通过深度阅读提升思考能力。</p>
<h2 id="阅读">阅读</h2>
<h3 id="最近阅读">最近阅读：</h3>
<p><a href="https://github.com/Vonng/ddia">DDIA 设计数据密集型应用</a></p>
<p><a href="https://sfc33ed4d8ae30993.jimcontent.com/download/version/0/module/5761298011/name/%E6%9B%BC%E6%98%86%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%28%E4%B8%AD%E6%96%87%29%E7%AC%AC%E4%BA%94%E7%89%88%28%E5%AE%8F%E8%A7%82%E5%88%86%E5%86%8C%29.pdf">principles of economics mankiw 宏观经济学 曼昆</a></p>
<h3 id="纪录片">纪录片</h3>
<ol>
<li><a href="https://www.bilibili.com/video/BV1cE411x7o2/?spm_id_from=333.337.search-card.all.click">街头绝味</a></li>
<li><a href="https://www.bilibili.com/bangumi/play/ep333749?spm_id_from=333.788.recommend_more_video.2">吴文芳：40小时看世界</a></li>
</ol>
<h2 id="关于本站">关于本站</h2>
<blockquote>
<p>本站灵感来自<a href="https://www.pseudoyu.com/zh/">pseudoyou</a>,真诚、自省的文字和开源的精神是我建站的目标。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>quic协议</title>
      <link>https://blog.yehaohui.com/zh-cn/2024/01/17/category/quic%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 17 Jan 2024 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2024/01/17/category/quic%E5%8D%8F%E8%AE%AE/</guid>
      <description>QUIC QUIC在用户空间实现，tcp/udp在内核空间 优势 减少了 TCP 三次握手及 TLS 握手时间。 改进的拥塞控制。 避免队头阻塞的多路复用。 连接迁移。 前向安</description>
      <content:encoded><![CDATA[<h2 id="quic">QUIC</h2>
<p>QUIC在用户空间实现，tcp/udp在内核空间</p>
<p><img src="https://s2.loli.net/2024/01/17/UikhnzBXEy1xG6C.png" alt="image.png"></p>
<h2 id="优势">优势</h2>
<ol>
<li>减少了 TCP 三次握手及 TLS 握手时间。</li>
<li>改进的拥塞控制。</li>
<li>避免队头阻塞的多路复用。</li>
<li>连接迁移。</li>
<li>前向安全。</li>
</ol>
<h2 id="过程">过程</h2>
<p><img src="https://s2.loli.net/2024/01/17/YOqf5nwXm2REe8z.png" alt="image.png"></p>
<p>传统需要TCP3握手，TLS4握手（一个用户空间一个内核无法合并）</p>
<h3 id="1-rtt">1-RTT</h3>
<p><img src="https://s2.loli.net/2024/01/17/dsaHwFMNtqVSnmR.png" alt="image.png"></p>
<p>第一次握手：</p>
<p>客户端主动向服务器发送Inchoate CHLO报文</p>
<p>服务器会向客户端发送REJ报文。REJ报文包含了服务器的配置信息，如长期的Diffie-Hellman值，服务器配置的签名，source-address-token(stk, 用于验证的加密块，包含有服务器看到的客户端的IP地址和服务器当前的时间戳，之后客户端会将该stk发回)等，为了进行身份证明还会使用私钥进行签名，同时也可以防篡改；</p>
<p>在收到服务器的配置信息后，客户端会通过证书链机制验签，并实现对服务器的身份认证。</p>
<p>第二次握手：</p>
<p>客户端在通过对服务器的验证之后，客户端会生成一个Diffie-Hellman值。此时客户端有了自身和对方的Diffie-Hellman值，就可以计算出初始密钥（initial key, ik）；</p>
<p>客户端将包含有DH公开之的明文Complete CHLO发送至服务器；</p>
<p>客户端使用ik对请求数据加密，发送至服务器；</p>
<p>服务器收到Complete CHLO之后就可以获得客户端的Diffie-Hellman的值，就可以计算出初始密钥。</p>
<p>服务器立即向客户端发送SHLO报文（ik加密的）。SHLO报文含有一个服务器临时Diffie-Hellman值，可以用于计算前向安全的密钥（会话密钥）；</p>
<p>服务器收到加密的请求数据，使用初始密钥进行解密；
服务器使用会话密钥对响应数据进行加密，发回给客户端。</p>
<p>客户端在收到SHLO之后使用初始密钥解密得到服务器的临时DH公开值，根据该临时值计算出会话密钥；
客户端收到加密的响应数据后，使用会话密钥进行解密。
整个握手过程会在2个RTT内完成。</p>
<h3 id="tls13">TLS1.3</h3>
<p><img src="https://s2.loli.net/2024/01/17/aKxcprIlAsGzCDZ.png" alt="image.png"></p>
<h3 id="0-rtt">0-rtt</h3>
<p>客户端在重连同一个服务器时，会使用已经缓存的服务器相关配置信息（stk，DH公开值等信息），并直接向服务器发送Complete CHLO报文，并使用ik对请求报文进行加密。但是服务器方面会标识相应的stk等信息已经过期，这时服务器会发送REJ信息，客户端需要重新与服务器进行连接。</p>
<p>如果没有过期的话，就可以直接建立连接，省下了重新建立连接的开销。</p>
<h2 id="前向安全">前向安全</h2>
<p>在最后一次握手时，会生成一个会话密钥sk。这样即使服务器的长期DH值被破获，且生成了初始密钥ik，也无法对会话中的数据进行解密。</p>
<h2 id="多路复用">多路复用</h2>
<p>可以在QUIC流上构建任意大小的应用程序报文，最多支持
2^64的字节。并且stream的实现是轻量级的，即使消息报文很小也可以为它们使用单独的流。每一个Stream都有stream ID唯一标识。这些流ID由客户端/服务器进行静态分配。客户端主动发起的流的ID永远是奇数，服务器发起的流的ID是偶数。这样可以避免冲突。当在一个未使用过的流上发送数据时，流会自动创建；当需要关闭时，就会在最后一帧数据上设置一个FIN的标志指示接收方关闭流。如果发送方或接收方确定不再需要流上的数据，则可以取消流，而无需断开整个 QUIC 连接。尽管流是可靠的抽象，但 QUIC 不会为已取消的流重新传输数据。</p>
<p><img src="https://s2.loli.net/2024/01/17/i3jEPlsMhtR5BHg.png" alt="image.png"></p>
<h2 id="重传">重传</h2>
<p>TCP 序列号有助于提高可靠性，并表示在接收方传送字节的顺序。这种混淆会导致“重传模糊”（retransmission ambiguity）问题，因为重传的 TCP 段携带与原始数据包相同的序列号 。 TCP ACK 的接收者无法确定 ACK 是为原始传输还是为重传而发送，并且通常通过昂贵的超时来检测重传段的丢失。每个 QUIC 数据包都携带一个新的数据包编号，包括那些携带重传数据的数据包。这种设计不需要单独的机制来区分重传的 ACK 和原始传输的 ACK，从而避免了 TCP 的重传模糊问题。流帧中的流偏移用于传递排序，数据包编号表示一个明确的时间顺序，这使得丢失检测比 TCP 更简单、更准确。</p>
<h2 id="流量控制">流量控制</h2>
<p>QUIC在连接有流量控制，在流这个级别也有流量控制</p>
<h2 id="拥塞控制">拥塞控制</h2>
<p>由于QUIC 通过 Packet Number 来标识包的序号，而且规定 Packet Number 只能单调递增，这也就解决了初始包和重传包的二义性。从而保证 RTT 的值是准确的。</p>
<h2 id="连接迁移">连接迁移</h2>
<p>QUIC连接使用随机生成的64bit的cid唯一确定。cid允许客户机在网络之间漫游，而不受网络或传输层参数变化的影响。</p>
<p>cid使得客户端能够独立于网络地址转换（network address translation, NAT）之外。cid 在路由中起着重要作用，特别是用于连接标识的目的。此外，使用 cids 可以通过探测连接的新路径实现多路径。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>k8s-day2</title>
      <link>https://blog.yehaohui.com/zh-cn/2024/01/08/category/k8s-day2/</link>
      <pubDate>Mon, 08 Jan 2024 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2024/01/08/category/k8s-day2/</guid>
      <description>RBAC 参考 Kubernetes（k8s）权限管理RBAC详解 网络 参考 写得非常好</description>
      <content:encoded><![CDATA[<h2 id="rbac">RBAC</h2>
<h3 id="参考">参考</h3>
<p><a href="https://juejin.cn/post/7116104973644988446">Kubernetes（k8s）权限管理RBAC详解</a></p>
<h2 id="网络">网络</h2>
<h3 id="参考-1">参考</h3>
<p><a href="https://www.zhaohuabing.com/post/2019-03-29-how-to-choose-ingress-for-service-mesh/">写得非常好</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-lock</title>
      <link>https://blog.yehaohui.com/zh-cn/2024/01/01/category/golang-lock/</link>
      <pubDate>Mon, 01 Jan 2024 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2024/01/01/category/golang-lock/</guid>
      <description>基本概念 互斥锁会将操作串行化，可以保证操作完全有序，适合资源只能由一个协程进行操作的情况，并发能力弱； 读写锁适合读多写少的情况，并发能有比较</description>
      <content:encoded><![CDATA[<h2 id="基本概念">基本概念</h2>
<p>互斥锁会将操作串行化，可以保证操作完全有序，适合资源只能由一个协程进行操作的情况，并发能力弱；</p>
<p>读写锁适合读多写少的情况，并发能有比较强。</p>
<p>使用信号量可以完成很多操作</p>
<ol>
<li>临界区互斥</li>
</ol>
<p>单一互斥量mutex</p>
<ol start="2">
<li>前驱</li>
</ol>
<p>其实就是拓扑排序</p>
<h2 id="syncmutex">sync.Mutex</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span>  <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="加锁">加锁</h3>
<p>如果发现锁被持有，会自旋一会，避免频繁的信号量唤醒。但是如果很多个自旋的协程都在等待，会导致饥饿问题。所以通过添加饥饿标志使每次让出锁都要唤醒一个被阻塞的协程来解决。</p>
<p><img src="https://s2.loli.net/2024/01/03/kg8Cc4moSGzbHA6.png" alt="image.png"></p>
<p>Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量</p>
<ul>
<li>Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。</li>
<li>Woken: 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。释放锁时，如果正常模式下，不会再唤醒其它协程。</li>
<li>Starving：表示该Mutex是否处理饥饿状态， 0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。</li>
<li>Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量
协程之间抢锁实际上是抢给Locked赋值的权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待</li>
</ul>
<p>Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。</p>
<p>互斥量有两种模式：正常模式和饥饿模式。</p>
<p>正常模式：正常模式下等待的协程按照先入先出排列，当一个协程被唤醒后并不是直接拥有锁，该协程需要和刚刚到达的协程一起竞争锁的所有权。新到的协程有个优势，那就是它已经在CPU上运行了，而且新到的协程可能有很多，所以被唤醒的协程极有可能抢占不到锁。在这种情况下，被唤醒的协程会被放置于等待队列的队头。如果等待的协程超过1ms内没有获取到锁，将会把锁置为饥饿模式。</p>
<p>饥饿模式：在饥饿模式下，解锁的协程会将锁的所有权直接交给等待队列中位于队头的协程。正好解锁的那一刻有新的协程到达，新到达的协程也不会尝试自旋获取锁。相反，他们会将自己置于等待队列的队尾。</p>
<p>如果等待队列中的协程获取到锁，它会查看</p>
<p>(1)自己是否是等待队列中最后一个协程</p>
<p>(2)自己等待的时间是否小于1ms</p>
<p>如果有任意一个条件满足，将会将锁改为普通模式。</p>
<p>代码解析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">lockSlow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">waitStartTime</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">starving</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">awoke</span> <span class="o">:=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">iter</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Don&#39;t spin in starvation mode, ownership is handed off to waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// so we won&#39;t be able to acquire the mutex anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果是饥饿模式，直接阻塞等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="nx">mutexLocked</span> <span class="o">&amp;&amp;</span> <span class="nf">runtime_canSpin</span><span class="p">(</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Active spinning makes sense.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Try to set mutexWoken flag to inform Unlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// to not wake other blocked goroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//尝试把woken状态设为1，这样在拥有锁的协程解锁的时候就不会把久的协程唤醒，这样可以增加自己获得锁的几率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//条件是，当前协程之前没有唤醒，woken没有被设为1，有在等待的协程，cas操作成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">awoke</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">				<span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">old</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">runtime_doSpin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">iter</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 此处说明锁变为饥饿状态或者已经解锁了，或者不符合自旋条件了（仍为锁定状态）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 锁状态包含-饥饿锁定、饥饿未锁定、正常锁定、正常未锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 获取锁最新的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">new</span> <span class="o">:=</span> <span class="nx">old</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Don&#39;t try to acquire starving mutex, new arriving goroutines must queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果是正常状态，尝试加锁。饥饿状态下要出让竞争权利，肯定不能加锁的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexLocked</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果锁还是被占用的或者锁是饥饿状态，只能将自己放到等待队列上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 到了这个阶段，遇到这些状态，协程只能躺平。饥饿状态要出让竞争权利
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">mutexWaiterShift</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The current goroutine switches mutex to starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// But if the mutex is currently unlocked, don&#39;t do the switch.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Unlock expects that starving mutex has waiters, which will not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// be true in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//如果当前协程感到饥饿，并且锁是锁定状态，那么就把锁状态改为饥饿锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">starving</span> <span class="o">&amp;&amp;</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">new</span> <span class="o">|=</span> <span class="nx">mutexStarving</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前协程把woken设为真，卸载要设回去，因为要么得到锁，要么等待，两种情况都和唤醒没关系了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">awoke</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// The goroutine has been woken from sleep,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// so we need to reset the flag in either case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">new</span> <span class="o">&amp;^=</span> <span class="nx">mutexWoken</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// old  -&gt; new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (0,1)正常且已锁定 -&gt; (+1,1?,1) 等待加一，状态待定，加锁   -&gt;  加到等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (0,0)正常且未锁定 -&gt; (+0,0 ,1) 等待不变，正常状态，加锁   -&gt;  加锁成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (1,1)饥饿且已锁定 -&gt; (+1,1?,1) 等待加一，饥饿待定，加锁   -&gt;  加到等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (1,0)饥饿且未锁定 -&gt; (+1,1 ,0) 等待加一，饥饿状态，不加锁  -&gt;  加到等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//加锁成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span> <span class="c1">// locked the mutex with CAS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// If we were already waiting before, queue at the front of the queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">queueLifo</span> <span class="o">:=</span> <span class="nx">waitStartTime</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">waitStartTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">waitStartTime</span> <span class="p">=</span> <span class="nf">runtime_nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">// 走到此处，说明协程没有获取到锁，调用runtime_SemacquireMutex，将该协程挂起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// waitStartTime能够判断该协程是新来的还是被唤醒的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// 如果是新来的，则加入队列尾部，等待唤醒，queueLifo=false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// 如果是从等待队列中唤醒的，则加入队列头部，queueLifo=true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// 如果后面该协程被唤醒，就从该位置继续往下执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">			<span class="nf">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="nx">queueLifo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">// 此刻说明该协程被唤醒了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="c1">// 判断该协程是否长时间没有获取到锁，如果是的话，就是饥饿的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">starving</span> <span class="p">=</span> <span class="nx">starving</span> <span class="o">||</span> <span class="nf">runtime_nanotime</span><span class="p">()</span><span class="o">-</span><span class="nx">waitStartTime</span> <span class="p">&gt;</span> <span class="nx">starvationThresholdNs</span>
</span></span><span class="line"><span class="cl">			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//饥饿模式下被唤醒一定是队头的协程，所以直接把锁给它
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// If this goroutine was woken and mutex is in starvation mode,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// ownership was handed off to us but mutex is in somewhat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// inconsistent state: mutexLocked is not set and we are still
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// accounted as waiter. Fix that.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">delta</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mutexLocked</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">!</span><span class="nx">starving</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// Exit starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// Critical to do it here and consider wait time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// Starvation mode is so inefficient, that two goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// can go lock-step infinitely once they switch mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// to starvation mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">delta</span> <span class="o">-=</span> <span class="nx">mutexStarving</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//delta可以让waiting个数减一，还可以弄调饥饿标志，还可以加锁（亏贼）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">awoke</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="nx">iter</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Unlock unlocks m.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is a run-time error if m is not locked on entry to Unlock.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A locked Mutex is not associated with a particular goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It is allowed for one goroutine to lock a Mutex and then
</span></span></span><span class="line"><span class="cl"><span class="c1">// arrange for another goroutine to unlock it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">		<span class="nx">race</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Fast path: drop lock bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">new</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="o">-</span><span class="nx">mutexLocked</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//还有一些别的事情要处理，比如饥饿状态，要唤醒协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">new</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Outlined slow path to allow inlining the fast path.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Mutex</span><span class="p">)</span> <span class="nf">unlockSlow</span><span class="p">(</span><span class="nx">new</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nx">new</span><span class="o">+</span><span class="nx">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">fatal</span><span class="p">(</span><span class="s">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">new</span><span class="o">&amp;</span><span class="nx">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//无starving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">old</span> <span class="o">:=</span> <span class="nx">new</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// If there are no waiters or a goroutine has already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// been woken or grabbed the lock, no need to wake anyone.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// In starvation mode ownership is directly handed off from unlocking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// goroutine to the next waiter. We are not part of this chain,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// So get off the way.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 没有要等待的协程或者已经有协程被唤醒或者已经有协程获取到锁了，就不需要唤醒任何人
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">old</span><span class="o">&gt;&gt;</span><span class="nx">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">old</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">mutexLocked</span><span class="p">|</span><span class="nx">mutexWoken</span><span class="p">|</span><span class="nx">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Grab the right to wake someone.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">new</span> <span class="p">=</span> <span class="p">(</span><span class="nx">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">mutexWaiterShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">mutexWoken</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">old</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">state</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Starving mode: handoff mutex ownership to the next waiter, and yield
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// our time slice so that the next waiter can start to run immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Note: mutexLocked is not set, the waiter will set it after wakeup.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// But mutex is still considered locked if mutexStarving is set,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// so new coming goroutines won&#39;t acquire it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//直接唤醒一个协程并且让出时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">sema</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://www.processon.com/view/link/60f4e1021e085376da5c05f8">源代码的流程图</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/544161308">信号量的原理</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-tcmalloc</title>
      <link>https://blog.yehaohui.com/zh-cn/2024/01/01/category/golang-tcmalloc/</link>
      <pubDate>Mon, 01 Jan 2024 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2024/01/01/category/golang-tcmalloc/</guid>
      <description>TCmalloc 为了解决中大对象的内存申请，TCmalloc有一个全局共享内存堆 Page 每个 Page 默认是 8KB。这里的page就像是虚拟内存的page Span Span是包</description>
      <content:encoded><![CDATA[<h2 id="tcmalloc">TCmalloc</h2>
<p><img src="https://cdn.learnku.com/uploads/images/202205/23/58489/DWdNm4x8Ig.png!large" alt="tomalloc"></p>
<p>为了解决中大对象的内存申请，TCmalloc有一个全局共享内存堆</p>
<h3 id="page">Page</h3>
<p>每个 Page 默认是 8KB。这里的page就像是虚拟内存的page</p>
<h3 id="span">Span</h3>
<p>Span是包含了不同数量的page的单位
<img src="https://cdn.learnku.com/uploads/images/202205/23/58489/ivmjaMfAeU.png!large" alt="span"></p>
<h3 id="size-class">Size Class</h3>
<p><img src="https://cdn.learnku.com/uploads/images/202205/23/58489/TxIGJR26fZ.png!large" alt=""></p>
<h3 id="threadcache">ThreadCache</h3>
<p>每个线程有单独的缓存
<img src="https://cdn.learnku.com/uploads/images/202205/23/58489/V85EFusAJ5.png!large" alt=""></p>
<h3 id="参考">参考</h3>
]]></content:encoded>
    </item>
    
    <item>
      <title>chan</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/12/12/category/chan/</link>
      <pubDate>Tue, 12 Dec 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/12/12/category/chan/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>golang-gc-optimization</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/12/12/category/golang-gc-optimization/</link>
      <pubDate>Tue, 12 Dec 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/12/12/category/golang-gc-optimization/</guid>
      <description>golang 是如何运行起来的</description>
      <content:encoded><![CDATA[<p><a href="https://www.zhihu.com/question/568743622/answer/3320805377">golang 是如何运行起来的</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-map</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/23/category/golang-map/</link>
      <pubDate>Thu, 23 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/23/category/golang-map/</guid>
      <description>map map是一个很重要的数据结构，本篇文章记录学习golang中map源码的过程。 图多取自别人的博客，非原创请注意 基本的概念不在赘述了 以下分析</description>
      <content:encoded><![CDATA[<h1 id="map">map</h1>
<p>map是一个很重要的数据结构，本篇文章记录学习golang中map源码的过程。</p>
<p>图多取自别人的博客，非原创请注意</p>
<p>基本的概念不在赘述了</p>
<p>以下分析来自go 1.21.0</p>
<h2 id="使用">使用</h2>
<h3 id="创建">创建</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 指定 map 长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ageMp 为 nil，不能向其添加元素，会直接panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ageMp</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span></code></pre></div><h2 id="变量和类型">变量和类型</h2>
<p><img src="https://s2.loli.net/2023/11/23/GcFBKTq2ZeuioI8.png" alt="image.png"></p>
<blockquote>
<p>map是以bucket来组织键值对的，一个bucket最多8个键值对。</p>
</blockquote>
<h3 id="变量常量">变量（常量）</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Maximum number of key/elem pairs a bucket can hold.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapBucketCountBits</span> <span class="c1">//3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapBucketCount</span> <span class="c1">//8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用loadFactorNum/loadFactorDen来代表负载因子，用两个整数就可以进行整数运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Maximum average load of a bucket that triggers growth is bucketCnt*13/16 (about 80% full)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Because of minimum alignment rules, bucketCnt is known to be at least 8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Represent as loadFactorNum/loadFactorDen, to allow integer math.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">loadFactorDen</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">loadFactorNum</span> <span class="p">=</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">*</span> <span class="mi">13</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="nx">loadFactorDen</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// key和value size都是128（加起来不超过uint8）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Maximum key or elem size to keep inline (instead of mallocing per element).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Must fit in a uint8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast versions cannot handle big elems - the cutoff size for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// fast versions in cmd/compile/internal/gc/walk.go must be at most this elem.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxKeySize</span>  <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapMaxKeyBytes</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxElemSize</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapMaxElemBytes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//其实就是bmap结构体的对齐大小（8字节即使是amd64p32）,注意这里是编译期前的，不包括那些奇奇怪怪的后面加的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// data offset should be the size of the bmap struct, but needs to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// aligned correctly. For amd64p32 this means 64-bit alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// even though pointers are 32 bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataOffset</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="p">}{}.</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Possible tophash values. We reserve a few possibilities for special marks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Each bucket (including its overflow buckets, if any) will have either all or none of its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// entries in the evacuated* states (except during the evacuate() method, which only happens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// during map writes and thus no one else can observe the map during that time).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">emptyRest</span>      <span class="p">=</span> <span class="mi">0</span> <span class="c1">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">emptyOne</span>       <span class="p">=</span> <span class="mi">1</span> <span class="c1">// this cell is empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedX</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedY</span>     <span class="p">=</span> <span class="mi">3</span> <span class="c1">// same as above, but evacuated to second half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedEmpty</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// cell is empty, bucket is evacuated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">minTopHash</span>     <span class="p">=</span> <span class="mi">5</span> <span class="c1">// minimum tophash for a normal filled cell.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">iterator</span>     <span class="p">=</span> <span class="mi">1</span> <span class="c1">// there may be an iterator using buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">oldIterator</span>  <span class="p">=</span> <span class="mi">2</span> <span class="c1">// there may be an iterator using oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hashWriting</span>  <span class="p">=</span> <span class="mi">4</span> <span class="c1">// a goroutine is writing to the map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sameSizeGrow</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// the current map growth is to a new map of the same size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// sentinel bucket ID for iterator checks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">noCheck</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><h3 id="类型">类型</h3>
<h4 id="hmap">hmap</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A header for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// previous bucket array of half the size, non-nil only when growing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 指示扩容进度，小于此地址的 buckets 迁移完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>mapextra</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapextra holds fields that are not present on all maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If both key and elem do not contain pointers and are inline, then we mark bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// type as containing no pointers. This avoids scanning such maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The indirection allows to store a pointer to the slice in hiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="bmap">bmap</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A bucket for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// tophash generally contains the top byte of the hash value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// tophash[0] is a bucket evacuation state instead.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Followed by an overflow pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>实际上，bmap不止这么简单的东西。bmap会在编译期生成其他东西，相关的东西和cmd/compile/internal/reflectdata有关</p>
<p>相关函数：cmd/compile/internal/reflectdata/reflect.go/MapBucketType</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">topbits</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">keys</span>     <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">keytype</span>
</span></span><span class="line"><span class="cl">    <span class="nx">values</span>   <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">valuetype</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//曾经有padding，现在已经没有了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://s2.loli.net/2023/11/23/87xb5GEeCf1PF6W.png" alt="image.png">
值得注意的是，当键或值的大小超过128字节时，会使用指针来存储，而不是直接存储在bmap中。而且当key和elme都没有指针类型的时候overflow会变成uintptr类型并且由hmap来管理overflow（不会被GC认为有指针）不然就是unsafe.pointer。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://golang.design/go-questions/map/principal/">Go 程序员面试笔试宝典</a></li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#336-%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB">golang设计与实现</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>grpc-advanced</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/20/category/grpc-advanced/</link>
      <pubDate>Mon, 20 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/20/category/grpc-advanced/</guid>
      <description>grpc-tsl server side TLS 有关TLS的知识结合这个看体验更佳 Interceptor 有4种拦截器 type UnaryClientInterceptor func(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error) type StreamClientInterceptor func(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, streamer Streamer,</description>
      <content:encoded><![CDATA[<h2 id="grpc-tsl">grpc-tsl</h2>
<h3 id="server-side-tls">server side TLS</h3>
<p>有关TLS的知识结合<a href="https://www.cnblogs.com/sewain/p/14250884.html#ssltls">这个</a>看体验更佳</p>
<h3 id="interceptor">Interceptor</h3>
<p>有4种拦截器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">UnaryClientInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">UnaryServerInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">UnaryServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamClientInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">streamer</span> <span class="nx">Streamer</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">ClientStream</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamServerInterceptor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">srv</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ss</span> <span class="nx">ServerStream</span><span class="p">,</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">StreamServerInfo</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">StreamHandler</span><span class="p">)</span> <span class="kt">error</span>
</span></span></code></pre></div><p>通过WithxxxInterceptor()方法添加客户端拦截器</p>
<p>一般的使用场景是添加K/V元数据</p>
<p>下面的例子是客户端的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">UnaryClientInterceptor</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryClientInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 预处理(pre-processing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取正在运行程序的操作系统
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">cos</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将操作系统信息附加到传出请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ctx</span> <span class="p">=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">AppendToOutgoingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;client-os&#34;</span><span class="p">,</span> <span class="nx">cos</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 可以看做是当前 RPC 方法，一般在拦截器中调用 invoker 能达到调用 RPC 方法的效果，当然底层也是 gRPC 在处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用RPC方法(invoking RPC method)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nf">invoker</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 后处理(post-processing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;RPC: %s,,client-OS: &#39;%v&#39; req:%v start time: %s, end time: %s, err: %v&#34;</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">cos</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">start</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">),</span> <span class="nx">end</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">),</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下面是服务端</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">UnaryServerInterceptor</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">info</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryServerInfo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">handler</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryHandler</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 预处理(pre-processing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从传入上下文获取元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">md</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">metadata</span><span class="p">.</span><span class="nf">FromIncomingContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;couldn&#39;t parse incoming context metadata&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 检索客户端操作系统，如果它不存在，则此值为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">os</span> <span class="o">:=</span> <span class="nx">md</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;client-os&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取客户端IP地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ip</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">getClientIP</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// RPC 方法真正执行的逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 调用RPC方法(invoking RPC method)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">m</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">handler</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">end</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录请求参数 耗时 错误信息等数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 后处理(post-processing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;RPC: %s,client-OS: &#39;%v&#39; and IP: &#39;%v&#39; req:%v start time: %s, end time: %s, err: %v&#34;</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nx">FullMethod</span><span class="p">,</span> <span class="nx">os</span><span class="p">,</span> <span class="nx">ip</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">start</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">),</span> <span class="nx">end</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">),</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// GetClientIP检查上下文以检索客户机的ip地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">getClientIP</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">peer</span><span class="p">.</span><span class="nf">FromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;couldn&#39;t parse client IP address&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Addr</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="流式拦截">流式拦截</h4>
<p>流程差不多，3个阶段</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">1）预处理 (pre-processing)
</span></span><span class="line"><span class="cl">2）调用 RPC 方法 (invoking RPC method)
</span></span><span class="line"><span class="cl">3）后处理 (post-processing)
</span></span></code></pre></div><p>但是在2，3步的时候有所不同，比如是调用streamer而不是invoker，而且是要直接放回streamer对象。
拦截流的话需要重写streamer的SendMsg和RecvMsg方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">StreamClientInterceptor</span><span class="p">()</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamClientInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">desc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">,</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">streamer</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">Streamer</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;opening client streaming to the server method: %v&#34;</span><span class="p">,</span> <span class="nx">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用Streamer函数，获得ClientStream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">streamer</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">desc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">newStreamClient</span><span class="p">(</span><span class="nx">stream</span><span class="p">),</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 嵌入式 streamClient 允许我们访问SendMsg和RecvMsg函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">streamClient</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 对ClientStream进行包装
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newStreamClient</span><span class="p">(</span><span class="nx">c</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">)</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">streamClient</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// RecvMsg从流中接收消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">streamClient</span><span class="p">)</span> <span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Receive a message (Type: %T) at %v&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// RecvMsg从流中接收消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">streamClient</span><span class="p">)</span> <span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Send a message (Type: %T) at %v&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">RFC3339</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">(),</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithStreamInterceptor</span><span class="p">(</span><span class="nx">Interceptor</span><span class="p">.</span><span class="nf">StreamClientInterceptor</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span></code></pre></div><h3 id="自定义身份验证">自定义身份验证</h3>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://learnku.com/articles/73105">grpc进阶</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>go-zero goctl</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/go-zero-goctl/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/go-zero-goctl/</guid>
      <description>goctl </description>
      <content:encoded><![CDATA[<h2 id="goctl">goctl</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>grpc-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/grpc-intro/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/grpc-intro/</guid>
      <description>grpc 简单使用 这次这次实践的目录 . ├── client │ └── hello-client │ └── client.go ├── go.mod ├── go.sum ├── proto │ └── hello │ ├── hello_grpc.pb.go │ ├── hello.pb.go │ └── hello.proto └── server └── hello-server └</description>
      <content:encoded><![CDATA[<h1 id="grpc">grpc</h1>
<p><img src="https://s2.loli.net/2023/11/22/m3zX4BjgTlOneyY.png" alt="image.png"></p>
<h2 id="简单使用">简单使用</h2>
<p>这次这次实践的目录</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── client
</span></span><span class="line"><span class="cl">│   └── hello-client
</span></span><span class="line"><span class="cl">│       └── client.go
</span></span><span class="line"><span class="cl">├── go.mod
</span></span><span class="line"><span class="cl">├── go.sum
</span></span><span class="line"><span class="cl">├── proto
</span></span><span class="line"><span class="cl">│   └── hello
</span></span><span class="line"><span class="cl">│       ├── hello_grpc.pb.go
</span></span><span class="line"><span class="cl">│       ├── hello.pb.go
</span></span><span class="line"><span class="cl">│       └── hello.proto
</span></span><span class="line"><span class="cl">└── server
</span></span><span class="line"><span class="cl">    └── hello-server
</span></span><span class="line"><span class="cl">        └── server.go
</span></span></code></pre></div><p>proto</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义go生成后的包名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">option</span> <span class="n">go_package</span> <span class="o">=</span> <span class="s">&#34;./;hello&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kn">package</span> <span class="nn">proto</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义入参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">message</span> <span class="nc">Request</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">message</span> <span class="nc">Response</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">service</span> <span class="n">UserService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Say</span><span class="p">(</span><span class="n">Request</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Response</span><span class="p">);</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h3 id="server">server</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HelloService</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 必须嵌入UnimplementedUserServiceServer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hello</span><span class="p">.</span><span class="nx">UnimplementedUserServiceServer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现SayHi方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">HelloService</span><span class="p">)</span> <span class="nf">Say</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="o">*</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">format</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Response</span><span class="p">{</span><span class="nx">Result</span><span class="p">:</span> <span class="s">&#34;hi &#34;</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nf">GetName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;---&#34;</span> <span class="o">+</span> <span class="nx">format</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;8888&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建grpc服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 注册服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hello</span><span class="p">.</span><span class="nf">RegisterUserServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">HelloService</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 监听端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;net.Listen err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>分析上面的代码：</p>
<p>服务端需要实现在protobuf定义的函数，具体为定义一个结构体组合UnimplementedUserServiceServer,然后实现对应的方法。注意pb生成的golang函数与go本身的rpc不同的地方在于有一个context入参和返回值是通过返回来获取而不是作为一个参数的。</p>
<h3 id="client">client</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;8888&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 建立链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">insecure</span><span class="p">.</span><span class="nf">NewCredentials</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 一定要记得关闭链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 实例化客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">hello</span><span class="p">.</span><span class="nf">NewUserServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 发起请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Say</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Request</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;lin钟一&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;client.SayHi err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: %s&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>客户端代码也很简单，首先建立链接，然后实例化客户端，最后发起请求。</p>
<h2 id="grpc-streaming-client-and-server">gRPC Streaming, Client and Server</h2>
<ul>
<li>Server-side streaming RPC—— 客户端向服务器发送单个请求并接收回数据序列流（读回一系列消息）。客户端从返回的流中读取，直到没有更多消息为止。</li>
<li>Client-side streaming RPC—— 客户端向服务器发送数据序列流（写入一系列消息），一旦客户端完成了消息的写入，它会等待服务器读取所有消息并返回其响应结果。</li>
<li>Bidirectional streaming RPC—— 它是双向流式传输，客户端和服务器使用读写流发送一系列消息。两个流独立运行；因此，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入。保留每个流中消息的顺序。例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。</li>
</ul>
<h3 id="server-stream">server stream</h3>
<p>这个是服务端发送stream类型的数据</p>
<h4 id="proto">proto</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">StreamService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="k">rpc</span> <span class="n">List</span><span class="p">(</span><span class="n">StreamRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">StreamResponse</span><span class="p">)</span> <span class="p">{};</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h4 id="服务端">服务端</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">2. 通过 client 获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">3. for循环中通过stream.Recv()依次获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="cm">4. err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">List</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 具体返回多少个response根据业务逻辑调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过 send 方法不断推送数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Name</span><span class="p">:</span>  <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Value</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回nil表示已经完成响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>StreamService_ListServer是pb-grpc为 stream 类型的生成的类型，他的公开函数为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamService_ListServer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Send</span><span class="p">(</span><span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//内部一般有一个私有结构体来实现这个Send，Send一般就是调用ServerStream的SendMsg方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">streamServiceListServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">streamServiceListServer</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ServerStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="客户端">客户端</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">2. 通过 client 获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">3. for循环中通过stream.Recv()依次获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="cm">4. err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用获取stream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">List</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过 Recv() 不断获取服务端send()推送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="探究生成的代码">探究生成的代码</h3>
<h4 id="client-1">client</h4>
<p>对于Client端来说，先生成一个xxxServiceClient实现pb中定义的函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamServiceClient</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//List：服务器端流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">List</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">StreamService_ListClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//Record：客户端流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Record</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">StreamService_RecordClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//Route：双向流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Route</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">StreamService_RouteClient</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一旦有需要流式传输的都是通过返回一个xxx_funcClient结构体（实现了Recv或者Send+CloseAndRecv或者Send+Recv）而Send或者别的函数都是调用grpc.ClientStream.SendMsg或者RecvMsg。拦截器就是通过重写这两个函数来实现流式拦截</p>
<h3 id="server-1">Server</h3>
<p>生成的xxxserver一般包括</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">UserServiceServer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Say</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span><span class="c1">//用户定义的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mustEmbedUnimplementedUserServiceServer</span><span class="p">()</span><span class="c1">//检查是否嵌入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>正常来说还是一样嵌入一个UnimplementedUserServiceServer，原理就是UnimplementedUserServiceServer定义了未实现的接口和一个mustEmbedUnimplementedUserServiceServer函数，通过嵌入这个结构体并重写用户定义函数来实现接口。</p>
<p>而对于流式传输</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamServiceServer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//List：服务器端流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">List</span><span class="p">(</span><span class="o">*</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//Record：客户端流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Record</span><span class="p">(</span><span class="nx">StreamService_RecordServer</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//Route：双向流式 RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Route</span><span class="p">(</span><span class="nx">StreamService_RouteServer</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mustEmbedUnimplementedStreamServiceServer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这里流式传输的东西都是通过xxx_funcServer的参数来获得，要注意的是其实方法都差不多，然后如果有获取一次或者说发送一次就关闭的一般会变成xxxAndClose比如这里的RecordServer就是SendAndClose，Client的CloseAndRecv</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://learnku.com/articles/73104">入门grpc非常好的文章</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>protobuf-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/protobuf-intro/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/protobuf-intro/</guid>
      <description>本篇文章记录学习protobuf的过程 定义消息 syntax = &amp;#34;proto3&amp;#34;; message name { body } syntax = &amp;#34;proto3&amp;#34;; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } 通常把message定义在一个单独的文件</description>
      <content:encoded><![CDATA[<h1 id="本篇文章记录学习protobuf的过程">本篇文章记录学习protobuf的过程</h1>
<h2 id="定义消息">定义消息</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">name</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="n">body</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span> <span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>通常把message定义在一个单独的文件中，文件名以.proto结尾。</p>
</blockquote>
<ul>
<li>第一行指定版本，不指定默认是proto2.</li>
<li>message是消息的关键字，后面跟着消息的名称，名称必须是唯一的。</li>
</ul>
<h3 id="字段类型字段标识和字段标签field-type--field-numbers--field-labels">字段类型，字段标识和字段标签（Field Type &amp; Field Numbers &amp; Field labels）</h3>
<h4 id="字段类型field-type">字段类型Field Type</h4>
<h5 id="数字类型">数字类型</h5>
<p>int64,int32,uint32,uint64,sint32,sin64 都是可变长的,然后uint表示无符号,sint在表示负数的时候比较高效</p>
<p>fixed32,fixed64,sfix32,sfix64 都是固定长度的</p>
<h5 id="其他常见类型">其他常见类型</h5>
<p>bool</p>
<p>string 大小小于2^32</p>
<p>bytes 大小可能大于2^32</p>
<h5 id="enum">enum</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_UNIVERSAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_WEB</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_IMAGES</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_LOCAL</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_NEWS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_PRODUCTS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_VIDEO</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">results_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">Corpus</span> <span class="n">corpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h5 id="map">map</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">map</span><span class="p">&lt;</span><span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">&gt;</span> <span class="n">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>…where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type. The value_type can be any type except another map.</p>
</blockquote>
<p>key_type可以是:标量(除bytes和bool),value_type不能是map,不能嵌套map</p>
<h5 id="any">any</h5>
<p>Any 消息类型允许您将消息作为嵌入类型使用，而不需要它们的.proto 定义。</p>
<p>Any 以字节的形式包含任意序列化的消息，以及作为该消息类型的全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要 import google/protobuf/any.proto</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="k">import</span> <span class="s">&#34;google/protobuf/any.proto&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">ErrorStatus</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">repeated</span> <span class="n">google.protobuf.Any</span> <span class="n">details</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h5 id="oneof">oneof</h5>
<p>如果需要一条包含多个字段的消息，并且最多同时设置一个字段，可以强制执行此行为并使用 oneof 功能节省内存。</p>
<p>oneof 字段与常规字段一样，在 oneof 共享内存中的所有字段，最多可以同时设置一个字段。设置 oneof 的任何成员会自动清除所有其他成员。</p>
<p>如果设置了多个值，则由 proto 中的 order 确定的最后一个设置的值将覆盖所有以前的设置值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">SampleMessage</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">oneof</span> <span class="n">test_oneof</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="n">SubMessage</span> <span class="n">sub_message</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h4 id="field-numbers">Field Numbers</h4>
<p>每个字段都要有一个标识，这里还是比较复杂的。</p>
<p>先说基本要求：</p>
<ol>
<li>field numbers 必须唯一（指在那个message内）</li>
<li>19,000-19,999是被pb内部使用的，不能使用</li>
<li>不能使用reserved的和已经分配给extension的</li>
<li>Field number不能被reuse，这其实是在说delete的时候要把这个field number和对应的name加到reserved里面去，之后都不能用</li>
</ol>
<p>然后是一些tricks：尽量把经常用到的字段分配小的field number因为他们的占用相对小，而且在编码的时候也会更加高效。</p>
<h4 id="field-labels">Field labels</h4>
<ul>
<li>optional
<ul>
<li>field is set, 也就是有一个确切值</li>
<li>field is unset,那么会返回的是default value</li>
</ul>
</li>
<li>repeated 其实就是说这个字段是一个数组</li>
<li>map</li>
<li>implicit field message(如果没有label)</li>
</ul>
<h3 id="package">package</h3>
<p>给一个.proto文件指定package, 是为了避免和其他的.proto文件的message名称冲突.</p>
<p>option go_package = &ldquo;github.com/TripleCGame/apis/api;api&rdquo;;—前一个参数用于指定生成文件的位置，后一个参数指定生成的 .go 文件的 package 。具体语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="k">option</span> <span class="n">go_package</span> <span class="o">=</span> <span class="s">&#34;{out_path};out_go_package&#34;</span><span class="p">;</span><span class="err">
</span></span></span></code></pre></div><p>注意：这里指定的 out_path 并不是绝对路径，只是相对路径或者说只是路径的一部分，和 protoc 的 &ndash;go_out 拼接后才是完整的路径。</p>
<h2 id="定义service">定义service</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">SearchService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Search</span><span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">);</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h2 id="命令">命令</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">protoc -I . -I /usr/local/include -I <span class="k">$(</span>GOPATH<span class="k">)</span>/src --go_out<span class="o">=</span>. simple.proto
</span></span></code></pre></div><p>-I 或 &ndash;proto_path: 		指定import搜索的文件夹路径</p>
<p>&ndash;go_out 		  :	 	 编译产生的 go代码 的生成位置</p>
<h3 id="代码生成规则">代码生成规则</h3>
<p>每个xxx.proto文件, 生成一个xxx.pb.go文件.</p>
<p>Go文件的package文件的生成规则:</p>
<ul>
<li>
<p>case1: .proto文件不包含package</p>
<ul>
<li>如果一个.proto文件中不包含package声明，生成的源代码将会使用.proto文件的文件名(去掉扩展名)作为Go包名，</li>
<li>其中, 生成的Go的包名中会自动把.转换为_。</li>
<li>举例来说一个名为high.score.proto不包含package声明的proto文件, 将会生成文件high.score.pb.go，他的Go包名是high_score。</li>
</ul>
</li>
<li>
<p>case2: .proto文件包含package</p>
<ul>
<li>经过编译的Go代码的包名默认使用proto文件的package名称, 除非在.proto文件中使用option go_package显示进行指定Go文件的import path.</li>
<li>其中, 生成的Go的包名中会自动把.转换为_。</li>
<li>举例来说proto包名example.high_score将会生成Go包名example_high_score。</li>
</ul>
</li>
<li>
<p>case3: .proto文件包含package, 同时包含option go_package</p>
<ul>
<li>option go_package 的作用是去指定生成的go文件的package的完整导入路径(import path)的, 如:</li>
</ul>
<p><code>option go_package = &quot;example.com/foo/bar&quot;; // 生成的foo.pb.go文件的package的import path就是 &quot;example.com/foobar&quot;</code></p>
</li>
</ul>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://protobuf.dev/programming-guides/proto3/">Protocol Buffers Documentation</a></li>
<li><a href="https://juejin.cn/post/6865126893063471112">这篇文章讲的特别好</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>plan9&#43;go-assembler</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/plan9-go-assembler/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/plan9-go-assembler/</guid>
      <description>plan9 本文记录plan9汇编的学习过程，sorry全是抄的，只能说抄一遍印象深一点而且好复盘。 基本指令 栈调整 SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈</description>
      <content:encoded><![CDATA[<h1 id="plan9">plan9</h1>
<p>本文记录plan9汇编的学习过程，sorry全是抄的，只能说抄一遍印象深一点而且好复盘。</p>
<p><img src="https://picx.zhimg.com/80/215522854f166f7b5a537ccfa641c922_720w.webp?source=1def8aca" alt="">
<img src="https://s2.loli.net/2023/11/19/eWghm4HFzrnkOoN.png" alt="image.png"></p>
<h2 id="基本指令">基本指令</h2>
<h3 id="栈调整">栈调整</h3>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧
...               // 省略无用代码
ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧
</code></pre><h3 id="数据">数据</h3>
<p>常数在 plan9 汇编用 $num 表示，可以为负数，默认情况下为十进制。可以用 $0x123 的形式来表示十六进制数。</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">MOVB $1, DI      // 1 byte
MOVW $0x10, BX   // 2 bytes
MOVD $1, DX      // 4 bytes
MOVQ $-10, AX     // 8 bytes
</code></pre><p>搬运的长度是由 MOV 的后缀决定</p>
<h3 id="条件跳转无条件跳转">条件跳转/无条件跳转</h3>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">// 无条件跳转
JMP addr   // 跳转到地址，地址可为代码中的地址，不过实际上手写不会出现这种东西
JMP label  // 跳转到标签，可以跳转到同一函数内的标签位置
JMP 2(PC)  // 以当前指令为基础，向前/后跳转 x 行
JMP -2(PC) // 同上

// 有条件跳转
JNZ target // 如果 zero flag 被 set 过，则跳转
</code></pre><h3 id="寄存器">寄存器</h3>
<p>IA64	rax	rbx	rcx	rdx	rdi	rsi	rbp	rsp	r8	r9	r10	r11	r12	r13	r14	rip</p>
<p>Plan9	AX	BX	CX	DX	DI	SI	BP	SP	R8	R9	R10	R11	R12	R13	R14	PC</p>
<p>在 plan9 汇编里都是可以使用的，应用代码层面会用到的通用寄存器主要是: rax, rbx, rcx, rdx, rdi, rsi, r8~r15 这 14 个寄存器，虽然 rbp 和 rsp 也可以用，不过 bp 和 sp 会被用来管理栈顶和栈底，最好不要拿来进行运算。</p>
<h3 id="伪寄存器">伪寄存器</h3>
<blockquote>
<ul>
<li>FP: Frame pointer: arguments and locals.</li>
<li>PC: Program counter: jumps and branches.</li>
<li>SB: Static base pointer: global symbols.</li>
<li>SP: Stack pointer: top of stack.</li>
</ul>
</blockquote>
<ul>
<li>FP: 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 caller 的 stack frame 上。具体可参见之后的 栈结构 一章。</li>
<li>PC: 实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。除了个别跳转之外，手写 plan9 代码与 PC 寄存器打交道的情况较少。</li>
<li>SB: 全局静态基指针，一般用来声明函数或全局变量，在之后的函数知识和示例部分会看到具体用法。</li>
<li>SP: plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间。假如局部变量都是 8 字节，那么第一个局部变量就可以用 localvar0-8(SP) 来表示。这也是一个词不表意的寄存器。与硬件寄存器 SP 是两个不同的东西，在栈帧 size 为 0 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset(SP) 形式，则表示伪寄存器 SP。如果是 offset(SP) 则表示硬件寄存器 SP。务必注意。对于编译输出(go tool compile -S / go tool objdump)的代码来讲，目前所有的 SP 都是硬件寄存器 SP，无论是否带 symbol。</li>
</ul>
<h3 id="变量声明">变量声明</h3>
<p>在汇编里所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。</p>
<p>使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:</p>
<p>DATA    symbol+offset(SB)/width, value</p>
<p>使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。</p>
<p>GLOBL divtab(SB), RODATA, $64</p>
<p>GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">DATA age+0x00<span class="o">(</span>SB<span class="o">)</span>/4, <span class="nv">$18</span>  // forever <span class="m">18</span>
</span></span><span class="line"><span class="cl">GLOBL age<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$4</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DATA pi+0<span class="o">(</span>SB<span class="o">)</span>/8, <span class="nv">$3</span>.1415926
</span></span><span class="line"><span class="cl">GLOBL pi<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DATA birthYear+0<span class="o">(</span>SB<span class="o">)</span>/4, <span class="nv">$1988</span>
</span></span><span class="line"><span class="cl">GLOBL birthYear<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$4</span>
</span></span></code></pre></div><p>有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">DATA bio&lt;&gt;+0<span class="o">(</span>SB<span class="o">)</span>/8, <span class="s2">$&#34;oh yes i&#34;</span>
</span></span><span class="line"><span class="cl">DATA bio&lt;&gt;+8<span class="o">(</span>SB<span class="o">)</span>/8, <span class="s2">$&#34;am here &#34;</span>
</span></span><span class="line"><span class="cl">GLOBL bio&lt;&gt;<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$16</span>
</span></span></code></pre></div><p>大部分都比较好理解，不过这里我们又引入了新的标记 &lt;&gt;，这个跟在符号名之后，表示该全局变量只在当前文件中生效，类似于 C 语言中的 static。如果在另外文件中引用该变量的话，会报 relocation target not found 的错误。</p>
<p>flag的其他取值</p>
<blockquote>
<p>NOPROF = 1
(For TEXT items.) Don&rsquo;t profile the marked function. This flag is deprecated.</p>
</blockquote>
<blockquote>
<p>DUPOK = 2
It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use.</p>
</blockquote>
<blockquote>
<p>NOSPLIT = 4
(For TEXT items.) Don&rsquo;t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself.</p>
</blockquote>
<blockquote>
<p>RODATA = 8
(For DATA and GLOBL items.) Put this data in a read-only section.</p>
</blockquote>
<blockquote>
<p>NOPTR = 16
(For DATA and GLOBL items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector.</p>
</blockquote>
<blockquote>
<p>WRAPPER = 32
(For TEXT items.) This is a wrapper function and should not count as disabling recover.</p>
</blockquote>
<blockquote>
<p>NEEDCTXT = 64
(For TEXT items.) This function is a closure so it uses its incoming context register.</p>
</blockquote>
<h3 id="函数声明">函数声明</h3>
<pre tabindex="0"><code>// func add(a, b int) int
//   =&gt; 该声明定义在同一个 package 下的任意 .go 文件中
//   =&gt; 只有函数头，没有实现
TEXT pkgname·add(SB), NOSPLIT, $0-8
    MOVQ a+0(FP), AX
    MOVQ a+8(FP), BX
    ADDQ AX, BX
    MOVQ BX, ret+16(FP)
    RET
</code></pre><pre tabindex="0"><code>
                              参数及返回值大小
                                  | 
 TEXT pkgname·add(SB),NOSPLIT,$32-32
       |        |               |
      包名     函数名         栈帧大小(局部变量+可能需要的额外调用函数的参数空间的总大小，但不包括调用其它函数时的 ret address 的大小)
</code></pre><p>为什么要叫 TEXT ？如果对程序数据在文件中和内存中的分段稍有了解的同学应该知道，我们的代码在二进制文件中，是存储在 .text 段中的，这里也就是一种约定俗成的起名方式。实际上在 plan9 中 TEXT 是一个指令，用来定义一个函数。除了 TEXT 之外还有前面变量声明说到的 DATA/GLOBL。</p>
<h3 id="栈结构">栈结构</h3>
<p><img src="https://s2.loli.net/2023/11/19/yWCViLIpnArb4w9.png" alt="image.png"></p>
<p>在 AMD64 环境，伪 PC 寄存器其实是 IP 指令计数器寄存器的别名。伪 FP 寄存器对应的是函数的帧指针，一般用来访问函数的参数和返回值。伪 SP 栈指针对应的是当前函数栈帧的底部（不包括参数和返回值部分），一般用于定位局部变量。伪 SP 是一个比较特殊的寄存器，因为还存在一个同名的 SP 真寄存器。真 SP 寄存器对应的是栈的顶部，一般用于定位调用其它函数的参数和返回值。</p>
<p>当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如 (SP)、+8(SP) 没有标识符前缀为真 SP 寄存器，而 a(SP)、b+8(SP) 有标识符为前缀表示伪寄存器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">                                                                                   
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       current func arg0                                           
</span></span><span class="line"><span class="cl">                       ----------------- &lt;----------- FP<span class="o">(</span>pseudo FP<span class="o">)</span>                
</span></span><span class="line"><span class="cl">                        <span class="nb">caller</span> ret addr                                            
</span></span><span class="line"><span class="cl">                       +---------------+                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span> <span class="nb">caller</span> BP<span class="o">(</span>*<span class="o">)</span>  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       ----------------- &lt;----------- SP<span class="o">(</span>pseudo SP，实际上是当前栈帧的 BP 位置<span class="o">)</span>
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var0  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var1  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var2  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                -                          
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   ........    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local VarN  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  temporarily  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  unused space <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call retn    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call ret<span class="o">(</span>n-1<span class="o">)</span><span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  ..........   <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call ret1    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call argn    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   .....       <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg3    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg2    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>---------------<span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg1    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------   &lt;------------  hardware SP 位置           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span> <span class="k">return</span> addr   <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       +---------------+                                           
</span></span><span class="line"><span class="cl">                                                                                   
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">                                                                                                                              
</span></span><span class="line"><span class="cl">                                       <span class="nb">caller</span>                                                                                 
</span></span><span class="line"><span class="cl">                                 +------------------+                                                                         
</span></span><span class="line"><span class="cl">                                 <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       +----------------------&gt;  --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span> <span class="nb">caller</span> parent BP <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>           BP<span class="o">(</span>pseudo SP<span class="o">)</span> --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   Local Var0     <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   .......        <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   Local VarN     <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">                                 --------------------                                                                         
</span></span><span class="line"><span class="cl"> <span class="nb">caller</span> stack frame              <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">                                 <span class="p">|</span>   callee arg2    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   callee arg1    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   callee arg0    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         ----------------------------------------------+   FP<span class="o">(</span>virtual register<span class="o">)</span>                       
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   <span class="k">return</span> addr    <span class="p">|</span>  parent <span class="k">return</span> address   <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">       +----------------------&gt;  +------------------+---------------------------    &lt;-------------------------------+         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>  <span class="nb">caller</span> BP               <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>  <span class="o">(</span><span class="nb">caller</span> frame pointer<span class="o">)</span>  <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                     BP<span class="o">(</span>pseudo SP<span class="o">)</span>  ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local Var0           <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local Var1           <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    ----------------------------                            callee stack frame
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>       .....              <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local VarN           <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                  SP<span class="o">(</span>Real Register<span class="o">)</span> ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    +--------------------------+    &lt;-------------------------------+         
</span></span><span class="line"><span class="cl">                                                                                                                              
</span></span><span class="line"><span class="cl">                                                              callee
</span></span></code></pre></div><h3 id="argsize">argsize</h3>
<p>函数声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"> TEXT pkgname·add<span class="o">(</span>SB<span class="o">)</span>,NOSPLIT,<span class="nv">$16</span>-32
</span></span></code></pre></div><p>前面已经说过 $16-32 表示 $framesize-argsize。Go 在函数调用时，参数和返回值都需要由 caller 在其栈帧上备好空间。callee 在声明时仍然需要知道这个 argsize。argsize 的计算方法是，参数大小求和+返回值大小求和，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。</p>
<h3 id="framesize">framesize</h3>
<p>函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：</p>
<ol>
<li>局部变量，及其每个变量的 size。</li>
<li>在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。</li>
<li>原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会死。</li>
<li>在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。</li>
</ol>
<h2 id="官方文档学习">官方文档学习</h2>
<p>参考自<a href="https://go.dev/doc/asm">A Quick Guide to Go&rsquo;s Assembler</a></p>
<h2 id="实践">实践</h2>
<p>以下的内容基于自己的实践</p>
<h3 id="command">Command</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool compile
</span></span></code></pre></div><p>可以通过 go doc cmd/compile 来查看该命令的文档</p>
<p>根据文档可以得知用法如下</p>
<p>go tool compile [flags] file&hellip;</p>
<p>flag：</p>
<ul>
<li>D 设置导入的相对位置</li>
<li>I dir1 I dir2 设置导入包的位置</li>
<li>S 输出汇编代码</li>
<li>N 禁止优化</li>
</ul>
<h3 id="例子">例子</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── compile
</span></span><span class="line"><span class="cl">│   └── main.go
</span></span><span class="line"><span class="cl">└── pkg
</span></span><span class="line"><span class="cl">    ├── pkg_amd64.s
</span></span><span class="line"><span class="cl">    └── var.go
</span></span></code></pre></div><p>main打印pkg中的Id变量，var.go声明，pkg_amd64.s实现</p>
<pre tabindex="0"><code>#include &#34;textflag.h&#34;

GLOBL ·Id(SB),NOPTR,$8

DATA ·Id+0(SB)/1,$0x37
DATA ·Id+1(SB)/1,$0x25
DATA ·Id+2(SB)/1,$0x00
DATA ·Id+3(SB)/1,$0x00
DATA ·Id+4(SB)/1,$0x00
DATA ·Id+5(SB)/1,$0x00
DATA ·Id+6(SB)/1,$0x00
DATA ·Id+7(SB)/1,$0x00
</code></pre><h2 id="reference">Reference</h2>
<ol>
<li><a href="https://mioto.me/2021/01/plan9-assembly/">Plan9 汇编入门讲解</a></li>
<li><a href="https://xargin.com/plan9-assembly/">Go 系列文章3 ：plan9 汇编入门</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-01-basic.html">go高级编程</a></li>
<li><a href="https://segmentfault.com/a/1190000039753236">这个很好</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis-single</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</guid>
      <description>本文记录分布式redis的学习过程 replication(主从) 命令 一般是从节点向主节点发起复制请求 &amp;gt; REPLICAOF host port 原理 Redis的复制主要包括同步</description>
      <content:encoded><![CDATA[<h1 id="本文记录分布式redis的学习过程">本文记录分布式redis的学习过程</h1>
<h2 id="replication主从">replication(主从)</h2>
<h3 id="命令">命令</h3>
<p>一般是从节点向主节点发起复制请求</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">&gt; REPLICAOF host port
</span></span></code></pre></div><h3 id="原理">原理</h3>
<p>Redis的复制主要包括同步（sync）和命令传播（command propagate）</p>
<h4 id="同步">同步</h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis-single</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</guid>
      <description>redis单机数据库的实现 数据库 服务端有一个结构体 struct redisServer { char *configfile; // 配置文件的绝对路径 int hz; // serverCron() 每秒调用的次数 redisDb *db; // 数据库 }; 命令 切换数据库SELEC</description>
      <content:encoded><![CDATA[<h2 id="redis单机数据库的实现">redis单机数据库的实现</h2>
<h3 id="数据库">数据库</h3>
<p>服务端有一个结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">configfile</span><span class="p">;</span>             <span class="c1">// 配置文件的绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">hz</span><span class="p">;</span>                       <span class="c1">// serverCron() 每秒调用的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>    <span class="c1">// 数据库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-b8fb33ad197578f8bd1e3d7c2962fe6b_720w.webp" alt="before"></p>
<h4 id="命令">命令</h4>
<p>切换数据库<code>SELECT ${dbnumber}</code>
<img src="https://pic4.zhimg.com/80/v2-691e28bc290a35f699bf145c5b655467_720w.webp" alt="after"></p>
<h3 id="键空间">键空间</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数据库键空间，保存着数据库中的所有键值对    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</span></span></code></pre></div><p><img src="https://pic1.zhimg.com/80/v2-03929f00f0134f78a34813e419d8ba54_720w.webp" alt=""></p>
<p>增删改查基本都和dict有关，还有一些其他操作比如FLUSHDB，RANDOMKEY，KEYS等等也都是对键值对进行操作得到的。</p>
<p>值得注意的是在读写键时redis会维护相关信息：</p>
<ol>
<li>记录hit&amp;miss信息</li>
<li>更新LRU时间</li>
<li>如果过期则删除</li>
<li>WATCH指令会记录并发送事件</li>
<li>每次修改会incr dirty flag（影响持久化）</li>
</ol>
<h4 id="键的过期或生存时间">键的过期或生存时间</h4>
<h5 id="命令-1">命令</h5>
<p>基本上就是EXPIRE，PEXPIRE，EXPIREAT，TTL，PERSIST这几个</p>
<h5 id="实现结构">实现结构</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数据库键空间，保存着数据库中的所有键值对    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span> <span class="c1">// 过期字典，保存着键的过期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</span></span></code></pre></div><p>就是dict键值对字典差不多，区别在于值是 long long类型的而已。</p>
<h5 id="过期键的判定和删除">过期键的判定和删除</h5>
<p>判定：</p>
<p>先去expires字典找过期时间，然后和当前时间比较，如果过期则返回-1，否则返回剩余时间。</p>
<p>删除：</p>
<h6 id="1-定时删除">1. 定时删除</h6>
<p>内存友好（该删就删），cpu不友好（时间事件中断，查找时间事件的无序链表复杂度为O(N)）</p>
<p>创建KEY的时候创建一个timer.</p>
<h6 id="2-惰性删除">2. 惰性删除</h6>
<p>内存不友好 （只有要用到才删除） cpu友好</p>
<p><img src="https://pic3.zhimg.com/80/v2-df499f6f57bdf2870241805949e1be5e_720w.webp" alt="">
<img src="https://pic3.zhimg.com/80/v2-14c9a6009d9dfe2b0a1439b7d1caeff2_720w.webp" alt=""></p>
<h6 id="3-定期删除">3. 定期删除</h6>
<p>在上面两个方案之间权衡，隔一段时间扫描一次，删除过期的键。</p>
<p>实现：</p>
<p>每次servercron执行的时候就会执行activeExpireCycle函数，这个函数会遍历所有db里的所有键（随机取出）执行一段时间。下次执行的时候会从上次停止的地方继续执行。</p>
<h5 id="aof和rdb对过期键的处理">AOF和RDB对过期键的处理</h5>
<p>生成AOF和RDB的时候会检查键是否过期，如果过期则不会生成。</p>
<p>载入：</p>
<p>RDB：</p>
<p>主服务器不会载入过期键，从服务器会载入所有。</p>
<p>AOF：</p>
<p>删除过期键会在AOF中记录一条DEL命令。</p>
<h3 id="持久化">持久化</h3>
<h4 id="rdb">RDB</h4>
<p>AOF优先级大于RDB，如果开启了AOF则RDB不会执行。</p>
<p>SAVE和BGSAVE：SAVE会阻塞，BGSAVE是fork一个子进程来执行，fork下的子进程会继承虚页表，写时复制，所以不会占用太多内存。当主进程进行写操作时，会把写操作涉及的物理内存页先拷贝一份，子进程的虚拟内存指向新的这个物理内存页，这也就是COW特性。</p>
<p>BGSAVE和BGWRITEAOF的冲突的，也就是不能同时执行。</p>
<p>配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 900秒内如果有1个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">900</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 300秒内如果有10个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">300</span> <span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 60秒内如果有10000个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">60</span> <span class="m">10000</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//修改计数器,之前说过每次对键的操作会记录dirty flag，此时可以用来判断是否需要BGSAVE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//上一次执行保存的时间,和上面配合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">time_t</span> <span class="n">lastsave</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//记录保存条件的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">saveparam</span> <span class="o">*</span><span class="n">saveparams</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">saveparam</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 秒数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">time_t</span> <span class="n">seconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改的key的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">changes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>检查是否需要BGSAVE的判断是在serverCron里面的，每次执行都会检查是否需要执行BGSAVE，如果需要则执行。</p>
<h5 id="rdb文件结构">RDB文件结构</h5>
<p><img src="https://pic2.zhimg.com/80/v2-1bdd8f1ecbb3ecfb3533caaa81e355fd_720w.webp" alt=""></p>
<p>可以有多个database，每个database里面是[SELECT,db_number,key_value_pairs]</p>
<p>key_value_pairs里面是[TYPE,key,value],如果是带过期时间的话[EXPIRETIME_MS,ms,TYPE,Key,Value]</p>
<h4 id="aof">AOF</h4>
<h4 id="实现">实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//AOF缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">aof_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>命令追加：</p>
<p>客户端发出的命令会追加到aof_buf后。</p>
<p>AOF文件的写入和同步</p>
<p>AOF文件的写入判断是在事件处理循环中的flushAppendOnlyFile函数中。</p>
<p>flushAppendOnlyFile根据服务器配置的appendfsync来决定是否需要同步。</p>
<ul>
<li>always： 每次都把aof_buf缓冲区里面的内容写入并同步到AOF文件</li>
<li>everysec：写入到AOF文件，如果距离上次同步超过1sec就同步(syscall fsync)</li>
<li>no： 写入AOF文件，但是不同步</li>
</ul>
<h5 id="载入">载入</h5>
<p>虚拟出一个不带网络连接的客户端一条条指令读取执行。</p>
<h5 id="重写">重写</h5>
<p>其实就和rocksdb的compaction差不多</p>
<p>值得注意的是后台重写，子进程fork之后会有一个AOF重写缓冲区，在重写过程中命令会被同时写到AOF缓冲和AOF重写缓冲区。在子进程重写完后会给父进程发送一个信号，父进程接受到信号后会把AOF重写缓冲区的内容写到AOF文件中并替换旧的。</p>
<h3 id="事件">事件</h3>
<p>事件分为文件事件（fd）和时间事件</p>
<h4 id="文件事件">文件事件</h4>
<p>i/o多路复用处理事件可以看我的另一篇文章[interview-linux]</p>
<h5 id="事件类型">事件类型</h5>
<ol>
<li>AE_READABLE 可读事件(优先级高)</li>
<li>AE_WRITEABLE 可写事件</li>
</ol>
<h5 id="文件事件处理器">文件事件处理器</h5>
<ol>
<li>连接应答处理器</li>
<li>命令请求处理器</li>
<li>命令回复处理器</li>
</ol>
<p>完整流程：</p>
<p>服务器启动时将监听套接字的AE_READABLE的处理事件设为连接应答处理器&hellip;建立连接（创建客户端fd并将该fd的AE_READBABLE与应答处理器关联还有AE_WRITABLE同理），之后就可以正常处理对应事件了，注意当命令结果全部写回套接字时，AE_WRITABLE会被解除对应事件的关联。</p>
<h4 id="时间事件">时间事件</h4>
<p>主要有两类：</p>
<ol>
<li>
<p>定时事件</p>
</li>
<li>
<p>周期事件</p>
</li>
</ol>
<h5 id="实现-1">实现</h5>
<p>time_event包含3个属性：id(全局唯一)，when(毫秒)，timeProc(回调函数)</p>
<p>根据timeProc的返回值判断定时or定期</p>
<p>定时：返回ae.h/AE_NOMORE
定期：返回别的</p>
<p>所有time_event结构体包含在一个无序链表中（新事件插入到表头），每次都会遍历这个链表，如果when小于当前时间则执行对应的回调函数。</p>
<p>时间事件应用示例：serverCron函数</p>
<p>serverCron函数作用</p>
<ul>
<li>更新统计信息</li>
<li>是否删除过期键值对</li>
<li>是否进行持久化</li>
<li>主从是否同步</li>
<li>是否关闭客户端连接</li>
</ul>
<h4 id="事件调度">事件调度</h4>
<p>就是一个循环，先获取最近的一个事件（有可能已经过去），设置timeinterval（可能0），在这个time-interval里面找文件事件，然后分别处理这些事件。</p>
<h3 id="clientserver">client&amp;server</h3>
<h4 id="client">client</h4>
<p>CLIENT LIST来显示client信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//-1代表伪客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//name 用CLIENT setname来设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 标记状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">querybuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命令参数数组，每个都是一个字符串对象【set】 【key】 【&#34;value&#34;】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命令参数数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向当前正在执行的命令对象,是通过argv的第0个值在command字典里面找的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 固定输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">REDIS_REPLY_CHUNK_BYTES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//buf数组已使用字节数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">bufpos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//不固定输出缓冲区,多个字符串构成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//身份验证 0 代表未通过，1代表通过。使用AUTH password 来验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">authenticated</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//时间相关的记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//伪客户端一直存在，直到server被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisClient</span> <span class="o">*</span><span class="n">lua_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="客户端的创建和关闭">客户端的创建和关闭</h5>
<h6 id="创建">创建</h6>
<p>如果是通过网络，那就会调用连接应答处理器来将一个CLient添加到redisServer的client链表末尾</p>
<h6 id="关闭">关闭</h6>
<p>关闭的原因有很多</p>
<ol>
<li>客户端主动退出</li>
<li>被Client kill杀死</li>
<li>timeout超时，但是主从复制，或者是pubsub的客户端不会超时</li>
<li>输入输出缓冲区溢出</li>
</ol>
<h4 id="server">server</h4>
<p>一个命令的执行流程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisCommand</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisCommmandProc</span><span class="o">*</span> <span class="n">proc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//参数个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">arity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//字符串表示的FLAG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">sflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//实际FLAG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>客户端键入<code> SET KEY VALUE</code></li>
<li>客户端翻译成协议格式</li>
<li>发送到服务端，服务端解析到对应CLient结构的argv和argc
<ol>
<li>命令执行器(1)查找命令实现（在命令表字典里面找{&ldquo;SET&rdquo;,*redisCommand}）</li>
<li>命令执行器(2) 执行预备操作
<ul>
<li>检查cmd指针是不是NULL</li>
<li>检查命令的参数个数是否正确</li>
<li>检查身份验证</li>
<li>等等</li>
</ul>
</li>
<li>命令执行器(3) 执行命令
<ul>
<li>读取键值对</li>
<li>执行命令</li>
<li>返回结果</li>
</ul>
</li>
<li>命令执行器(4) 执行后续操作
<ul>
<li>AOF</li>
<li>判断是否需要记录为慢查询</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="servercron函数">serverCron函数</h5>
<ul>
<li>更新时间，redisServer结构中有两个属性分别是unixtime和mstime，分别记录了秒和毫秒，这是为了减少获取时间的系统调用次数。这两个值被用来操作时间精度要求不高的功能（LRU时间更新，打印日志）</li>
<li>更新统计信息，比如命中率，命中次数，miss次数，命令执行次数，命令执行耗时等等</li>
<li>是否删除过期键值对，这个在上面已经说过了</li>
<li>是否进行持久化，这个也在上面说过了</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Golang 编译器代码浅析》阅读</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/13/category/golang-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B5%85%E6%9E%90%E9%98%85%E8%AF%BB/</link>
      <pubDate>Mon, 13 Nov 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/13/category/golang-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B5%85%E6%9E%90%E9%98%85%E8%AF%BB/</guid>
      <description>Golang 编译器代码浅析</description>
      <content:encoded><![CDATA[<p><a href="https://gocompiler.shizhz.me/">Golang 编译器代码浅析</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-base-structure</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-base-structure/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-base-structure/</guid>
      <description>记录golang中的底层数据结构 slice 基础的东西比如len，cap，ptr这些东西就不说了 从slice中获取内存地址和从内存中构造slice 从s</description>
      <content:encoded><![CDATA[<h1 id="记录golang中的底层数据结构">记录golang中的底层数据结构</h1>
<h2 id="slice">slice</h2>
<p>基础的东西比如len，cap，ptr这些东西就不说了
<img src="https://img.halfrost.com/Blog/ArticleImage/57_2.png" alt="go slice"></p>
<h3 id="从slice中获取内存地址和从内存中构造slice">从slice中获取内存地址和从内存中构造slice</h3>
<h4 id="从slice中获取内存地址">从slice中获取内存地址</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></div><h4 id="从内存中构造slice">从内存中构造slice</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s1</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">addr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}{</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">))</span>
</span></span></code></pre></div><p>或者使用go的反射包中的SliceHeader</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">o</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)((</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Cap</span> <span class="p">=</span> <span class="nx">length</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Len</span> <span class="p">=</span> <span class="nx">length</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>BTW 为了看懂上面的代码我还去学了下unsafe包(还是蛮简单的)</p>
</blockquote>
<p>值得注意的是reflect.SliceHeader已经被弃用了，下面是go的官方解释</p>
<blockquote>
<p>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</p>
</blockquote>
<p>其实就是uintptr是不能保证数据不被GC掉，然后SliceHeader已经被移到unsafe里面去了。</p>
<h3 id="空切片和nil切片的区别">空切片和nil切片的区别</h3>
<p>空切片
<img src="https://img.halfrost.com/Blog/ArticleImage/57_7.png" alt="空"></p>
<p>nil切片
<img src="https://img.halfrost.com/Blog/ArticleImage/57_8.png" alt="nil切片"></p>
<p>一个是指向一个空的数组，一个是指向nil</p>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<h2 id="map">map</h2>
<p>比较复杂，见另一篇文章。</p>
<h3 id="参考">参考</h3>
<ol>
<li><a href="https://eddycjy.com/posts/go/map-con/">Go 为什么不在语言层面支持 map 并发？</a></li>
</ol>
<h2 id="syncmap">sync.map</h2>
<p>为了并发的map而被设计出来，在两种情况下他的性能是最好的</p>
<ol>
<li>when the entry for a given key is only ever written once but read many times, as in caches that only grow.</li>
<li>when multiple goroutines read, write, and overwrite entries for disjoint sets of keys.</li>
</ol>
<p>同时定义了两大类操作：</p>
<ol>
<li>Load, LoadAndDelete, LoadOrStore, Swap, CompareAndSwap, and CompareAndDelete are read operations;</li>
<li>Delete, LoadAndDelete, Store, and Swap are write operations;</li>
</ol>
<p>而且<strong>LoadOrStore is a write operation when it returns loaded set to false; CompareAndSwap is a write operation when it returns swapped set to true; and CompareAndDelete is a write operation when it returns deleted set to true.</strong></p>
<p>在go的内存模型中<em>Map arranges that a write operation “synchronizes before” any read operation that observes the effect of the write</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//即使old设成nil也不能判断空的是删除成功，所以返回true的语义很强（本身存在key，并且和old一样）
</span></span></span><span class="line"><span class="cl"><span class="c1">//CompareAndDelete deletes the entry for key if its value is equal to old. The old value must be of a comparable type.
</span></span></span><span class="line"><span class="cl"><span class="c1">//If there is no current value for key in the map, CompareAndDelete returns false (even if the old value is the nil interface value).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">CompareAndDelete</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">deleted</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//nil是不可比较的，所以同样不可以把 old设成nil
</span></span></span><span class="line"><span class="cl"><span class="c1">//CompareAndSwap swaps the old and new values for key if the value stored in the map is equal to old. The old value must be of a comparable type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">any</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//无法从返回值中得到信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//这个倒是和普通map挺像的
</span></span></span><span class="line"><span class="cl"><span class="c1">//Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Load</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//本来在单线程的话是可以分两个操作的，但是在并发场景下就只能合在一起形成新的primitive
</span></span></span><span class="line"><span class="cl"><span class="c1">//LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadAndDelete</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//和上面差不多
</span></span></span><span class="line"><span class="cl"><span class="c1">//LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">actual</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//遍历的方式，可以在其中删除map中的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//常规
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">previous</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="channel">channel</h2>
<h3 id="数据结构">数据结构</h3>
<h3 id="参考-1">参考</h3>
<ol>
<li><a href="https://www.bilibili.com/video/BV1uv4y187p6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7d9aad84add3e8bea9beb1d04c53f57e">go channel视频</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-pprof</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-pprof/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-pprof/</guid>
      <description>简单介绍 是什么 pprof 是用于可视化和分析性能分析数据的工具 pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告） profile.proto 是一个</description>
      <content:encoded><![CDATA[<h2 id="简单介绍">简单介绍</h2>
<blockquote>
<p>是什么
pprof 是用于可视化和分析性能分析数据的工具</p>
</blockquote>
<blockquote>
<p>pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）</p>
</blockquote>
<blockquote>
<p>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p>
</blockquote>
<blockquote>
<p>支持什么使用模式</p>
</blockquote>
<blockquote>
<ul>
<li>Report generation：报告生成</li>
<li>nteractive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
</blockquote>
<blockquote>
<p>可以做什么</p>
<ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">pprof实战</a></li>
<li><a href="https://howieyuen.github.io/docs/golang/tools/pprof/">pprof</a></li>
<li><a href="https://github.com/eddycjy/blog/blob/master/content/posts/go/tools/2018-09-15-go-tool-pprof.md">煎鱼大佬的博客</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-snowflake</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-snowflake/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-snowflake/</guid>
      <description>雪花算法 1.第一位 占用1bit，其值始终是0，没有实际作用。 2.时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。 3.工作机器i</description>
      <content:encoded><![CDATA[<h1 id="雪花算法">雪花算法</h1>
<p><img src="https://pic4.zhimg.com/80/v2-0ca4a4125b1cbda69cfa972b1e568ffb_720w.webp" alt=""></p>
<p>1.第一位 占用1bit，其值始终是0，没有实际作用。 2.时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。 3.工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。 4.序列号 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p>
<blockquote>
<p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢：： 同一毫秒的ID数量 = 1024 X 4096 = 4194304</p>
</blockquote>
<h2 id="这里的代码实现是基于osproxy的">这里的代码实现是基于osproxy的</h2>
<h3 id="变量和类型">变量和类型</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">snowFlake</span> <span class="o">*</span><span class="nx">Snowflake</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">twepoch</span>            <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1417937700000</span><span class="p">)</span> <span class="c1">// Unix纪元时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">workerIdBits</span>       <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>              <span class="c1">// 机器ID所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">datacenterBits</span>     <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>              <span class="c1">// 数据中心ID所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxWorkerId</span>        <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">workerIdBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxDatacenterId</span>    <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">datacenterBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequenceBits</span>       <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="c1">// 序列号所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">workerIdShift</span>      <span class="p">=</span> <span class="nx">sequenceBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">datacenterIdShift</span>  <span class="p">=</span> <span class="nx">sequenceBits</span> <span class="o">+</span> <span class="nx">workerIdBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timestampLeftShift</span> <span class="p">=</span> <span class="nx">sequenceBits</span> <span class="o">+</span> <span class="nx">workerIdBits</span> <span class="o">+</span> <span class="nx">datacenterBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequenceMask</span>       <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">sequenceBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Snowflake</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>            <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastTimestamp</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">workerId</span>      <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">datacenterId</span>  <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequence</span>      <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="初始化">初始化</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">InitSnowFlake</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这里只有一个数据中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//使用ip来标识每台机器，可能可以根据mac地址来表示，然后通过网关ip来标识数据中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// get local ip
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ip</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetOutBoundIP</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// get workId from redis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">workId</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lgRedis</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">plugins</span><span class="p">.</span><span class="nx">LangGoRedis</span><span class="p">).</span><span class="nf">NewRedis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ipExist</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">).</span><span class="nf">Val</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ipExist</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">curWorkId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workId</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">curWorkId</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//在redis中存{ip:workerID}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//而且记录workerID的key是一个自增的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">newWorkId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Incr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">WorkID</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">,</span> <span class="nx">newWorkId</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workId</span> <span class="p">=</span> <span class="nx">newWorkId</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newSnowFlake</span><span class="p">(</span><span class="nx">workId</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">snowFlake</span> <span class="p">=</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSnowFlake</span><span class="p">(</span><span class="nx">workerId</span><span class="p">,</span> <span class="nx">datacenterId</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Snowflake</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">workerId</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">workerId</span> <span class="p">&gt;</span> <span class="nx">maxWorkerId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;worker id out of range&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">datacenterId</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">datacenterId</span> <span class="p">&gt;</span> <span class="nx">maxDatacenterId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;datacenter id out of range&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Snowflake</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastTimestamp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workerId</span><span class="p">:</span>      <span class="nx">workerId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">datacenterId</span><span class="p">:</span>  <span class="nx">datacenterId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sequence</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="生成">生成</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NextId .
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sf</span> <span class="o">*</span><span class="nx">Snowflake</span><span class="p">)</span> <span class="nf">NextId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//毫秒级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timestamp</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//时钟回拨，在用雪花算法的id作为递增主键的时候是一个严重的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">timestamp</span> <span class="p">&lt;</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;clock moved backwards&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//同一时间就用sequence来区分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">timestamp</span> <span class="o">==</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="p">=</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">sequenceMask</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果sequence用完了，就等待下一毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 时钟回拨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">timestamp</span> <span class="o">&lt;=</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">timestamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">=</span> <span class="nx">timestamp</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//拼接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 相当于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">id</span> <span class="o">:=</span> <span class="p">((</span><span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">twepoch</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">timestampLeftShift</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">datacenterId</span> <span class="o">&lt;&lt;</span> <span class="nx">datacenterIdShift</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">workerId</span> <span class="o">&lt;&lt;</span> <span class="nx">workerIdShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">id</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="总结">总结</h3>
<p>实现得还是很精巧的，而且在初始化其实也有合理的入参，配合redis的自增来实现全局唯一id。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/qinguoyi/osproxy#%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5osproxy">osproxy</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-unsafe</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-unsafe/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-unsafe/</guid>
      <description>unsafe包介绍 首先，unsafe正如其名是不安全的。 来自go语言官方文档的警告 unsafe包的文档是这么说的： 导入unsafe的软件包可</description>
      <content:encoded><![CDATA[<h2 id="unsafe包介绍">unsafe包介绍</h2>
<p>首先，unsafe正如其名是不安全的。</p>
<blockquote>
<p>来自go语言官方文档的警告</p>
</blockquote>
<blockquote>
<p>unsafe包的文档是这么说的：</p>
</blockquote>
<blockquote>
<p>导入unsafe的软件包可能不可移植，并且不受Go 1兼容性指南的保护。</p>
</blockquote>
<blockquote>
<p>Go 1 兼容性指南这么说：</p>
</blockquote>
<blockquote>
<p>导入unsafe软件包可能取决于Go实现的内部属性。 我们保留对可能导致程序崩溃的实现进行更改的权利。</p>
</blockquote>
<p>golang里面的三个指针类型</p>
<ul>
<li>*类型:普通指针类型，用于传递对象地址，不能进行指针运算。</li>
<li>unsafe.Pointer:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。</li>
<li>uintptr:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。</li>
</ul>
<h3 id="unsafe包里面">unsafe包里面</h3>
<p>函数：</p>
<p>func Alignof（variable ArbitraryType）uintptr</p>
<p>func Offsetof（selector ArbitraryType）uintptr</p>
<p>func Sizeof（variable ArbitraryType）uintptr</p>
<p>这里，ArbitraryType不是一个真正的类型，它只是一个占位符。与Golang中的大多数函数不同，上述三个函数的调用将始终在编译时求值，而不是运行时。 这意味着它们的返回结果可以分配给常量。</p>
<p>func String(ptr *byte, len IntegerType) string //(go 1.20)</p>
<p>func StringData(str string) *byte //(go 1.20)</p>
<p>这里只讲后两个新加的函数，StringData用于从string中获取地址，String函数用于从特定的字符串地址中截取len长度的子字符串。</p>
<p>类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其实和上面String的两个函数一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">func</span> <span class="nf">Slice</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="nx">ArbitraryType</span><span class="p">,</span> <span class="nx">len</span> <span class="nx">IntegerType</span><span class="p">)</span> <span class="p">[]</span><span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">SliceData</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">ArbitraryType</span><span class="p">)</span> <span class="o">*</span><span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//SliceData returns a pointer to the underlying array of the argument slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//If cap(slice) &gt; 0, SliceData returns &amp;slice[:1][0].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//If slice == nil, SliceData returns nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//Otherwise, SliceData returns a non-nil pointer to an unspecified memory address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntegerType</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其实就是封装了地址偏移函数，以前是要转成uintptr然后计算再转回来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">Pointer</span><span class="p">,</span> <span class="nx">len</span> <span class="nx">IntegerType</span><span class="p">)</span> <span class="nx">Pointer</span>
</span></span></code></pre></div><h2 id="参考">参考</h2>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1192566">Go里面的unsafe包详解 </a></li>
<li><a href="https://www.cnblogs.com/-wenli/p/12682477.html">pointer和uintptr</a></li>
<li><a href="https://www.cnblogs.com/-wenli/p/12681044.html">如何得到一个对象的内存大小</a></li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>