<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Yehh</title>
    <link>https://blog.yehaohui.com/zh-cn/</link>
    <description>Recent content on Yehh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Sep 2023 13:01:23 +0800</lastBuildDate>
    
    <atom:link href="https://blog.yehaohui.com/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://blog.yehaohui.com/zh-cn/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/about/</guid>
      <description>Hi! 我是叶浩辉 华南理工大学 软件学院二年级本科生, 兴趣集中在Computer Vision 和 Trustworthy Machine Learning。 希望不断学习，不断进步，通过深度阅读提升思</description>
      <content:encoded><![CDATA[<h2 id="hi-我是叶浩辉httpsblogyehaohuicom">Hi! 我是<a href="https://blog.yehaohui.com/">叶浩辉</a></h2>
<p><a href="https://www.scut.edu.cn/new/">华南理工大学</a> 软件学院二年级本科生, <del>兴趣集中在Computer Vision 和 Trustworthy Machine Learning。</del></p>
<p>希望不断学习，不断进步，通过深度阅读提升思考能力。</p>
<h2 id="关于本站">关于本站</h2>
<blockquote>
<p>本站灵感来自<a href="https://www.pseudoyu.com/zh/">pseudoyou</a>,真诚、自省的文字和开源的精神是我建站的目标。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>yehh-wiki</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/09/16/category/yehh-wiki/</link>
      <pubDate>Sat, 16 Sep 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/09/16/category/yehh-wiki/</guid>
      <description>这里记录一些有用的连接 设计一个软件(服务)的原则/最佳实践-12factors golang 有用的库 viper 配置库 fsnotify 跨平台的文件提醒(一般是文件修改的提醒吧)</description>
      <content:encoded><![CDATA[<h2 id="这里记录一些有用的连接">这里记录一些有用的连接</h2>
<p><a href="https://12factor.net/">设计一个软件(服务)的原则/最佳实践-12factors</a></p>
<h2 id="golang-有用的库">golang 有用的库</h2>
<ol>
<li>viper 配置库</li>
<li>fsnotify 跨平台的文件提醒(一般是文件修改的提醒吧)</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>DDIA-note</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/09/14/category/ddia-note/</link>
      <pubDate>Thu, 14 Sep 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/09/14/category/ddia-note/</guid>
      <description>Reference DDIA chinese</description>
      <content:encoded><![CDATA[<h2 id="reference">Reference</h2>
<p><a href="http://ddia.vonng.com/#/">DDIA chinese</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>interview-golang</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/09/13/category/interview-golang/</link>
      <pubDate>Wed, 13 Sep 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/09/13/category/interview-golang/</guid>
      <description>golang问题 init的执行顺序 Golang中变量的分配位置是堆or栈可以看看这个和刘丹冰的 GC[典藏版]Golang三色标记、混合写屏障</description>
      <content:encoded><![CDATA[<h2 id="golang问题">golang问题</h2>
<ol>
<li>init的执行顺序</li>
<li>Golang中变量的分配位置是堆or栈<a href="https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/stack-heap">可以看看这个</a>和<a href="https://studygolang.com/articles/27020">刘丹冰的</a></li>
<li>GC<a href="https://segmentfault.com/a/1190000022030353">[典藏版]Golang三色标记、混合写屏障GC模式图文全分析</a></li>
<li>扩容机制<a href="https://juejin.cn/post/7101928883280150558">Go 1.18 全新的切片扩容机制</a></li>
<li>Golang内存模型 <a href="https://cloud.tencent.com/developer/article/1422392">go内存管理</a> <a href="https://blog.wallenwang.com/2018/11/tcmalloc/#ftoc-heading-2">tcmalloc</a> <a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">go语言设计和实现</a></li>
</ol>
<h3 id="参考">参考</h3>
<p><a href="https://zhuanlan.zhihu.com/p/471490292">go常见面试</a></p>
<p><a href="https://golang.design/go-questions/">Go 程序员面试笔试宝典</a></p>
<p><a href="https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/stack-heap">跟着煎鱼学go</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">go语言设计与实现</a></p>
<h2 id="redis">redis</h2>
<h2 id="mysql">mysql</h2>
<h3 id="参考-1">参考</h3>
<p><a href="https://zhuanlan.zhihu.com/p/403656116">MySQL八股文连环45问（背诵版）</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>高性能Mysql-ch1、2</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/09/12/category/high_perfermance_mysql_ch1_2/</link>
      <pubDate>Tue, 12 Sep 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/09/12/category/high_perfermance_mysql_ch1_2/</guid>
      <description>高性能Mysql 该系列主要是记录阅读高性能Mysql的一些笔记。 Mysql架构 架构的逻辑视图 连接管理和安全 每个客户端连接都会有一个线程，连接</description>
      <content:encoded><![CDATA[<h2 id="高性能mysql">高性能Mysql</h2>
<p>该系列主要是记录阅读高性能Mysql的一些笔记。</p>
<h3 id="mysql架构">Mysql架构</h3>
<h4 id="架构的逻辑视图">架构的逻辑视图</h4>
<p><img src="https://s2.loli.net/2023/09/12/sLkCIeyThaqAY3J.png" alt="如果无法打开请使用魔法"></p>
<h4 id="连接管理和安全">连接管理和安全</h4>
<p>每个客户端连接都会有一个线程，连接时会有身份验证，连接成功后还会验证用户是否具有执行每个查询的权限。</p>
<h4 id="优化和执行">优化和执行</h4>
<p>优化器不关心存储引擎的具体实现，但是存储引擎的确影响优化(Innodb和myisam在索引上的不同),优化器会向存储引擎查询他的一些功能和表的统计信息。</p>
<h4 id="锁的粒度">锁的粒度</h4>
<ol>
<li>表锁
锁定整张表</li>
<li>行锁
但是会有更多开销(跟踪拥有锁的用户，多久释放)</li>
</ol>
<h4 id="事务">事务</h4>
<p>主要就是ACID特性，这些在DB课上都学过，在此回顾一遍</p>
<ol>
<li>Atomicity</li>
</ol>
<p>原子性，事务内的语句不可分割，要么全执行，要么都不执行。</p>
<ol start="2">
<li>Consistency</li>
</ol>
<p>事务完成前后都处于一致性状态，e.g 钱的总数不变</p>
<ol start="3">
<li>Isolation</li>
</ol>
<p>一个事务在最终提交之前，其他的事务对其做出的修改不可见。</p>
<ol start="4">
<li>Durability</li>
</ol>
<p>事务提交后数据被持久化下来。</p>
<h4 id="隔离级别">隔离级别</h4>
<p>这也是很重要的概念</p>
<ol>
<li>
<p>(READ UNCOMMITTED)未提交读</p>
<p>A事务可以读B事务修改但未提交的数据(脏读)</p>
<ul>
<li>性能：没好很多</li>
<li>缺点：很多很多(主要是不一致)</li>
<li>几乎不使用</li>
</ul>
</li>
<li>
<p>(READ COMMITTED)提交读</p>
<p>大部分数据库系统使用这个隔离级别(但是Mysql不是),这会有个问题就是在A事务对某行的两次查询之间会有一个事务提交，导致不可重复读(两次读的结果不同)。</p>
</li>
<li>
<p>(REPEATABLE READ)可重复读</p>
<p>解决不可重复读问题，保证在同一个事务中多次读取相同行的结果是一样的。但是幻行(Phantom row)无法解决，也就在事务过程中会有新的记录被插入。</p>
</li>
<li>
<p>(SERIALIZABLE) 可串行化</p>
<p>每行数据都加锁(慢)</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读(幻行)</th>
<th>加锁读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h4 id="mvcc多版本并发控制">MVCC(多版本并发控制)</h4>
<p>推荐看</p>
<ol>
<li>Jeremy 大神的文章<a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/">The basics of the InnoDB undo logging and history system</a></li>
<li>中文比较好的文章<a href="https://zhuanlan.zhihu.com/p/52977862">数据库基础（四）Innodb MVCC实现原理</a></li>
<li>这个也不错<a href="https://zhuanlan.zhihu.com/p/231947511">一文搞懂InnoDB MVCC机制</a></li>
</ol>
<p>总结一下：</p>
<ol>
<li>
<p><strong>Undo logging</strong> and <strong>InnoDB’s “history” system</strong> are the mechanisms that underly its implementation of MVCC, but the way this works is generally very poorly understood.</p>
</li>
<li></li>
</ol>
<h4 id="heading"></h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>istio-day1</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/27/category/istio-day1/</link>
      <pubDate>Sun, 27 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/27/category/istio-day1/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>leetcode_record2</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/25/category/leetcode_record2/</link>
      <pubDate>Fri, 25 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/25/category/leetcode_record2/</guid>
      <description>力扣记录2 剑指 Offer 51. 数组中的逆序对 我对这题的评价是逆天 class Solution { public: int mergeSort(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; tmp, int l, int r) { if (l &amp;gt;= r) { return 0; } int mid = (l + r) / 2; int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);</description>
      <content:encoded><![CDATA[<h3 id="力扣记录2">力扣记录2</h3>
<h4 id="剑指-offer-51-数组中的逆序对httpsleetcodecnproblemsshu-zu-zhong-de-ni-xu-dui-lcofdescription"><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">剑指 Offer 51. 数组中的逆序对</a></h4>
<p>我对这题的评价是逆天</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">inv_count</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">inv_count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">inv_count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">inv_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">reversePairs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ol>
<li>
<p>先讲讲这题，递归归并排序后，左右两个数组是有序，然后在并的时候统计左侧比右侧大的数量，如何统计呢：就是在左边的归并的时候统计这个时候右侧数组左边有多少已经被归并，这些就是比左侧这个小的。</p>
</li>
<li>
<p>其实这道题还可以学到归并排序的写法：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">tmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//递归结束条件，可以变成l-r小于一定值时用插入排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 递归归并子数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 合并两个有序数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 统一对待剩下的左(右)数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将tmp数组的值复制到nums数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="剑指-offer-56---i-数组中数字出现的次数httpsleetcodecnproblemsshu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof"><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3>
<p>先贴代码，感觉这种题就是见过就知道&hellip;&hellip;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">singleNumbers</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">div</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">((</span><span class="n">div</span> <span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">div</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">div</span> <span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">a</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">b</span> <span class="o">^=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>首先一个前置知识是：异或运算的性质：两个相同的数异或为0，一个数和0异或还是它本身。所以当只有一个数字只出现一次时，我们可以将所有的数异或，最后得到的结果就是那个只出现一次的数。</p>
<p>所以这题就是如何分组使得每组只有一个只出现一次的数，那么我们可以先将所有的数异或，得到的结果就是那两个只出现一次的数异或的结果，然后我们找到这个结果中第一个为1的位，因为这个位是两个数不同的位，所以我们可以根据这个位将所有的数分成两组，这样每组就只有一个只出现一次的数了。</p>
<h3 id="剑指-offer-58---i-翻转单词顺序httpsleetcodecnproblemsfan-zhuan-dan-ci-shun-xu-lcof"><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3>
<p>之前用go写发现挺简单，但是用c++写inplace的就有点难了。</p>
<p>方法我是知道的，先全翻转然后单词翻转，主要就是要注意多个空格怎么办，实际上还是用双指针的思想把空格或者说不用的挪到最后面去，然后erase掉就行了。</p>
<p>上代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">start</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">start</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//  cout&lt;&lt;s&lt;&lt;endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39; &#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span><span class="p">(</span><span class="n">end</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39; &#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">idx</span><span class="o">-</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">),</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// idx+=end-start;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;idx:&#34;</span><span class="o">&lt;&lt;</span><span class="n">idx</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">start</span><span class="o">=</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">idx</span><span class="p">,</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="岛屿数量httpsleetcodecnproblemsnumber-of-islandsdescription"><a href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量</a></h3>
]]></content:encoded>
    </item>
    
    <item>
      <title>containerd-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/23/category/containerd-intro/</link>
      <pubDate>Wed, 23 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/23/category/containerd-intro/</guid>
      <description>Reference 容器运行时 containerd 学习笔记</description>
      <content:encoded><![CDATA[<h2 id="reference">Reference</h2>
<p><a href="https://www.aneasystone.com/archives/2023/06/containerd-notes.html">容器运行时 containerd 学习笔记</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Go 语言高性能编程》阅读</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/19/category/go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB/</link>
      <pubDate>Sat, 19 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/19/category/go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB/</guid>
      <description>这个系列是记录阅读《Go 语言高性能编程》这本书的一些笔记 第一章：Go 语言性能分析 在学生时期，测试很难被重视起来，但是写好测试是程序员的进阶之</description>
      <content:encoded><![CDATA[<h3 id="这个系列是记录阅读go-语言高性能编程这本书的一些笔记">这个系列是记录阅读《Go 语言高性能编程》这本书的一些笔记</h3>
<h4 id="第一章go-语言性能分析">第一章：Go 语言性能分析</h4>
<p>在学生时期，测试很难被重视起来，但是写好测试是程序员的进阶之路，性能分析往往基于测试。</p>
<p>详见<a href=""></a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>gee-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/19/category/gee-intro/</link>
      <pubDate>Sat, 19 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/19/category/gee-intro/</guid>
      <description>gee 本项目模仿极客兔兔的7天项目进行学习 gee-web 简介 这是一个简单的web框架，实现了路由、中间件、静态文件服务、模板渲染等功能。主要是模仿gin框架</description>
      <content:encoded><![CDATA[<h3 id="gee">gee</h3>
<p>本项目模仿极客兔兔的7天项目进行学习</p>
<h3 id="gee-web">gee-web</h3>
<h4 id="简介">简介</h4>
<p>这是一个简单的web框架，实现了路由、中间件、静态文件服务、模板渲染等功能。主要是模仿gin框架进行实现，下面就来说说从中学到的东西。</p>
<h5 id="context">context</h5>
<ol>
<li>
<p>每次请求都会创建一个context，所以在context中存储一些请求相关的信息是很有必要的，比如说请求的method、path、响应的writer等等，这些信息都是在请求过程中会用到的，所以在context中存储这些信息是很有必要的。</p>
</li>
<li>
<p>比如restful接口的构建，如果每次都要json然后encode会有很多重复代码。</p>
</li>
</ol>
<p>实现上</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// origin objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Writer</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Req</span>    <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// request info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Path</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Method</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// response info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StatusCode</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>基本就是把Writer req Path Method 等常用属性封装，然后提供一些常用的方法，比如说PostForm、Query、Status、SetHeader、String、JSON等等。</p>
<h5 id="router">router</h5>
<p>基于前缀树实现，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">router</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">roots</span>    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">handlers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">HandlerFunc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pattern</span>  <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">part</span>     <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">isWild</span>   <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意每个方法(GET POST)都有对应Node 根节点，然后看node的结构，包含pattern part children isWild，pattern是完整的路径，part是当前节点的路径，children是子节点，isWild表示是否精确匹配。</p>
<p>搜索时通过Path找到节点，然后根据patten来找到对应handler。</p>
<h5 id="group">group</h5>
<p>分组这个功能还是很有用的</p>
<ol>
<li>提供了逻辑上的隔离，使得每个分组中的路由都有相同的前缀，这样就可以提取公共的前缀，减少冗余代码。</li>
<li>中间件可以基于组来设置，这样就可以对某个组的路由设置中间件，而不是每个路由都设置中间件。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">RouterGroup</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">prefix</span>      <span class="kt">string</span>
</span></span><span class="line"><span class="cl">		<span class="nx">middlewares</span> <span class="p">[]</span><span class="nx">HandlerFunc</span> <span class="c1">// support middleware
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">parent</span>      <span class="o">*</span><span class="nx">RouterGroup</span>  <span class="c1">// support nesting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">engine</span>      <span class="o">*</span><span class="nx">Engine</span>       <span class="c1">// all groups share a Engine instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">Engine</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">RouterGroup</span>
</span></span><span class="line"><span class="cl">		<span class="nx">router</span> <span class="o">*</span><span class="nx">router</span>
</span></span><span class="line"><span class="cl">		<span class="nx">groups</span> <span class="p">[]</span><span class="o">*</span><span class="nx">RouterGroup</span> <span class="c1">// store all groups
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span></code></pre></div><p>实现就有点意思了，每个分组为了保持对engine的可见性(可能表述有问题),需要有一个engine的引用这样添加路由时才能添加到engine中，所以每个分组都有一个engine的引用，然后engine中有一个groups的属性，用来存储所有的分组，这样就可以通过engine来访问所有的分组了。</p>
<h5 id="middleware">middleware</h5>
<p>中间件的设计也很精巧</p>
<p>它是基于这样一种情景:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">A</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">part1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">part2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">B</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">part3</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">part4</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所以context需要添加一个index属性，用来记录当前执行到哪个中间件了，然后在Next方法中，先把index加1，然后执行中间件，然后再执行Next方法，这样就可以实现中间件的执行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个next设计很有意思，这个是从当前中间件的下一个进行遍历操作，而不是只执行下一个。这是因为有些中间件的操作是不调用next的，比如说logger中间件，它只是打印日志，然后就不需要执行下一个中间件了，所以这样设计是很合理的。然后与之配套的Context.Fail方法，用来中断中间件的执行也很有意思。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Fail</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">H</span><span class="p">{</span><span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">err</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>他这里会把index直接设置为最后，那么堆栈中嵌套调用的next都会立刻退出而不会继续执行下去。</p>
<p>差点漏说了，这个URL本身的Handler也被当成一个中间件放在最后，这样代码连贯性比较好。servehttp的时候就是调用next就开始执行了。</p>
<h5 id="panic-recover">panic-recover</h5>
<p>这个也是http框架必不可少的，因为http框架是一个长期运行的服务，所以必须要有panic-recover机制，不然一旦出现panic，整个服务就会挂掉，这是不允许的。</p>
<p>这gee(gin)中这是通过设置recover中间件来实现的也是一种很不错的方法。</p>
<h3 id="gee-cache">gee-cache</h3>
<h4 id="day1-lru">Day1 LRU</h4>
<p>基本上是用Map和list.List来实现LRU，要注意的是链表里面不止存value，还要存key因为这样删除的时候才可以O(1)删除map</p>
<h4 id="day2">Day2</h4>
<ol>
<li>byteview: 一个只读的数据结构，实现了查询长度和拷贝的功能。</li>
<li>回调 Getter，这一部分是为了实现缓存中找不到去更深层的数据源查找的功能。</li>
</ol>
<p>有意思的是这里用了一个Getter接口，然后用GetterFunc来实现这个接口，这样就可以用函数来实现这个接口了，这样就可以不用每次都实现一个结构体了(当然实现结构体也可以)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A Getter loads data for a key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Getter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A GetterFunc implements Getter with a function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">GetterFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get implements Getter interface function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">GetterFunc</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>Group</li>
</ol>
<p>group可以看成是命名空间，每个group有一个名字，然后每个group有一个cache，然后每个group有一个getter，这样就可以实现不同的group有不同的cache和getter了。</p>
<h4 id="day3-http-服务端">Day3 HTTP 服务端</h4>
<p>其实比较简单，就是写了一个HTTPPool的结构体，实现ServeHttp方法。要注意现在的HTTPPool是一个单机的，所以只能用来做单机的缓存。</p>
<h4 id="一致性哈希">一致性哈希</h4>
<p><img src="https://geektutu.com/post/geecache-day4/add_peer.jpg" alt=""></p>
<p>避免数据倾斜，一个真实节点可能对应多个缓存节点。</p>
<h4 id="实现">实现</h4>
<p>首先就是节点的添加，主要就是用一个数组有序存放各个虚拟节点hash值，再用一个hashmap存虚拟节点和真实节点的对应关系。
在根据key获取节点的时候就把key的hash值用来二分查找，然后找到第一个大于等于key的hash值，然后就可以找到对应的节点了。</p>
<h4 id="分布式节点">分布式节点</h4>
<ol>
<li>定义接口</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// PeerPicker is the interface that must be implemented to locate
</span></span></span><span class="line"><span class="cl"><span class="c1">// the peer that owns a specific key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerPicker</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PickPeer</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">peer</span> <span class="nx">PeerGetter</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// PeerGetter is the interface that must be implemented by a peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerGetter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Get</span><span class="p">(</span><span class="nx">group</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>由httppool实现peerPicker接口，利用其内部的一致性哈希模块选择真实节点。</li>
<li>httpgetter实现peergetter接口，利用http客户端从远程节点获取缓存值(其实就是封装了http请求)。</li>
<li>集成httppool到group中，就是修改一下load方法使其先pick再get。</li>
</ol>
<h4 id="day6">day6</h4>
<p>防止缓存击穿：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">singleflight</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>       <span class="c1">// protects m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>call 代表正在进行中，或已经结束的请求。使用 sync.WaitGroup 锁避免重入。</li>
<li>Group 是 singleflight 的主数据结构，管理不同 key 的请求(call)。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">))</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//提前返回结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">call</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//唯一一次调用fn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">delete</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>gee-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/19/category/gee-intro/</link>
      <pubDate>Sat, 19 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/19/category/gee-intro/</guid>
      <description>osproxy</description>
      <content:encoded><![CDATA[<p><a href="https://juejin.cn/post/7242284648021131323">osproxy</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang test</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/19/category/golang-test/</link>
      <pubDate>Sat, 19 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/19/category/golang-test/</guid>
      <description>标准库 testing 标准测试使用go test 来编译运行测试*_test.go文件，这些文件不是go build命令编译的对象。 *_test.go 中，有三种测试 功能测试 每一个测试</description>
      <content:encoded><![CDATA[<h2 id="标准库">标准库</h2>
<p>testing</p>
<p>标准测试使用go test 来编译运行测试*_test.go文件，这些文件不是go build命令编译的对象。</p>
<p>*_test.go 中，有三种测试</p>
<ol>
<li>
<p>功能测试</p>
<p>每一个测试文件必须导入testing包，并且函数的签名为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//以Test开头，后面的名称首字母大写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">TestName</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>基准测试</p>
<p>函数签名为</p>
<p>调用时: <code>go test -bench</code></p>
</li>
<li>
<p>示例函数</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>go-package-overview</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/16/category/net/http/</link>
      <pubDate>Wed, 16 Aug 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/16/category/net/http/</guid>
      <description>i/o io constants const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end ) 和c++的seekg一样，有三种相对寻找方式 variables 几种错误 //要注意E</description>
      <content:encoded><![CDATA[<h2 id="io">i/o</h2>
<h3 id="io-1">io</h3>
<h4 id="constants">constants</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SeekStart</span>   <span class="p">=</span> <span class="mi">0</span> <span class="c1">// seek relative to the origin of the file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">SeekCurrent</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// seek relative to the current offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">SeekEnd</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// seek relative to the end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></div><p>和c++的seekg一样，有三种相对寻找方式</p>
<h4 id="variables">variables</h4>
<p>几种错误</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//要注意EOF是一个error，应该把它当成一个特殊的错误来处理，而不是一个正常的错误，因为一个正常的read读到结尾也是会返回EOF的，如果是
</span></span></span><span class="line"><span class="cl"><span class="c1">//中间遇到了异常的EOF会返回ErrUnexpectedEOF 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">EOF</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;EOF&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//就是在一个关闭的pipe上读写，（应该是fd有问题）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrClosedPipe</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;io: read/write on closed pipe&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//read读不出数据，一般来说是read的implementation有问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrNoProgress</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;multiple Read calls return no data or error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// read的时候[]byte的size不够大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrShortBuffer</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;short buffer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// write 不够指定数目的字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrShortWrite</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;short write&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 提前读到EOF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ErrUnexpectedEOF</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;unexpected EOF&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="type">type</h4>
<p>基本就是读和写的接口</p>
<ol>
<li>
<p>byte相关: ByteReader, ByteScanner, ByteWriter(interface)</p>
</li>
<li>
<p>CLoser(interface)</p>
</li>
<li>
<p>LimitedReader</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="kd">type</span> <span class="nx">LimitedReader</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">R</span> <span class="nx">Reader</span> <span class="c1">// underlying reader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">N</span> <span class="kt">int64</span>  <span class="c1">// max bytes remaining
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span></code></pre></div><p>``</p>
</li>
<li>
<p>NewOffsetWriter 基本就是随机写入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">OffsetWriter</span><span class="p">)</span> <span class="nx">Seek</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">OffsetWriter</span><span class="p">)</span> <span class="nx">Write</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">OffsetWriter</span><span class="p">)</span> <span class="nx">WriteAt</span>
</span></span></code></pre></div></li>
<li>
<p>PipeReader 是一个没有可读就会一直阻塞直到有可读或者管道关闭</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">PipeReader</span><span class="p">)</span> <span class="nx">Close</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">PipeReader</span><span class="p">)</span> <span class="nx">CloseWithError</span>
</span></span><span class="line"><span class="cl">	<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">PipeReader</span><span class="p">)</span> <span class="nx">Read</span>
</span></span></code></pre></div></li>
<li>
<p>与之对应的是PipeWriter，函数基本差不多</p>
</li>
<li>
<p>Reader有几个有意思的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">//生成一个LimitedReader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">func</span> <span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">Reader</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//多个reader 按顺序concat在一起
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">func</span> <span class="nf">MultiReader</span><span class="p">(</span><span class="nx">readers</span> <span class="o">...</span><span class="nx">Reader</span><span class="p">)</span> <span class="nx">Reader</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//类似linux的tee指令，读入r的内容时会把对应的写入w，分流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">func</span> <span class="nf">TeeReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">w</span> <span class="nx">Writer</span><span class="p">)</span> <span class="nx">Reader</span>
</span></span></code></pre></div><p>``</p>
</li>
<li>
<p>ReaderAt就是从某个offset开始read，ReadFrom主要是Writer调用，并且主要用在copy上。</p>
</li>
<li>
<p>RuneReader RuneScanner就是针对rune做了改进</p>
</li>
<li>
<p>seeker 也一般</p>
</li>
<li>
<p>Writer 里面的MultiWriter 可以把一次write的内容写到所有write里面</p>
</li>
</ol>
<h4 id="function">function</h4>
<ol>
<li>
<p>copy(dst,src) 使用<a href="https://zhuanlan.zhihu.com/p/83398714#:~:text=%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88Zero%2Dcopy%EF%BC%89,%E5%9C%A8%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E8%B4%9F%E8%BD%BD%E3%80%82">零拷贝技术</a></p>
</li>
<li>
<p>func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) 使用如果没有实现readfrom writeto那就用自定义的buffer来进行缓冲，没有的话就新allocate一个</p>
</li>
<li>
<p>CopyN(dst,src)只是限制了copy的字节数量</p>
</li>
</ol>
<p>他们都依赖copyBuffer这个私有函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">copyBuffer</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果src实现了WriterTo接口，则直接使用其WriteTo方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">wt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">src</span><span class="p">.(</span><span class="nx">WriterTo</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">wt</span><span class="p">.</span><span class="nf">WriteTo</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果dst实现了ReaderFrom接口，则直接使用其ReadFrom方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">rt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dst</span><span class="p">.(</span><span class="nx">ReaderFrom</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配buf，默认每次最多拷贝32K
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">32</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nr</span><span class="p">,</span> <span class="nx">er</span> <span class="o">:=</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">nr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将读到的数据写入到输出流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">nw</span><span class="p">,</span> <span class="nx">ew</span> <span class="o">:=</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">nr</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">nw</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">written</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">nw</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 写出错，退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">ew</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">err</span> <span class="p">=</span> <span class="nx">ew</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 数据量不一致，报错退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">nr</span> <span class="o">!=</span> <span class="nx">nw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">err</span> <span class="p">=</span> <span class="nx">ErrShortWrite</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 拷贝完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">er</span> <span class="o">==</span> <span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 出错退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">er</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="p">=</span> <span class="nx">er</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">written</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="4">
<li>
<p>pipe() 返回pipe读和写管道</p>
</li>
<li>
<p>ReadAll ReadAtLeast ReadFull WriteString 其实都比较容易理解</p>
</li>
</ol>
<h3 id="ioutil">ioutil</h3>
<blockquote>
<p>Deprecated: As of Go 1.16, the same functionality is now provided by package io or package os, and those implementations should be preferred in new code. See the specific function documentation for details.</p>
</blockquote>
<h3 id="fmt">fmt</h3>
<p>占位符比较多，用到再看</p>
<p>常用函数还是要知道：</p>
<h4 id="函数">函数</h4>
<ol>
<li>
<p>Append Appendf Appendln</p>
<p><code>func Append(b []byte, a ...any) []byte</code> 一般是这样的格式</p>
</li>
<li>
<p>Fprint Fprintf Fprintln</p>
<p><code> func Fprint(w io.Writer, a ...any) (n int, err error)</code> 这样的格式</p>
</li>
<li>
<p>Sprint Sprintf Sprintln</p>
<p><code>func Sprint(a ...any) string</code> 这样的格式</p>
</li>
<li>
<p>Fscan Fscanf Fscanln</p>
<p><code>func Fscan(r io.Reader, a ...any) (n int, err error)</code> 这样的格式</p>
<p>给一个例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">i</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">        <span class="nx">b</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">        <span class="nx">s</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="s">&#34;5 true gophers&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fscanf</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="s">&#34;%d %t %s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;Fscanf: %v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其余几个和print的差不多，注意传入指针</p>
</li>
</ol>
<h4 id="类型">类型</h4>
<ol>
<li>formatter</li>
</ol>
<p>自定义格式化输出，就是根据%后面的符号来输出对应的(少见)</p>
<ol start="2">
<li>GoStringer</li>
</ol>
<p><code>GoString() string</code> 自定义如何字符串化一个struct (少见)</p>
<ol start="3">
<li>String</li>
</ol>
<p><code>String() string</code> 自定义如何字符串化一个struct (常见) 类似java的toString</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>zero-copy</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/16/category/zero-copy/</link>
      <pubDate>Wed, 16 Aug 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/16/category/zero-copy/</guid>
      <description>linux i/o &amp;amp;&amp;amp; zero-copy reference: Linux I/O 原理和 Zero-copy 技术全面揭秘 深入剖析Linux IO原理和几种零拷贝机制的实现</description>
      <content:encoded><![CDATA[<h2 id="linux-io--zero-copy">linux i/o &amp;&amp; zero-copy</h2>
<h2 id="reference">reference:</h2>
<p><a href="https://zhuanlan.zhihu.com/p/308054212">Linux I/O 原理和 Zero-copy 技术全面揭秘</a>
<a href="https://zhuanlan.zhihu.com/p/83398714#:~:text=%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88Zero-copy%EF%BC%89,%E5%9C%A8%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E8%B4%9F%E8%BD%BD%E3%80%82">深入剖析Linux IO原理和几种零拷贝机制的实现</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-detail</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/13/category/golang-detail/</link>
      <pubDate>Sun, 13 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/13/category/golang-detail/</guid>
      <description>空结构体 type EST stuct{ } func main(){ var b EST var c struct{}; fmt.Printf(&amp;#34;b address %P size %d\n&amp;#34;,&amp;amp;b,unsafe.size(b)) fmt.Printf(&amp;#34;c address %P size %d\n&amp;#34;,&amp;amp;c,unsafe.size(c)) //两者地址相同，空间占用都是0 } 自定义的和struct{}是等价 用法set可以用值为空</description>
      <content:encoded><![CDATA[<h3 id="空结构体">空结构体</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">EST</span> <span class="nx">stuct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">b</span> <span class="nx">EST</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">c</span> <span class="kd">struct</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;b address %P size %d\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;c address %P size %d\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//两者地址相同，空间占用都是0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>自定义的和struct{}是等价</li>
<li>用法set可以用值为空结构体的map来实现</li>
<li>可以用值为空结构体的channel</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>leetcode_record1</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/13/category/leetcode_record1/</link>
      <pubDate>Sun, 13 Aug 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/13/category/leetcode_record1/</guid>
      <description>剑指offer 剑指 Offer 12. 矩阵中的路径 一眼看出是回溯，其实还是挺简单的，但是要主要一开始遍历来找到起点。 剪绳子II 不能用动态规划，只能贪心，但是</description>
      <content:encoded><![CDATA[<h2 id="剑指offer">剑指offer</h2>
<h3 id="剑指-offer-12-矩阵中的路径httpsleetcodecnproblemsju-zhen-zhong-de-lu-jing-lcofdescription"><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/description/">剑指 Offer 12. 矩阵中的路径</a></h3>
<p>一眼看出是回溯，其实还是挺简单的，但是要主要一开始遍历来找到起点。</p>
<h3 id="剪绳子iihttpsleetcodecnproblemsjian-sheng-zi-ii-lcofdescription"><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/description/">剪绳子II</a></h3>
<p>不能用动态规划，只能贪心，但是贪心的话要用到数学知识，比如说3越多越好，因为3<em>3&gt;2</em>2<em>2，所以尽量分成3，但是要注意3</em>2&gt;2<em>2，所以如果最后剩下4的话，要分成2</em>2，而不能分成3*1</p>
<p>我之前动态规划是看4以及以上的都是乘积比自身大，所以只考虑将绳子剪掉二和三的情况(剪掉一显然小)所以贪心可以从中得到启发就是分成3越多越好，但是要注意3<em>1&lt;2</em>2，所以如果最后剩下4的话，要分成2<em>2，而不能分成3</em>1.</p>
<h3 id="剑指-offer-16-数值的整数次方httpsleetcodecnproblemsshu-zhi-de-zheng-shu-ci-fang-lcofdescription"><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/">剑指 Offer 16. 数值的整数次方</a></h3>
<p>快速指数幂</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">myPow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//避免-2147483648(2的-31次方)溢出，负数还是等于自己
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">long</span> <span class="kt">long</span> <span class="n">z</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//处理负指数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">z</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//每次缩小范围是通过指数的log来下降，所以时间复杂度是logn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">double</span> <span class="n">res</span> <span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">z</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">((</span><span class="n">z</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="o">*=</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="正则表达式匹配httpsleetcodecnproblemszheng-ze-biao-da-shi-pi-pei-lcofdescription"><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/">正则表达式匹配</a></h3>
<p>我对这题的评价是: 生不出人，我很抱歉</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">isMatch</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="剑指-offer-27-二叉树的镜像httpsleetcodecnproblemser-cha-shu-de-jing-xiang-lcofdescription"><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/">剑指 Offer 27. 二叉树的镜像</a></h3>
<h3 id="剑指-offer-28-对称的二叉树httpsleetcodecnproblemsdui-cheng-de-er-cha-shu-lcof"><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3>
<p>最近重新做了两道对称二叉树或者说镜像二叉树的题目，对对称二叉树的理解更深了。先来看如何获取镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Definition for a binary tree node.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * struct TreeNode {
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     int val;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     TreeNode *left;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     TreeNode *right;
</span></span></span><span class="line"><span class="cl"><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span class="line"><span class="cl"><span class="cm"> * };
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">mirrorTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">deque</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">layerSize</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">layerSize</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">layerSize</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>这里我使用了中序遍历，把一棵二叉树的轴对称这个操作看成层序遍历下的左右节点交换，这样问题范围就缩小成左右子树的镜像，然后一直。。。就行</p>
<h3 id="剑指-offer-37-序列化二叉树httpsleetcodecnproblemsxu-lie-hua-er-cha-shu-lcofdescription"><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/">剑指 Offer 37. 序列化二叉树</a></h3>
<p>序列化二叉树，我这里用的是层序遍历，要注意的是，如果是空节点，也要加入到序列化字符串中，这样才能保证反序列化的时候，空节点也能被还原出来。</p>
<h3 id="剑指-offer-39-数组中出现次数超过一半的数字httpsleetcodecnproblemsshu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcofdescription"><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3>
<p>虽然是一道简单题，可以用hash表解决，但是有个最好的方法还是可以记一记，就是众数的性质，众数的个数大于一半，所以如果我们把众数记为1，其他数记为-1，那么最后的和一定大于0，这样就可以用一个变量来记录当前和，如果和为0，那么就把当前数记为众数，最后返回的时候，还要判断一下这个数是不是众数，因为有可能没有众数，比如[1,2,3,4,5,6,7,8,9]，这样的数组就没有众数。</p>
<p>两个数比较</p>
<ol>
<li>都是众数，那么num++；</li>
<li>一个众数一个其他，num&ndash;</li>
<li>两个都不是众数那&ndash;(因为去掉两个非众数，众数还是在剩下的数组里面是众数)</li>
</ol>
<p>代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">majorityElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">++</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">candidate</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="1444-切披萨的方案数httpsleetcodecnproblemsnumber-of-ways-of-cutting-a-pizzadescription"><a href="https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/description/">1444. 切披萨的方案数</a></h3>
<p>属于是顶级的逆天题。</p>
<ol>
<li>前缀和减少重复计算，这个我见得比较少，但是实际上应该是比较常见的，所以要记住。这道题是二维前缀和，也就是说，我们可以用一个二维数组来记录到当前位置的所有苹果的数量，这样我们就可以在O(1)的时间内计算出任意一个矩形区域的苹果数量。</li>
<li>dp，其实dp这个思路不难想到，难的是状态定义和状态方程的定义。</li>
</ol>
<p>直接看代码吧</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ways</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">pizza</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">apples</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 预处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">apples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">apples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pizza</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ki</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ki</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="n">ki</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 水平方向切
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i2</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">apples</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">dp</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">ki</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i2</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 垂直方向切
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j2</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j2</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">apples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j2</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">dp</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">ki</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j2</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 作者：力扣官方题解
</span></span></span><span class="line"><span class="cl"><span class="c1">// 链接：https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/solutions/2387392/qie-pi-sa-de-fang-an-shu-by-leetcode-sol-7ik7/
</span></span></span><span class="line"><span class="cl"><span class="c1">// 来源：力扣（LeetCode）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span></code></pre></div><p>下面这个是优化的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ways</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pizza</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// 二维后缀和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pizza</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">col_s</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// colS[j] 表示 f 第 j 列的后缀和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">row_s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// f[i] 的后缀和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 左边界没有苹果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="c1">// 上边界没有苹果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span> <span class="c1">// 左边界上边界都有苹果，那么无论怎么切都有苹果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_s</span> <span class="o">+</span> <span class="n">col_s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">row_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_s</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">col_s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">col_s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 作者：灵茶山艾府
</span></span></span><span class="line"><span class="cl"><span class="c1">// 链接：https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/solutions/1/ji-bai-100cong-di-gui-dao-di-tui-dao-you-dxz5/
</span></span></span><span class="line"><span class="cl"><span class="c1">// 来源：力扣（LeetCode）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span></code></pre></div><h3 id="剑指-offer-41-数据流中的中位数httpsleetcodecnproblemsshu-ju-liu-zhong-de-zhong-wei-shu-lcofdescription"><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/description/">剑指 Offer 41. 数据流中的中位数</a></h3>
<p>这题主要是要想到用两个堆来实现，然后每次添加的情况要考虑清除，总共有三个区间。一步步来就不会忘</p>
<h3 id="剑指-offer-43-1n-整数中-1-出现的次数httpsleetcodecnproblems1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcofdescription"><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/description/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h3>
<p>这题思路对了，而且时间上击败100%</p>
<p>一开始老是出错有几个原因：</p>
<ol>
<li>在递归的时候处理首位情况没有考虑清楚，也就是首位大于一，等于1，小于1(等于0)的情况没有想清楚。</li>
<li>递归结束条件也没有想清楚</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">countDigitOne</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">recursive</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">recursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="p">,</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">first</span>  <span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">first</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// cout&lt;&lt;first&lt;&lt;rest&lt;&lt;endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">first</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="o">*</span><span class="n">recursive</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="n">recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">rest</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="o">*</span><span class="n">recursive</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="n">recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="剑指-offer-44-数字序列中某一位的数字httpsleetcodecnproblemsshu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcofdescription"><a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/description/">剑指 Offer 44. 数字序列中某一位的数字</a></h3>
<p>这个其实也是数位找规律的问题，要问某一位的数是什么，就得知道这位在哪个数上，并且在这个数的哪一位。
首先就是按照
0-9 10-99来给位数分组，然后就能知道这个位是在该组的哪个数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">findNthDigit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">max_</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">min_</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="p">(</span><span class="n">max_</span><span class="o">-</span><span class="n">min_</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nn</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span><span class="o">+=</span><span class="p">(</span><span class="n">max_</span><span class="o">-</span><span class="n">min_</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">min_</span><span class="o">=</span><span class="n">max_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">max_</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">newPos</span> <span class="o">=</span> <span class="n">nn</span><span class="o">-</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">first</span> <span class="o">=</span> <span class="n">newPos</span><span class="o">/</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">newPos</span><span class="o">%</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">min_</span><span class="o">+</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// cout&lt;&lt;newPos&lt;&lt;&#34; &#34;&lt;&lt;first&lt;&lt;&#34; &#34;&lt;&lt;rest&lt;&lt;&#34; &#34;&lt;&lt;num&lt;&lt;&#34; &#34;&lt;&lt;i;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">long</span> <span class="kt">long</span>  <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">rest</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>  <span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">shift</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="剑指-offer-46-把数字翻译成字符串httpsleetcodecnproblemsba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcofdescription"><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/">剑指 Offer 46. 把数字翻译成字符串</a></h3>
<p>其实也是数位计算，有几个需要改进的地方</p>
<ol>
<li>计算掩码位的时候一开始写成</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>但是应该是&gt;=</p>
<ol start="2">
<li>
<p>又是考虑每次的结束和分支</p>
<ul>
<li>结束，i&lt;=1的时候退出返回1.</li>
<li>分支：
<ul>
<li>首位0:意味着第一位和前两位的编码是一样的所以直接返回后面的编码方案数</li>
<li>首位非零: 就是比较直观的两种情况:单个数字编码和可能两位数的编码</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="剑指-offer-49-丑数httpsleetcodecnproblemschou-shu-lcofdescription"><a href="https://leetcode.cn/problems/chou-shu-lcof/description/">剑指 Offer 49. 丑数</a></h3>
<p>其实很容易看出来是DP，但是状态转移不好想，主要是顺序很难保证。</p>
<p>基于这样一种思想，后面的丑数总是从前面的生成-&gt;前面的数总是会乘2，3，5来得到后面的数，所以用三个指针来从左向右跟踪这三个序列中最小的每次取最小的就可以保证顺序了。</p>
<h3 id="剑指-offer-53---i-在排序数组中查找数字-ihttpsleetcodecnproblemszai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcofdescription"><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3>
<p>其实就是二分查找，但是这个是二分查找的变体，就是会有重复的数字，所以需要找是target的第一个和最后一个</p>
<p>可以总结下来的写法:
可以发现，如果想找第一个那就是在相等的时候j=middle，注意这个时候的middle是(i+j)/2也就是说会偏向小的，那把right赋小值也是可以跳出i&lt;j的循环的。</p>
<p>那么最后一个也相似，就是把左边界赋middle，同时middle的算法是(i+j+1)/2。</p>
<p>需要注意的是，当找不到的时候得到的两个结果有可能越界找第一个值的时候j=-1,找最后一个值的时候可能i=num.size()。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//binary search 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//  cout&lt;&lt;i&lt;&lt;&#34; &#34;&lt;&lt;j&lt;&lt;endl;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span><span class="o">=</span><span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span><span class="o">&lt;</span><span class="n">target</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">i</span><span class="o">=</span><span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">j</span><span class="o">=</span><span class="n">middle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">target</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">//j leftmost target
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">ii</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="n">ii</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">ii</span><span class="o">&lt;</span><span class="n">jj</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">jj</span><span class="o">=</span><span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span><span class="o">&gt;</span><span class="n">target</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ii</span><span class="o">=</span><span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ii</span><span class="o">=</span><span class="n">middle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ii</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>rocksdb源码分析（1）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb1/</link>
      <pubDate>Sat, 05 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb1/</guid>
      <description>rocksdb源码解读(一) 本系列开始对rocksdb源码进行解读，主要是为了更好的理解rocksdb的设计思想，以及对rocksdb的使用</description>
      <content:encoded><![CDATA[<h2 id="rocksdb源码解读一">rocksdb源码解读(一)</h2>
<p>本系列开始对rocksdb源码进行解读，主要是为了更好的理解rocksdb的设计思想，以及对rocksdb的使用有更深入的理解。
从用法开始一步步深入。</p>
<h2 id="rocksdb的基本使用">rocksdb的基本使用</h2>
<h3 id="option设置">option设置</h3>
<p>在打开一个rocksdb的时候需要提供设置选项,有<a href="https://github.com/facebook/rocksdb/wiki/Option-String-and-Option-Map">三种方法</a></p>
<ol>
<li>通过Options类</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="n">rocksdb</span><span class="o">::</span><span class="n">DB</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rocksdb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">options</span><span class="p">.</span><span class="n">create_if_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rocksdb</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">rocksdb</span><span class="o">::</span><span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&#34;/tmp/testdb&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//也可以使用leveldb相关接口的options并转变成rocksdb的options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&#34;rocksdb/utilities/leveldb_options.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">  <span class="n">rocksdb</span><span class="o">::</span><span class="n">LevelDBOptions</span> <span class="n">leveldb_options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">leveldb_options</span><span class="p">.</span><span class="n">option1</span> <span class="o">=</span> <span class="n">value1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">leveldb_options</span><span class="p">.</span><span class="n">option2</span> <span class="o">=</span> <span class="n">value2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">rocksdb</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span> <span class="o">=</span> <span class="n">rocksdb</span><span class="o">::</span><span class="n">ConvertOptions</span><span class="p">(</span><span class="n">leveldb_options</span><span class="p">);</span>
</span></span></code></pre></div><p><a href="https://github.com/facebook/rocksdb/wiki/RocksDB-Options-File">也可以通过options 文件</a></p>
<blockquote>
<p>In RocksDB 4.3, we add a set of features that makes managing RocksDB options easier.</p>
</blockquote>
<blockquote>
<ol>
<li>Each RocksDB database will now automatically persist its current set of options into a file on every successful call of DB::Open(), SetOptions(), and CreateColumnFamily() / DropColumnFamily().</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>LoadLatestOptions() / LoadOptionsFromFile(): A function that constructs RocksDB options object from an options file.</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>CheckOptionsCompatibility: A function that performs compatibility check on two sets of RocksDB options.</li>
</ol>
</blockquote>
<blockquote>
<p>With the above options file support, developers no longer need to maintain the full set of options of a previously-created RocksDB instance. In addition, when changing options is needed, CheckOptionsCompatibility() can further make sure the resulting set of Options can successfully open the same RocksDB database without corrupting the underlying data.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="c1">// 一般来说的步骤就是 先load上次的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">LoadLatestOptions</span><span class="p">(</span><span class="n">cfg_opts</span><span class="p">,</span> <span class="n">path_to_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loaded_db_opt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loaded_cf_descs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//然后检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">CheckOptionsCompatibility</span><span class="p">(</span><span class="n">cfg_opts</span><span class="p">,</span> <span class="n">kDBPath</span><span class="p">,</span> <span class="n">db_options</span><span class="p">,</span> <span class="n">loaded_cf_descs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//接着打开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">s</span> <span class="o">=</span> <span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">loaded_db_opt</span><span class="p">,</span> <span class="n">kDBPath</span><span class="p">,</span> <span class="n">loaded_cf_descs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handles</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 要注意一些 新版本-&gt;旧版本和 一些用户定义的函数和指针类型的option需要特殊处理
</span></span></span></code></pre></div><p><a href="https://github.com/facebook/rocksdb/blob/main/examples/rocksdb_option_file_example.ini">这是一个官方的示例ini配置文件</a></p>
<ol start="2">
<li>Option String</li>
<li>Option map</li>
</ol>
<h3 id="status">Status</h3>
<p>两种方法</p>
<ol>
<li></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"> <span class="k">delete</span> <span class="n">db</span><span class="p">;</span> <span class="c1">//会丢失错误信息
</span></span></span></code></pre></div><ol start="2">
<li></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="p">...</span> <span class="k">do</span> <span class="n">something</span> <span class="n">with</span> <span class="n">db</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span> <span class="n">log</span> <span class="n">status</span> <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">db</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="simple-rw-example">simple r/w example</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">DB</span><span class="o">*</span> <span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Optimize RocksDB. This is the easiest way to get RocksDB to perform well
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">options</span><span class="p">.</span><span class="n">IncreaseParallelism</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">OptimizeLevelStyleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// create the DB if it&#39;s not already present
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">options</span><span class="p">.</span><span class="n">create_if_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// open DB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">kDBPath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Put key-value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="s">&#34;key1&#34;</span><span class="p">,</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// get value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="s">&#34;key1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// atomically apply a set of updates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">WriteBatch</span> <span class="n">batch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">batch</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="s">&#34;key1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">batch</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="s">&#34;key2&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="s">&#34;key1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">IsNotFound</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="s">&#34;key2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">PinnableSlice</span> <span class="n">pinnable_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="s">&#34;key2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinnable_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">pinnable_val</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">string_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// If it cannot pin the value, it copies the value to its internal buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// The intenral buffer could be set during construction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">PinnableSlice</span> <span class="nf">pinnable_val</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="s">&#34;key2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinnable_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span><span class="n">pinnable_val</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// If the value is not pinned, the internal buffer must have the value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">pinnable_val</span><span class="p">.</span><span class="n">IsPinned</span><span class="p">()</span> <span class="o">||</span> <span class="n">string_val</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">PinnableSlice</span> <span class="n">pinnable_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="s">&#34;key1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinnable_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">IsNotFound</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Reset PinnableSlice after each use and before each reuse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pinnable_val</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">db</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">ReadOptions</span><span class="p">(),</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="s">&#34;key2&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinnable_val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">pinnable_val</span> <span class="o">==</span> <span class="s">&#34;value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pinnable_val</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The Slice pointed by pinnable_val is not valid after this point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">db</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><h4 id="writeoption">WriteOption</h4>
<p>设置写入选项</p>
<ul>
<li>sync(是否刷盘)</li>
<li>disableWAL</li>
<li>ignore_missing_column_families(没有Column_family的时候忽略)</li>
<li>no_slowdown(非阻塞写，否则立即返回错误)</li>
<li>low_pri(等待优先级高的写入或者compaction完成)</li>
<li>memtable_insert_hint_per_batch（记住该batch的最后写入位置提高效率）</li>
<li>rate_limiter_priority（设置优先级）</li>
<li>protection_bytes_per_key([0|8]设置保护字节，用于检测写入的错误)</li>
</ul>
<p>readoption有点多遇到再看</p>
<h4 id="put实现">PUT实现</h4>
<p>先贴一张dalao的图
<img src="https://s2.loli.net/2023/08/06/Z2qXMzLYCHbgrfR.png" alt="image.png"></p>
<blockquote>
<p>rocksdb支持多线程并发写入，在多个写线程中选出一个领导者，然后领导者负责为这一批线程进行统一的WAL写入，然后根据用户设置的不同（rocksdb允许在打开数据库时通过选项进行设置）。</p>
<ul>
<li>如果使用高并发度的设置，leader线程就会唤醒所有在等待的follower线程，然后所有线程一起并发写memtable，等到所有线程全部写入完成，leader线程就会唤醒组织下一批写入的正在等待的新leader线程，然后退出</li>
<li>如果使用低并发度的设置，leader线程就会为整个批写入组的线程完成串行的memtable写入，然后按照与上述逻辑相同的方式退出。</li>
</ul>
</blockquote>
<p>入口:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Set the database entry for &#34;key&#34; to &#34;value&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If &#34;key&#34; already exists, it will be overwritten.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns OK on success, and a non-OK status on error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Note: consider setting options.sync = true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="n">Status</span> <span class="nf">Put</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">ColumnFamilyHandle</span><span class="o">*</span> <span class="n">column_family</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="n">Status</span> <span class="nf">Put</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">ColumnFamilyHandle</span><span class="o">*</span> <span class="n">column_family</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="n">Status</span> <span class="nf">Put</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Put</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">virtual</span> <span class="n">Status</span> <span class="nf">Put</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">ts</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Put</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">DefaultColumnFamily</span><span class="p">(),</span> <span class="n">key</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//上面两个纯虚函数才是真正实现的地方，下面只是设置默认的column_family。而DBImpl也只是检查一下并调用父类的put函数
</span></span></span></code></pre></div><p>下面来看Put的实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Default implementations of convenience methods that subclasses of DB
</span></span></span><span class="line"><span class="cl"><span class="c1">// can call if they wish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Status</span> <span class="n">DB</span><span class="o">::</span><span class="n">Put</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">opt</span><span class="p">,</span> <span class="n">ColumnFamilyHandle</span><span class="o">*</span> <span class="n">column_family</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Pre-allocate size of write batch conservatively.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 8 bytes are taken by header, 4 bytes for count, 1 byte for type,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and we allocate 11 extra bytes for key length, as well as value length.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">WriteBatch</span> <span class="nf">batch</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* max_bytes */</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">opt</span><span class="p">.</span><span class="n">protection_bytes_per_key</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* default_cf_ts_sz */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="n">column_family</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">Write</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Write进入WriteImpl
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="k">const</span> <span class="n">WriteOptions</span><span class="o">&amp;</span> <span class="n">write_options</span><span class="p">,</span> <span class="n">WriteBatch</span><span class="o">*</span> <span class="n">my_batch</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">write_options</span><span class="p">.</span><span class="n">protection_bytes_per_key</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">WriteBatchInternal</span><span class="o">::</span><span class="n">UpdateProtectionInfo</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">my_batch</span><span class="p">,</span> <span class="n">write_options</span><span class="p">.</span><span class="n">protection_bytes_per_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">WriteImpl</span><span class="p">(</span><span class="n">write_options</span><span class="p">,</span> <span class="n">my_batch</span><span class="p">,</span> <span class="cm">/*callback=*/</span><span class="k">nullptr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="cm">/*log_used=*/</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先会生成一个Writer，包含了此次写入的信息，然后WriteThread::JoinBatchGroup（这里的group是一串链表，每次写入都只会有一个group被写入）。</p>
<p><img src="https://s2.loli.net/2023/08/06/FL28VCWfDxNn73E.png" alt="image.png">
两个指针实现双向链表，而且在DBImpl中唯一的WriteThread中是用<code>std::atomic&lt;Writer*&gt; newest_writer_;</code>来保存的，这样可以实现尾节点插入的原子性，可以多线程并发插入尾节点。(注意在插入节点的时候只有后指向前的单向链表，在leader写的时候才会从后往前建立另一个方向的连接)</p>
<p>而且WriteThread在初始化的时候，newest_writer_是初始化为null的所以第一个进入的一定是leader。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">WriteThread</span><span class="o">::</span><span class="n">JoinBatchGroup</span><span class="p">(</span><span class="n">Writer</span><span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">TEST_SYNC_POINT_CALLBACK</span><span class="p">(</span><span class="s">&#34;WriteThread::JoinBatchGroup:Start&#34;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">batch</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//linkOne 函数主要是把链表尾newest_writer变成此次的writer（也就是插入尾）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//，如果链表没有元素就直接返回(也就是这是第一个Writer也就是leader)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">linked_as_leader</span> <span class="o">=</span> <span class="n">LinkOne</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newest_writer_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">linked_as_leader</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SetState</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">STATE_GROUP_LEADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TEST_SYNC_POINT_CALLBACK</span><span class="p">(</span><span class="s">&#34;WriteThread::JoinBatchGroup:Wait&#34;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">TEST_SYNC_POINT_CALLBACK</span><span class="p">(</span><span class="s">&#34;WriteThread::JoinBatchGroup:Wait2&#34;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">linked_as_leader</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Wait util:
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 1) An existing leader pick us as the new leader when it finishes
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 2) An existing leader pick us as its follewer and
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 2.1) finishes the memtable writes on our behalf
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 2.2) Or tell us to finish the memtable writes in pralallel
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 3) (pipelined write) An existing leader pick us as its follower and
</span></span></span><span class="line"><span class="cl"><span class="cm">     *    finish book-keeping and WAL write for us, enqueue us as pending
</span></span></span><span class="line"><span class="cl"><span class="cm">     *    memtable writer, and
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 3.1) we become memtable writer group leader, or
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 3.2) an existing memtable writer group leader tell us to finish memtable
</span></span></span><span class="line"><span class="cl"><span class="cm">     *      writes in parallel.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">TEST_SYNC_POINT_CALLBACK</span><span class="p">(</span><span class="s">&#34;WriteThread::JoinBatchGroup:BeganWaiting&#34;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">AwaitState</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">STATE_GROUP_LEADER</span> <span class="o">|</span> <span class="n">STATE_MEMTABLE_WRITER_LEADER</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">                   <span class="n">STATE_PARALLEL_MEMTABLE_WRITER</span> <span class="o">|</span> <span class="n">STATE_COMPLETED</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="o">&amp;</span><span class="n">jbg_ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">TEST_SYNC_POINT_CALLBACK</span><span class="p">(</span><span class="s">&#34;WriteThread::JoinBatchGroup:DoneWaiting&#34;</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>根据该写入线程是否是leader分为几种情况</p>
<ol>
<li>
<p>是leader</p>
<ol>
<li>JoinBatchGroup返回STATE_GROUP_LEADER,而且是无阻塞的。</li>
<li>先进行PreprocessWrite(),这个函数里面是进行一些预处理
<ol>
<li>比如WAL的大小超过了max_total_wal_size就把对应wal里面的数据刷盘(刷盘过程中也会切换memtable)并且切换新的wal</li>
<li>看buffer_size够不够，(其实就是看write_buffer_manager_-&gt;ShouldFlush())</li>
<li>等等</li>
</ol>
</li>
<li>EnterAsBatchGroupLeader，这个函数主要先建立从前往后的连接(CreateMissingNewerLinks)然后是从leader开始从后根据option的相同建立write_group。</li>
<li>获取到此次写入的write_group后先进行一些数据统计。</li>
<li>然后就是真正的写入了，先是<a href="https://zhuanlan.zhihu.com/p/618736762">写入WAL</a>
<ol>
<li>先把write_group的数据整合到一起然后写入WAL，接着根据option判断是否刷盘。</li>
</ol>
</li>
<li>然后是<a href="https://zhuanlan.zhihu.com/p/618742569">memtable</a>
<ol>
<li>根据option的是否并行来决定是自己把所有数据写入(!parallel)还是通知其他线程让他们自己写入（parallel）</li>
</ol>
</li>
<li>接着是判断是否刷盘</li>
<li>然后优雅退出并且做一些收尾工作，主要是调用ExitAsBatchGroupLeader 通知其他线程成为leader</li>
</ol>
</li>
<li>
<p>不是leader</p>
<ol>
<li>
<p>加入batch group 并且leader perform the write 返回 STATE_DONE</p>
</li>
<li>
<p>加入batch group 且由自己的线程负责写入 返回STATE_PARALLEL_MEMTABLE_WRITER</p>
</li>
</ol>
</li>
<li></li>
</ol>
<p>参考:</p>
<p><a href="https://kernelmaker.github.io/Leveldb_Put">某位阿里云dalao的博客</a></p>
<p><a href="https://www.jianshu.com/p/daa18eebf6e1">湾湾大哥的解析，图片的来源(侵删)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/441890425">RocksDB-04-写流程图解</a>
<a href="https://zhuanlan.zhihu.com/p/369384686">RocksDB写流程梳理</a></p>
<h4 id="pinnableslice">PinnableSlice</h4>
<p>先说Slice，它基本就是对c字符串的封装，包含了一个指针和一个长度，可以通过data()和size()获取，也可以通过[]访问，但是没有做越界检查，所以要注意。</p>
<p>然后PinnableSlice继承自Slice，它的作用是为了减少内存拷贝，它有两种模式，一种是pin模式，一种是no pin模式，pin模式下，它会直接返回指向rocksdb内部的指针，这样就不用拷贝了，但是要注意，这个指针只在当前的读操作有效，下一次读操作之前必须调用reset()，否则会出现错误，no pin模式下，它会拷贝一份数据到自己的内部缓冲区，这样就不用担心下一次读操作会出错了，但是会多一次内存拷贝。</p>
<p>参考：</p>
<p><a href="https://kernelmaker.github.io/Rocksdb_pinnableslice">某位阿里云dalao的博客</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>rocksdb源码分析（2）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb2/</link>
      <pubDate>Sat, 05 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb2/</guid>
      <description>columnfamily memtable WAL 格式 创建: rocksdb::DB::Open(options, &amp;ldquo;./db/&amp;rdquo;, &amp;amp;db); db-&amp;gt;Flush(rocksdb::FlushOptions(), handles[1]); 在Write的时候检查WAl大小超过了max_total_wal_size的时候，会创建新的wal。 memtable 写入 slice.h Slice 主要</description>
      <content:encoded><![CDATA[<p><a href="http://mysql.taobao.org/monthly/2018/06/09/#:~:text=Column%20Family%E4%B8%BB%E8%A6%81%E6%98%AF%E6%8F%90%E4%BE%9B,%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84Column%20Family.">columnfamily</a></p>
<h2 id="memtable">memtable</h2>
<h2 id="wal">WAL</h2>
<h3 id="格式">格式</h3>
<h3 id="创建">创建:</h3>
<ol>
<li>rocksdb::DB::Open(options, &ldquo;./db/&rdquo;, &amp;db);</li>
<li>db-&gt;Flush(rocksdb::FlushOptions(), handles[1]);</li>
<li>在Write的时候检查WAl大小超过了max_total_wal_size的时候，会创建新的wal。</li>
</ol>
<h2 id="memtable-1">memtable</h2>
<h3 id="写入">写入</h3>
<h2 id="sliceh">slice.h</h2>
<h3 id="slice">Slice</h3>
<ul>
<li>主要是对字符串的封装，包括了字符串的长度和指针。</li>
</ul>
<h3 id="pinnableslice">pinnableslice</h3>
<ul>
<li>
<p>主要是对Slice的封装，继承于slice和cleanable，主要是避免memcpy，可以注册clean函数，当slice不再使用的时候，会调用clean函数。</p>
</li>
<li>
<p>读时优化
<img src="https://pic3.zhimg.com/80/v2-48739e53602175c42694c5d756e4b112_720w.webp" alt=""></p>
</li>
</ul>
<p>记得每次使用过后需要reset，否则会出现内存泄漏。</p>
<h2 id="customizableh">customizable.h</h2>
<pre><code>看不下去
</code></pre>
<h2 id="configurableh">Configurable.h</h2>
<pre><code>Configurable类
也看不下去
</code></pre>
<p>参考:</p>
<p><a href="https://rocksdb.org/blog/2017/08/24/pinnableslice.html">official blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30807728">这个讲的比较好</a></p>
<h3 id="sliceparts">SliceParts</h3>
<ul>
<li>表示slice数组。</li>
</ul>
<p>参考:</p>
<p><a href="https://zhuanlan.zhihu.com/p/343323703">Rocksdb WAL实现及源码详解</a></p>
<p>参考:</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>rocksdb源码分析（3）</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb3/</link>
      <pubDate>Sat, 05 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/05/category/rocksdb3/</guid>
      <description>column family 介绍 是用来做逻辑隔离的，不同的column family可以有不同的配置，比如不同的compaction策略，不同的压缩策略等等。而且不同</description>
      <content:encoded><![CDATA[<h2 id="column-family">column family</h2>
<h3 id="介绍">介绍</h3>
<p>是用来做逻辑隔离的，不同的column family可以有不同的配置，比如不同的compaction策略，不同的压缩策略等等。而且不同的column family 对应不同的memtable，但是共享同一个wal文件</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-interview-gmp</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/08/01/category/golang-interview-gmp/</link>
      <pubDate>Tue, 01 Aug 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/08/01/category/golang-interview-gmp/</guid>
      <description>golang 调度器的由来 如果把并发交给os来完成，首先是CPU的调度消耗，其次进程占用4GB(虚拟内存)，线程占用4MB这些都是比较高的内存占用。 协程</description>
      <content:encoded><![CDATA[<h2 id="golang-调度器的由来">golang 调度器的由来</h2>
<p>如果把并发交给os来完成，首先是CPU的调度消耗，其次进程占用4GB(虚拟内存)，线程占用4MB这些都是比较高的内存占用。</p>
<p>协程(其实也是用户态线程和内核态线程)</p>
<ul>
<li>N:1 N个协程1个进程，会有阻塞问题</li>
<li>1:1 实际上还是CPU负责切换，协程切换的时候需要保存上下文，这个过程也是比较耗时的</li>
<li>M:N M个协程N个线程，协程切换的时候不需要保存上下文，只需要保存协程的栈信息，这个过程是比较快的</li>
</ul>
<h2 id="gmp">GMP</h2>
<ol>
<li>简介</li>
</ol>
<p>G: goroutine 协程</p>
<p>M: thread 线程</p>
<p>P: processor 处理器</p>
<p><img src="https://s2.loli.net/2023/08/01/scxUTwEMuAfpaQZ.jpg" alt="16-GMP-调度.png"></p>
<ol start="2">
<li>
<p>设计策略</p>
</li>
<li>
<p>go func()经历了什么</p>
</li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>