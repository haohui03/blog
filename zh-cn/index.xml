<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Yehh</title>
    <link>https://blog.yehaohui.com/zh-cn/</link>
    <description>Recent content on Yehh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Dec 2023 13:01:23 +0800</lastBuildDate>
    
    <atom:link href="https://blog.yehaohui.com/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://blog.yehaohui.com/zh-cn/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/about/</guid>
      <description>Hi! 我是叶浩辉 华南理工大学 软件学院三年级本科生, 兴趣集中在Computer Vision 和 Trustworthy Machine Learning。 Key/Value Engine(RocksDB), distributed system, cloud native, golang, linux, k8s, docker, etc. 希望不断学习，不断进</description>
      <content:encoded><![CDATA[<h2 id="hi-我是叶浩辉httpsblogyehaohuicom">Hi! 我是<a href="https://blog.yehaohui.com/">叶浩辉</a></h2>
<p><a href="https://www.scut.edu.cn/new/">华南理工大学</a> 软件学院三年级本科生, <del>兴趣集中在Computer Vision 和 Trustworthy Machine Learning。</del> Key/Value Engine(RocksDB), distributed system, cloud native, golang, linux, k8s, docker, etc.</p>
<p>希望不断学习，不断进步，通过深度阅读提升思考能力。</p>
<h2 id="阅读">阅读</h2>
<h3 id="最近阅读">最近阅读：</h3>
<p><a href="https://github.com/Vonng/ddia">DDIA 设计数据密集型应用</a></p>
<p><a href="https://sfc33ed4d8ae30993.jimcontent.com/download/version/0/module/5761298011/name/%E6%9B%BC%E6%98%86%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%28%E4%B8%AD%E6%96%87%29%E7%AC%AC%E4%BA%94%E7%89%88%28%E5%AE%8F%E8%A7%82%E5%88%86%E5%86%8C%29.pdf">principles of economics mankiw 宏观经济学 曼昆</a></p>
<h3 id="纪录片">纪录片</h3>
<ol>
<li><a href="https://www.bilibili.com/video/BV1cE411x7o2/?spm_id_from=333.337.search-card.all.click">街头绝味</a></li>
<li><a href="https://www.bilibili.com/bangumi/play/ep333749?spm_id_from=333.788.recommend_more_video.2">吴文芳：40小时看世界</a></li>
</ol>
<h2 id="关于本站">关于本站</h2>
<blockquote>
<p>本站灵感来自<a href="https://www.pseudoyu.com/zh/">pseudoyou</a>,真诚、自省的文字和开源的精神是我建站的目标。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-gc-optimization</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/12/12/category/golang-gc-optimization/</link>
      <pubDate>Tue, 12 Dec 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/12/12/category/golang-gc-optimization/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>golang-map</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/23/category/golang-map/</link>
      <pubDate>Thu, 23 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/23/category/golang-map/</guid>
      <description>map map是一个很重要的数据结构，本篇文章记录学习golang中map源码的过程。 图多取自别人的博客，非原创请注意 基本的概念不在赘述了 以下分析</description>
      <content:encoded><![CDATA[<h1 id="map">map</h1>
<p>map是一个很重要的数据结构，本篇文章记录学习golang中map源码的过程。</p>
<p>图多取自别人的博客，非原创请注意</p>
<p>基本的概念不在赘述了</p>
<p>以下分析来自go 1.21.0</p>
<h2 id="使用">使用</h2>
<h3 id="创建">创建</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 指定 map 长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ageMp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ageMp 为 nil，不能向其添加元素，会直接panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ageMp</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span></code></pre></div><h2 id="变量和类型">变量和类型</h2>
<p><img src="https://s2.loli.net/2023/11/23/GcFBKTq2ZeuioI8.png" alt="image.png"></p>
<blockquote>
<p>map是以bucket来组织键值对的，一个bucket最多8个键值对。</p>
</blockquote>
<h3 id="变量常量">变量（常量）</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Maximum number of key/elem pairs a bucket can hold.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapBucketCountBits</span> <span class="c1">//3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapBucketCount</span> <span class="c1">//8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用loadFactorNum/loadFactorDen来代表负载因子，用两个整数就可以进行整数运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Maximum average load of a bucket that triggers growth is bucketCnt*13/16 (about 80% full)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Because of minimum alignment rules, bucketCnt is known to be at least 8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Represent as loadFactorNum/loadFactorDen, to allow integer math.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">loadFactorDen</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">loadFactorNum</span> <span class="p">=</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">*</span> <span class="mi">13</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="nx">loadFactorDen</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// key和value size都是128（加起来不超过uint8）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Maximum key or elem size to keep inline (instead of mallocing per element).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Must fit in a uint8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast versions cannot handle big elems - the cutoff size for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// fast versions in cmd/compile/internal/gc/walk.go must be at most this elem.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxKeySize</span>  <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapMaxKeyBytes</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxElemSize</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MapMaxElemBytes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//其实就是bmap结构体的对齐大小（8字节即使是amd64p32）,注意这里是编译期前的，不包括那些奇奇怪怪的后面加的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// data offset should be the size of the bmap struct, but needs to be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// aligned correctly. For amd64p32 this means 64-bit alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// even though pointers are 32 bit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataOffset</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="p">}{}.</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Possible tophash values. We reserve a few possibilities for special marks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Each bucket (including its overflow buckets, if any) will have either all or none of its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// entries in the evacuated* states (except during the evacuate() method, which only happens
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// during map writes and thus no one else can observe the map during that time).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">emptyRest</span>      <span class="p">=</span> <span class="mi">0</span> <span class="c1">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">emptyOne</span>       <span class="p">=</span> <span class="mi">1</span> <span class="c1">// this cell is empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedX</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedY</span>     <span class="p">=</span> <span class="mi">3</span> <span class="c1">// same as above, but evacuated to second half of larger table.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">evacuatedEmpty</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// cell is empty, bucket is evacuated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">minTopHash</span>     <span class="p">=</span> <span class="mi">5</span> <span class="c1">// minimum tophash for a normal filled cell.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">iterator</span>     <span class="p">=</span> <span class="mi">1</span> <span class="c1">// there may be an iterator using buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">oldIterator</span>  <span class="p">=</span> <span class="mi">2</span> <span class="c1">// there may be an iterator using oldbuckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hashWriting</span>  <span class="p">=</span> <span class="mi">4</span> <span class="c1">// a goroutine is writing to the map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sameSizeGrow</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// the current map growth is to a new map of the same size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// sentinel bucket ID for iterator checks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">noCheck</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><h3 id="类型">类型</h3>
<h4 id="hmap">hmap</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A header for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="nx">count</span>     <span class="kt">int</span> <span class="c1">// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// hash seed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// previous bucket array of half the size, non-nil only when growing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">    <span class="c1">// 指示扩容进度，小于此地址的 buckets 迁移完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nevacuate</span>  <span class="kt">uintptr</span>        <span class="c1">// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>mapextra</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// mapextra holds fields that are not present on all maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If both key and elem do not contain pointers and are inline, then we mark bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// type as containing no pointers. This avoids scanning such maps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// However, bmap.overflow is a pointer. In order to keep overflow buckets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// overflow and oldoverflow are only used if key and elem do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// overflow contains overflow buckets for hmap.buckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// oldoverflow contains overflow buckets for hmap.oldbuckets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The indirection allows to store a pointer to the slice in hiter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// nextOverflow holds a pointer to a free overflow bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="bmap">bmap</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A bucket for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// tophash generally contains the top byte of the hash value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// tophash[0] is a bucket evacuation state instead.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Followed by an overflow pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>实际上，bmap不止这么简单的东西。bmap会在编译期生成其他东西，相关的东西和cmd/compile/internal/reflectdata有关</p>
<p>相关函数：cmd/compile/internal/reflectdata/reflect.go/MapBucketType</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">topbits</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">keys</span>     <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">keytype</span>
</span></span><span class="line"><span class="cl">    <span class="nx">values</span>   <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">valuetype</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//曾经有padding，现在已经没有了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://s2.loli.net/2023/11/23/87xb5GEeCf1PF6W.png" alt="image.png">
值得注意的是，当键或值的大小超过128字节时，会使用指针来存储，而不是直接存储在bmap中。而且当key和elme都没有指针类型的时候overflow会变成uintptr类型并且由hmap来管理overflow（不会被GC认为有指针）不然就是unsafe.pointer。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://golang.design/go-questions/map/principal/">Go 程序员面试笔试宝典</a></li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#336-%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB">golang设计与实现</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>grpc-advanced</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/20/category/grpc-advanced/</link>
      <pubDate>Mon, 20 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/20/category/grpc-advanced/</guid>
      <description>grpc-tsl server side TLS 有关TLS的知识结合这个看体验更佳 mutual TLS 参考 grpc进阶</description>
      <content:encoded><![CDATA[<h2 id="grpc-tsl">grpc-tsl</h2>
<h3 id="server-side-tls">server side TLS</h3>
<p>有关TLS的知识结合<a href="https://www.cnblogs.com/sewain/p/14250884.html#ssltls">这个</a>看体验更佳</p>
<h3 id="mutual-tls">mutual TLS</h3>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://learnku.com/articles/73105">grpc进阶</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>go-zero goctl</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/go-zero-goctl/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/go-zero-goctl/</guid>
      <description>goctl </description>
      <content:encoded><![CDATA[<h2 id="goctl">goctl</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>grpc-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/grpc-intro/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/grpc-intro/</guid>
      <description>grpc 简单使用 这次这次实践的目录 . ├── client │ └── hello-client │ └── client.go ├── go.mod ├── go.sum ├── proto │ └── hello │ ├── hello_grpc.pb.go │ ├── hello.pb.go │ └── hello.proto └── server └── hello-server └</description>
      <content:encoded><![CDATA[<h1 id="grpc">grpc</h1>
<p><img src="https://s2.loli.net/2023/11/22/m3zX4BjgTlOneyY.png" alt="image.png"></p>
<h2 id="简单使用">简单使用</h2>
<p>这次这次实践的目录</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── client
</span></span><span class="line"><span class="cl">│   └── hello-client
</span></span><span class="line"><span class="cl">│       └── client.go
</span></span><span class="line"><span class="cl">├── go.mod
</span></span><span class="line"><span class="cl">├── go.sum
</span></span><span class="line"><span class="cl">├── proto
</span></span><span class="line"><span class="cl">│   └── hello
</span></span><span class="line"><span class="cl">│       ├── hello_grpc.pb.go
</span></span><span class="line"><span class="cl">│       ├── hello.pb.go
</span></span><span class="line"><span class="cl">│       └── hello.proto
</span></span><span class="line"><span class="cl">└── server
</span></span><span class="line"><span class="cl">    └── hello-server
</span></span><span class="line"><span class="cl">        └── server.go
</span></span></code></pre></div><p>proto</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义go生成后的包名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">option</span> <span class="n">go_package</span> <span class="o">=</span> <span class="s">&#34;./;hello&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kn">package</span> <span class="nn">proto</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义入参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">message</span> <span class="nc">Request</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">message</span> <span class="nc">Response</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c1">// 定义接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">service</span> <span class="n">UserService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Say</span><span class="p">(</span><span class="n">Request</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Response</span><span class="p">);</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h3 id="server">server</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HelloService</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 必须嵌入UnimplementedUserServiceServer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hello</span><span class="p">.</span><span class="nx">UnimplementedUserServiceServer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现SayHi方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">HelloService</span><span class="p">)</span> <span class="nf">Say</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="o">*</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">format</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="s">&#34;2006-01-02 15:04:05&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Response</span><span class="p">{</span><span class="nx">Result</span><span class="p">:</span> <span class="s">&#34;hi &#34;</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nf">GetName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;---&#34;</span> <span class="o">+</span> <span class="nx">format</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;8888&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建grpc服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 注册服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">hello</span><span class="p">.</span><span class="nf">RegisterUserServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">HelloService</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 监听端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;net.Listen err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>分析上面的代码：</p>
<p>服务端需要实现在protobuf定义的函数，具体为定义一个结构体组合UnimplementedUserServiceServer,然后实现对应的方法。注意pb生成的golang函数与go本身的rpc不同的地方在于有一个context入参和返回值是通过返回来获取而不是作为一个参数的。</p>
<h3 id="client">client</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;8888&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 建立链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">insecure</span><span class="p">.</span><span class="nf">NewCredentials</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 一定要记得关闭链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 实例化客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">hello</span><span class="p">.</span><span class="nf">NewUserServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 发起请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Say</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">hello</span><span class="p">.</span><span class="nx">Request</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;lin钟一&#34;</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;client.SayHi err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: %s&#34;</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>客户端代码也很简单，首先建立链接，然后实例化客户端，最后发起请求。</p>
<h2 id="grpc-streaming-client-and-server">gRPC Streaming, Client and Server</h2>
<ul>
<li>Server-side streaming RPC—— 客户端向服务器发送单个请求并接收回数据序列流（读回一系列消息）。客户端从返回的流中读取，直到没有更多消息为止。</li>
<li>Client-side streaming RPC—— 客户端向服务器发送数据序列流（写入一系列消息），一旦客户端完成了消息的写入，它会等待服务器读取所有消息并返回其响应结果。</li>
<li>Bidirectional streaming RPC—— 它是双向流式传输，客户端和服务器使用读写流发送一系列消息。两个流独立运行；因此，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入。保留每个流中消息的顺序。例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。</li>
</ul>
<h3 id="server-stream">server stream</h3>
<p>这个是服务端发送stream类型的数据</p>
<h4 id="proto">proto</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">StreamService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="k">rpc</span> <span class="n">List</span><span class="p">(</span><span class="n">StreamRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">StreamResponse</span><span class="p">)</span> <span class="p">{};</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h4 id="服务端">服务端</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">2. 通过 client 获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">3. for循环中通过stream.Recv()依次获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="cm">4. err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">List</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 具体返回多少个response根据业务逻辑调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过 send 方法不断推送数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Name</span><span class="p">:</span>  <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Value</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回nil表示已经完成响应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>StreamService_ListServer是pb-grpc为 stream 类型的生成的类型，他的公开函数为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StreamService_ListServer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Send</span><span class="p">(</span><span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//内部一般有一个私有结构体来实现这个Send，Send一般就是调用ServerStream的SendMsg方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">streamServiceListServer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">streamServiceListServer</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ServerStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="客户端">客户端</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">2. 通过 client 获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">3. for循环中通过stream.Recv()依次获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="cm">4. err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用获取stream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">List</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// for循环获取服务端推送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 通过 Recv() 不断获取服务端send()推送的消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// err==io.EOF则表示服务端关闭stream了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="client-stream">client stream</h3>
<h3 id="proto-1">proto</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">StreamService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Record</span><span class="p">(</span><span class="n">stream</span> <span class="n">StreamRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">StreamResponse</span><span class="p">)</span> <span class="p">{};</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h4 id="server-1">server</h4>
<p>其实差不多，只是server变成了Recv和SendAndClose</p>
<h4 id="client-1">client</h4>
<p>变成了Send和CloseAndRecv</p>
<h3 id="bidirectional-stream">bidirectional stream</h3>
<h3 id="proto-2">proto</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">StreamService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Route</span><span class="p">(</span><span class="n">stream</span> <span class="n">StreamRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">StreamResponse</span><span class="p">)</span> <span class="p">{};</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h3 id="server-2">server</h3>
<p>这里比较有意思，在服务端可以一边接受一边发送</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">// 1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">// 2. 通过client调用方法获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">// 3. 开两个goroutine（使用 chan 传递数据） 分别用于Recv()和Send()
</span></span></span><span class="line"><span class="cl"><span class="cm">// 3.1 一直Recv()到err==io.EOF(即客户端关闭stream)
</span></span></span><span class="line"><span class="cl"><span class="cm">// 3.2 Send()则自己控制什么时候Close 服务端stream没有close 只要跳出循环就算close了。 具体见https://github.com/grpc/grpc-go/issues/444
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Route</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RouteServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">wg</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">//任务编排
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">msgCh</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgCh</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">Name</span><span class="p">:</span>  <span class="nx">v</span><span class="p">.</span><span class="nf">GetName</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">Value</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">})</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Send error :&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">n</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;recv error :%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;stream.Recv pt.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">msgCh</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gRPC Stream Server: Route&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">close</span><span class="p">(</span><span class="nx">msgCh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">//等待任务结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="client-2">client</h3>
<p>和服务端类似，但是客户端需要主动调用 stream.CloseSend ()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">1. 建立连接 获取client
</span></span></span><span class="line"><span class="cl"><span class="cm">2. 通过client获取stream
</span></span></span><span class="line"><span class="cl"><span class="cm">3. 开两个goroutine 分别用于Recv()和Send()
</span></span></span><span class="line"><span class="cl"><span class="cm">    3.1 一直Recv()到err==io.EOF(即服务端关闭stream)
</span></span></span><span class="line"><span class="cl"><span class="cm">    3.2 Send()则由自己控制
</span></span></span><span class="line"><span class="cl"><span class="cm">4. 发送完毕调用 stream.CloseSend()关闭stream 必须调用关闭 否则Server会一直尝试接收数据 一直报错...
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">printRoute</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用方法获取stream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Route</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 开两个goroutine 分别用于Recv()和Send()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Server Closed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;send error:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 发送完毕关闭stream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="p">=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Send error:%v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="参考">参考</h2>
<ol>
<li><a href="https://learnku.com/articles/73104">入门grpc非常好的文章</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>protobuf-intro</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/19/category/protobuf-intro/</link>
      <pubDate>Sun, 19 Nov 2023 09:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/19/category/protobuf-intro/</guid>
      <description>本篇文章记录学习protobuf的过程 定义消息 syntax = &amp;#34;proto3&amp;#34;; message name { body } syntax = &amp;#34;proto3&amp;#34;; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } 通常把message定义在一个单独的文件</description>
      <content:encoded><![CDATA[<h1 id="本篇文章记录学习protobuf的过程">本篇文章记录学习protobuf的过程</h1>
<h2 id="定义消息">定义消息</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">name</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="n">body</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">syntax</span> <span class="o">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span> <span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">result_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>通常把message定义在一个单独的文件中，文件名以.proto结尾。</p>
</blockquote>
<ul>
<li>第一行指定版本，不指定默认是proto2.</li>
<li>message是消息的关键字，后面跟着消息的名称，名称必须是唯一的。</li>
</ul>
<h3 id="字段类型字段标识和字段标签field-type--field-numbers--field-labels">字段类型，字段标识和字段标签（Field Type &amp; Field Numbers &amp; Field labels）</h3>
<h4 id="字段类型field-type">字段类型Field Type</h4>
<h5 id="数字类型">数字类型</h5>
<p>int64,int32,uint32,uint64,sint32,sin64 都是可变长的,然后uint表示无符号,sint在表示负数的时候比较高效</p>
<p>fixed32,fixed64,sfix32,sfix64 都是固定长度的</p>
<h5 id="其他常见类型">其他常见类型</h5>
<p>bool</p>
<p>string 大小小于2^32</p>
<p>bytes 大小可能大于2^32</p>
<h5 id="enum">enum</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">enum</span> <span class="n">Corpus</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_UNIVERSAL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_WEB</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_IMAGES</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_LOCAL</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_NEWS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_PRODUCTS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">CORPUS_VIDEO</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">SearchRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">query</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">page_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">int32</span> <span class="n">results_per_page</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="n">Corpus</span> <span class="n">corpus</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h5 id="map">map</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="n">map</span><span class="p">&lt;</span><span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">&gt;</span> <span class="n">map_field</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>…where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type. The value_type can be any type except another map.</p>
</blockquote>
<p>key_type可以是:标量(除bytes和bool),value_type不能是map,不能嵌套map</p>
<h5 id="any">any</h5>
<p>Any 消息类型允许您将消息作为嵌入类型使用，而不需要它们的.proto 定义。</p>
<p>Any 以字节的形式包含任意序列化的消息，以及作为该消息类型的全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，您需要 import google/protobuf/any.proto</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="k">import</span> <span class="s">&#34;google/protobuf/any.proto&#34;</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">ErrorStatus</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">repeated</span> <span class="n">google.protobuf.Any</span> <span class="n">details</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h5 id="oneof">oneof</h5>
<p>如果需要一条包含多个字段的消息，并且最多同时设置一个字段，可以强制执行此行为并使用 oneof 功能节省内存。</p>
<p>oneof 字段与常规字段一样，在 oneof 共享内存中的所有字段，最多可以同时设置一个字段。设置 oneof 的任何成员会自动清除所有其他成员。</p>
<p>如果设置了多个值，则由 proto 中的 order 确定的最后一个设置的值将覆盖所有以前的设置值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">SampleMessage</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">oneof</span> <span class="n">test_oneof</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>    <span class="n">SubMessage</span> <span class="n">sub_message</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h4 id="field-numbers">Field Numbers</h4>
<p>每个字段都要有一个标识，这里还是比较复杂的。</p>
<p>先说基本要求：</p>
<ol>
<li>field numbers 必须唯一（指在那个message内）</li>
<li>19,000-19,999是被pb内部使用的，不能使用</li>
<li>不能使用reserved的和已经分配给extension的</li>
<li>Field number不能被reuse，这其实是在说delete的时候要把这个field number和对应的name加到reserved里面去，之后都不能用</li>
</ol>
<p>然后是一些tricks：尽量把经常用到的字段分配小的field number因为他们的占用相对小，而且在编码的时候也会更加高效。</p>
<h4 id="field-labels">Field labels</h4>
<ul>
<li>optional
<ul>
<li>field is set, 也就是有一个确切值</li>
<li>field is unset,那么会返回的是default value</li>
</ul>
</li>
<li>repeated 其实就是说这个字段是一个数组</li>
<li>map</li>
<li>implicit field message(如果没有label)</li>
</ul>
<h3 id="package">package</h3>
<p>给一个.proto文件指定package, 是为了避免和其他的.proto文件的message名称冲突.</p>
<p>option go_package = &ldquo;github.com/TripleCGame/apis/api;api&rdquo;;—前一个参数用于指定生成文件的位置，后一个参数指定生成的 .go 文件的 package 。具体语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="k">option</span> <span class="n">go_package</span> <span class="o">=</span> <span class="s">&#34;{out_path};out_go_package&#34;</span><span class="p">;</span><span class="err">
</span></span></span></code></pre></div><p>注意：这里指定的 out_path 并不是绝对路径，只是相对路径或者说只是路径的一部分，和 protoc 的 &ndash;go_out 拼接后才是完整的路径。</p>
<h2 id="定义service">定义service</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">SearchService</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Search</span><span class="p">(</span><span class="n">SearchRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">SearchResponse</span><span class="p">);</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h2 id="命令">命令</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">protoc -I . -I /usr/local/include -I <span class="k">$(</span>GOPATH<span class="k">)</span>/src --go_out<span class="o">=</span>. simple.proto
</span></span></code></pre></div><p>-I 或 &ndash;proto_path: 		指定import搜索的文件夹路径</p>
<p>&ndash;go_out 		  :	 	 编译产生的 go代码 的生成位置</p>
<h3 id="代码生成规则">代码生成规则</h3>
<p>每个xxx.proto文件, 生成一个xxx.pb.go文件.</p>
<p>Go文件的package文件的生成规则:</p>
<ul>
<li>
<p>case1: .proto文件不包含package</p>
<ul>
<li>如果一个.proto文件中不包含package声明，生成的源代码将会使用.proto文件的文件名(去掉扩展名)作为Go包名，</li>
<li>其中, 生成的Go的包名中会自动把.转换为_。</li>
<li>举例来说一个名为high.score.proto不包含package声明的proto文件, 将会生成文件high.score.pb.go，他的Go包名是high_score。</li>
</ul>
</li>
<li>
<p>case2: .proto文件包含package</p>
<ul>
<li>经过编译的Go代码的包名默认使用proto文件的package名称, 除非在.proto文件中使用option go_package显示进行指定Go文件的import path.</li>
<li>其中, 生成的Go的包名中会自动把.转换为_。</li>
<li>举例来说proto包名example.high_score将会生成Go包名example_high_score。</li>
</ul>
</li>
<li>
<p>case3: .proto文件包含package, 同时包含option go_package</p>
<ul>
<li>option go_package 的作用是去指定生成的go文件的package的完整导入路径(import path)的, 如:</li>
</ul>
<p><code>option go_package = &quot;example.com/foo/bar&quot;; // 生成的foo.pb.go文件的package的import path就是 &quot;example.com/foobar&quot;</code></p>
</li>
</ul>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://protobuf.dev/programming-guides/proto3/">Protocol Buffers Documentation</a></li>
<li><a href="https://juejin.cn/post/6865126893063471112">这篇文章讲的特别好</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>plan9&#43;go-assembler</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/plan9-go-assembler/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/plan9-go-assembler/</guid>
      <description>plan9 本文记录plan9汇编的学习过程，sorry全是抄的，只能说抄一遍印象深一点而且好复盘。 基本指令 栈调整 SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈</description>
      <content:encoded><![CDATA[<h1 id="plan9">plan9</h1>
<p>本文记录plan9汇编的学习过程，sorry全是抄的，只能说抄一遍印象深一点而且好复盘。</p>
<p><img src="https://picx.zhimg.com/80/215522854f166f7b5a537ccfa641c922_720w.webp?source=1def8aca" alt="">
<img src="https://s2.loli.net/2023/11/19/eWghm4HFzrnkOoN.png" alt="image.png"></p>
<h2 id="基本指令">基本指令</h2>
<h3 id="栈调整">栈调整</h3>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧
...               // 省略无用代码
ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧
</code></pre><h3 id="数据">数据</h3>
<p>常数在 plan9 汇编用 $num 表示，可以为负数，默认情况下为十进制。可以用 $0x123 的形式来表示十六进制数。</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">MOVB $1, DI      // 1 byte
MOVW $0x10, BX   // 2 bytes
MOVD $1, DX      // 4 bytes
MOVQ $-10, AX     // 8 bytes
</code></pre><p>搬运的长度是由 MOV 的后缀决定</p>
<h3 id="条件跳转无条件跳转">条件跳转/无条件跳转</h3>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">// 无条件跳转
JMP addr   // 跳转到地址，地址可为代码中的地址，不过实际上手写不会出现这种东西
JMP label  // 跳转到标签，可以跳转到同一函数内的标签位置
JMP 2(PC)  // 以当前指令为基础，向前/后跳转 x 行
JMP -2(PC) // 同上

// 有条件跳转
JNZ target // 如果 zero flag 被 set 过，则跳转
</code></pre><h3 id="寄存器">寄存器</h3>
<p>IA64	rax	rbx	rcx	rdx	rdi	rsi	rbp	rsp	r8	r9	r10	r11	r12	r13	r14	rip</p>
<p>Plan9	AX	BX	CX	DX	DI	SI	BP	SP	R8	R9	R10	R11	R12	R13	R14	PC</p>
<p>在 plan9 汇编里都是可以使用的，应用代码层面会用到的通用寄存器主要是: rax, rbx, rcx, rdx, rdi, rsi, r8~r15 这 14 个寄存器，虽然 rbp 和 rsp 也可以用，不过 bp 和 sp 会被用来管理栈顶和栈底，最好不要拿来进行运算。</p>
<h3 id="伪寄存器">伪寄存器</h3>
<blockquote>
<ul>
<li>FP: Frame pointer: arguments and locals.</li>
<li>PC: Program counter: jumps and branches.</li>
<li>SB: Static base pointer: global symbols.</li>
<li>SP: Stack pointer: top of stack.</li>
</ul>
</blockquote>
<ul>
<li>FP: 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，实际上它根本不是 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个 stack frame 底部的 BP 寄存器。假如当前的 callee 函数是 add，在 add 的代码中引用 FP，该 FP 指向的位置不在 callee 的 stack frame 之内，而是在 caller 的 stack frame 上。具体可参见之后的 栈结构 一章。</li>
<li>PC: 实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。除了个别跳转之外，手写 plan9 代码与 PC 寄存器打交道的情况较少。</li>
<li>SB: 全局静态基指针，一般用来声明函数或全局变量，在之后的函数知识和示例部分会看到具体用法。</li>
<li>SP: plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间。假如局部变量都是 8 字节，那么第一个局部变量就可以用 localvar0-8(SP) 来表示。这也是一个词不表意的寄存器。与硬件寄存器 SP 是两个不同的东西，在栈帧 size 为 0 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset(SP) 形式，则表示伪寄存器 SP。如果是 offset(SP) 则表示硬件寄存器 SP。务必注意。对于编译输出(go tool compile -S / go tool objdump)的代码来讲，目前所有的 SP 都是硬件寄存器 SP，无论是否带 symbol。</li>
</ul>
<h3 id="变量声明">变量声明</h3>
<p>在汇编里所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。</p>
<p>使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:</p>
<p>DATA    symbol+offset(SB)/width, value</p>
<p>使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。</p>
<p>GLOBL divtab(SB), RODATA, $64</p>
<p>GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">DATA age+0x00<span class="o">(</span>SB<span class="o">)</span>/4, <span class="nv">$18</span>  // forever <span class="m">18</span>
</span></span><span class="line"><span class="cl">GLOBL age<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$4</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DATA pi+0<span class="o">(</span>SB<span class="o">)</span>/8, <span class="nv">$3</span>.1415926
</span></span><span class="line"><span class="cl">GLOBL pi<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DATA birthYear+0<span class="o">(</span>SB<span class="o">)</span>/4, <span class="nv">$1988</span>
</span></span><span class="line"><span class="cl">GLOBL birthYear<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$4</span>
</span></span></code></pre></div><p>有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">DATA bio&lt;&gt;+0<span class="o">(</span>SB<span class="o">)</span>/8, <span class="s2">$&#34;oh yes i&#34;</span>
</span></span><span class="line"><span class="cl">DATA bio&lt;&gt;+8<span class="o">(</span>SB<span class="o">)</span>/8, <span class="s2">$&#34;am here &#34;</span>
</span></span><span class="line"><span class="cl">GLOBL bio&lt;&gt;<span class="o">(</span>SB<span class="o">)</span>, RODATA, <span class="nv">$16</span>
</span></span></code></pre></div><p>大部分都比较好理解，不过这里我们又引入了新的标记 &lt;&gt;，这个跟在符号名之后，表示该全局变量只在当前文件中生效，类似于 C 语言中的 static。如果在另外文件中引用该变量的话，会报 relocation target not found 的错误。</p>
<p>flag的其他取值</p>
<blockquote>
<p>NOPROF = 1
(For TEXT items.) Don&rsquo;t profile the marked function. This flag is deprecated.</p>
</blockquote>
<blockquote>
<p>DUPOK = 2
It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use.</p>
</blockquote>
<blockquote>
<p>NOSPLIT = 4
(For TEXT items.) Don&rsquo;t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself.</p>
</blockquote>
<blockquote>
<p>RODATA = 8
(For DATA and GLOBL items.) Put this data in a read-only section.</p>
</blockquote>
<blockquote>
<p>NOPTR = 16
(For DATA and GLOBL items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector.</p>
</blockquote>
<blockquote>
<p>WRAPPER = 32
(For TEXT items.) This is a wrapper function and should not count as disabling recover.</p>
</blockquote>
<blockquote>
<p>NEEDCTXT = 64
(For TEXT items.) This function is a closure so it uses its incoming context register.</p>
</blockquote>
<h3 id="函数声明">函数声明</h3>
<pre tabindex="0"><code>// func add(a, b int) int
//   =&gt; 该声明定义在同一个 package 下的任意 .go 文件中
//   =&gt; 只有函数头，没有实现
TEXT pkgname·add(SB), NOSPLIT, $0-8
    MOVQ a+0(FP), AX
    MOVQ a+8(FP), BX
    ADDQ AX, BX
    MOVQ BX, ret+16(FP)
    RET
</code></pre><pre tabindex="0"><code>
                              参数及返回值大小
                                  | 
 TEXT pkgname·add(SB),NOSPLIT,$32-32
       |        |               |
      包名     函数名         栈帧大小(局部变量+可能需要的额外调用函数的参数空间的总大小，但不包括调用其它函数时的 ret address 的大小)
</code></pre><p>为什么要叫 TEXT ？如果对程序数据在文件中和内存中的分段稍有了解的同学应该知道，我们的代码在二进制文件中，是存储在 .text 段中的，这里也就是一种约定俗成的起名方式。实际上在 plan9 中 TEXT 是一个指令，用来定义一个函数。除了 TEXT 之外还有前面变量声明说到的 DATA/GLOBL。</p>
<h3 id="栈结构">栈结构</h3>
<p><img src="https://s2.loli.net/2023/11/19/yWCViLIpnArb4w9.png" alt="image.png"></p>
<p>在 AMD64 环境，伪 PC 寄存器其实是 IP 指令计数器寄存器的别名。伪 FP 寄存器对应的是函数的帧指针，一般用来访问函数的参数和返回值。伪 SP 栈指针对应的是当前函数栈帧的底部（不包括参数和返回值部分），一般用于定位局部变量。伪 SP 是一个比较特殊的寄存器，因为还存在一个同名的 SP 真寄存器。真 SP 寄存器对应的是栈的顶部，一般用于定位调用其它函数的参数和返回值。</p>
<p>当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如 (SP)、+8(SP) 没有标识符前缀为真 SP 寄存器，而 a(SP)、b+8(SP) 有标识符为前缀表示伪寄存器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">                                                                                   
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       current func arg0                                           
</span></span><span class="line"><span class="cl">                       ----------------- &lt;----------- FP<span class="o">(</span>pseudo FP<span class="o">)</span>                
</span></span><span class="line"><span class="cl">                        <span class="nb">caller</span> ret addr                                            
</span></span><span class="line"><span class="cl">                       +---------------+                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span> <span class="nb">caller</span> BP<span class="o">(</span>*<span class="o">)</span>  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       ----------------- &lt;----------- SP<span class="o">(</span>pseudo SP，实际上是当前栈帧的 BP 位置<span class="o">)</span>
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var0  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var1  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local Var2  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                -                          
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   ........    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   Local VarN  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  temporarily  <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  unused space <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>               <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call retn    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call ret<span class="o">(</span>n-1<span class="o">)</span><span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  ..........   <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call ret1    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call argn    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>   .....       <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg3    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg2    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>---------------<span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span>  call arg1    <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       -----------------   &lt;------------  hardware SP 位置           
</span></span><span class="line"><span class="cl">                       <span class="p">|</span> <span class="k">return</span> addr   <span class="p">|</span>                                           
</span></span><span class="line"><span class="cl">                       +---------------+                                           
</span></span><span class="line"><span class="cl">                                                                                   
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">                                                                                                                              
</span></span><span class="line"><span class="cl">                                       <span class="nb">caller</span>                                                                                 
</span></span><span class="line"><span class="cl">                                 +------------------+                                                                         
</span></span><span class="line"><span class="cl">                                 <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       +----------------------&gt;  --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span> <span class="nb">caller</span> parent BP <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>           BP<span class="o">(</span>pseudo SP<span class="o">)</span> --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   Local Var0     <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   .......        <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         --------------------                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   Local VarN     <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">                                 --------------------                                                                         
</span></span><span class="line"><span class="cl"> <span class="nb">caller</span> stack frame              <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">                                 <span class="p">|</span>   callee arg2    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   callee arg1    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>------------------<span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   callee arg0    <span class="p">|</span>                                                                         
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         ----------------------------------------------+   FP<span class="o">(</span>virtual register<span class="o">)</span>                       
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>                  <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                         <span class="p">|</span>   <span class="k">return</span> addr    <span class="p">|</span>  parent <span class="k">return</span> address   <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">       +----------------------&gt;  +------------------+---------------------------    &lt;-------------------------------+         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>  <span class="nb">caller</span> BP               <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>  <span class="o">(</span><span class="nb">caller</span> frame pointer<span class="o">)</span>  <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                     BP<span class="o">(</span>pseudo SP<span class="o">)</span>  ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local Var0           <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local Var1           <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    ----------------------------                            callee stack frame
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>       .....              <span class="p">|</span>                                              
</span></span><span class="line"><span class="cl">                                                    ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>     Local VarN           <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                  SP<span class="o">(</span>Real Register<span class="o">)</span> ----------------------------                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    <span class="p">|</span>                          <span class="p">|</span>                                    <span class="p">|</span>         
</span></span><span class="line"><span class="cl">                                                    +--------------------------+    &lt;-------------------------------+         
</span></span><span class="line"><span class="cl">                                                                                                                              
</span></span><span class="line"><span class="cl">                                                              callee
</span></span></code></pre></div><h3 id="argsize">argsize</h3>
<p>函数声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"> TEXT pkgname·add<span class="o">(</span>SB<span class="o">)</span>,NOSPLIT,<span class="nv">$16</span>-32
</span></span></code></pre></div><p>前面已经说过 $16-32 表示 $framesize-argsize。Go 在函数调用时，参数和返回值都需要由 caller 在其栈帧上备好空间。callee 在声明时仍然需要知道这个 argsize。argsize 的计算方法是，参数大小求和+返回值大小求和，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。</p>
<h3 id="framesize">framesize</h3>
<p>函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：</p>
<ol>
<li>局部变量，及其每个变量的 size。</li>
<li>在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。</li>
<li>原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会死。</li>
<li>在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。</li>
</ol>
<h2 id="官方文档学习">官方文档学习</h2>
<p>参考自<a href="https://go.dev/doc/asm">A Quick Guide to Go&rsquo;s Assembler</a></p>
<h2 id="实践">实践</h2>
<p>以下的内容基于自己的实践</p>
<h3 id="command">Command</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go tool compile
</span></span></code></pre></div><p>可以通过 go doc cmd/compile 来查看该命令的文档</p>
<p>根据文档可以得知用法如下</p>
<p>go tool compile [flags] file&hellip;</p>
<p>flag：</p>
<ul>
<li>D 设置导入的相对位置</li>
<li>I dir1 I dir2 设置导入包的位置</li>
<li>S 输出汇编代码</li>
<li>N 禁止优化</li>
</ul>
<h3 id="例子">例子</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── compile
</span></span><span class="line"><span class="cl">│   └── main.go
</span></span><span class="line"><span class="cl">└── pkg
</span></span><span class="line"><span class="cl">    ├── pkg_amd64.s
</span></span><span class="line"><span class="cl">    └── var.go
</span></span></code></pre></div><p>main打印pkg中的Id变量，var.go声明，pkg_amd64.s实现</p>
<pre tabindex="0"><code>#include &#34;textflag.h&#34;

GLOBL ·Id(SB),NOPTR,$8

DATA ·Id+0(SB)/1,$0x37
DATA ·Id+1(SB)/1,$0x25
DATA ·Id+2(SB)/1,$0x00
DATA ·Id+3(SB)/1,$0x00
DATA ·Id+4(SB)/1,$0x00
DATA ·Id+5(SB)/1,$0x00
DATA ·Id+6(SB)/1,$0x00
DATA ·Id+7(SB)/1,$0x00
</code></pre><h2 id="reference">Reference</h2>
<ol>
<li><a href="https://mioto.me/2021/01/plan9-assembly/">Plan9 汇编入门讲解</a></li>
<li><a href="https://xargin.com/plan9-assembly/">Go 系列文章3 ：plan9 汇编入门</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-01-basic.html">go高级编程</a></li>
<li><a href="https://segmentfault.com/a/1190000039753236">这个很好</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis-single</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</guid>
      <description>本文记录分布式redis的学习过程 replication(主从) 命令 一般是从节点向主节点发起复制请求 &amp;gt; REPLICAOF host port 原理 Redis的复制主要包括同步</description>
      <content:encoded><![CDATA[<h1 id="本文记录分布式redis的学习过程">本文记录分布式redis的学习过程</h1>
<h2 id="replication主从">replication(主从)</h2>
<h3 id="命令">命令</h3>
<p>一般是从节点向主节点发起复制请求</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">&gt; REPLICAOF host port
</span></span></code></pre></div><h3 id="原理">原理</h3>
<p>Redis的复制主要包括同步（sync）和命令传播（command propagate）</p>
<h4 id="同步">同步</h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis-single</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</link>
      <pubDate>Thu, 16 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/16/category/redis-single/</guid>
      <description>redis单机数据库的实现 数据库 服务端有一个结构体 struct redisServer { char *configfile; // 配置文件的绝对路径 int hz; // serverCron() 每秒调用的次数 redisDb *db; // 数据库 }; 命令 切换数据库SELEC</description>
      <content:encoded><![CDATA[<h2 id="redis单机数据库的实现">redis单机数据库的实现</h2>
<h3 id="数据库">数据库</h3>
<p>服务端有一个结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">configfile</span><span class="p">;</span>             <span class="c1">// 配置文件的绝对路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">hz</span><span class="p">;</span>                       <span class="c1">// serverCron() 每秒调用的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisDb</span> <span class="o">*</span><span class="n">db</span><span class="p">;</span>    <span class="c1">// 数据库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><img src="https://pic4.zhimg.com/80/v2-b8fb33ad197578f8bd1e3d7c2962fe6b_720w.webp" alt="before"></p>
<h4 id="命令">命令</h4>
<p>切换数据库<code>SELECT ${dbnumber}</code>
<img src="https://pic4.zhimg.com/80/v2-691e28bc290a35f699bf145c5b655467_720w.webp" alt="after"></p>
<h3 id="键空间">键空间</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数据库键空间，保存着数据库中的所有键值对    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</span></span></code></pre></div><p><img src="https://pic1.zhimg.com/80/v2-03929f00f0134f78a34813e419d8ba54_720w.webp" alt=""></p>
<p>增删改查基本都和dict有关，还有一些其他操作比如FLUSHDB，RANDOMKEY，KEYS等等也都是对键值对进行操作得到的。</p>
<p>值得注意的是在读写键时redis会维护相关信息：</p>
<ol>
<li>记录hit&amp;miss信息</li>
<li>更新LRU时间</li>
<li>如果过期则删除</li>
<li>WATCH指令会记录并发送事件</li>
<li>每次修改会incr dirty flag（影响持久化）</li>
</ol>
<h4 id="键的过期或生存时间">键的过期或生存时间</h4>
<h5 id="命令-1">命令</h5>
<p>基本上就是EXPIRE，PEXPIRE，EXPIREAT，TTL，PERSIST这几个</p>
<h5 id="实现结构">实现结构</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// ...    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 数据库键空间，保存着数据库中的所有键值对    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span> <span class="c1">// 过期字典，保存着键的过期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</span></span></code></pre></div><p>就是dict键值对字典差不多，区别在于值是 long long类型的而已。</p>
<h5 id="过期键的判定和删除">过期键的判定和删除</h5>
<p>判定：</p>
<p>先去expires字典找过期时间，然后和当前时间比较，如果过期则返回-1，否则返回剩余时间。</p>
<p>删除：</p>
<h6 id="1-定时删除">1. 定时删除</h6>
<p>内存友好（该删就删），cpu不友好（时间事件中断，查找时间事件的无序链表复杂度为O(N)）</p>
<p>创建KEY的时候创建一个timer.</p>
<h6 id="2-惰性删除">2. 惰性删除</h6>
<p>内存不友好 （只有要用到才删除） cpu友好</p>
<p><img src="https://pic3.zhimg.com/80/v2-df499f6f57bdf2870241805949e1be5e_720w.webp" alt="">
<img src="https://pic3.zhimg.com/80/v2-14c9a6009d9dfe2b0a1439b7d1caeff2_720w.webp" alt=""></p>
<h6 id="3-定期删除">3. 定期删除</h6>
<p>在上面两个方案之间权衡，隔一段时间扫描一次，删除过期的键。</p>
<p>实现：</p>
<p>每次servercron执行的时候就会执行activeExpireCycle函数，这个函数会遍历所有db里的所有键（随机取出）执行一段时间。下次执行的时候会从上次停止的地方继续执行。</p>
<h5 id="aof和rdb对过期键的处理">AOF和RDB对过期键的处理</h5>
<p>生成AOF和RDB的时候会检查键是否过期，如果过期则不会生成。</p>
<p>载入：</p>
<p>RDB：</p>
<p>主服务器不会载入过期键，从服务器会载入所有。</p>
<p>AOF：</p>
<p>删除过期键会在AOF中记录一条DEL命令。</p>
<h3 id="持久化">持久化</h3>
<h4 id="rdb">RDB</h4>
<p>AOF优先级大于RDB，如果开启了AOF则RDB不会执行。</p>
<p>SAVE和BGSAVE：SAVE会阻塞，BGSAVE是fork一个子进程来执行，fork下的子进程会继承虚页表，写时复制，所以不会占用太多内存。当主进程进行写操作时，会把写操作涉及的物理内存页先拷贝一份，子进程的虚拟内存指向新的这个物理内存页，这也就是COW特性。</p>
<p>BGSAVE和BGWRITEAOF的冲突的，也就是不能同时执行。</p>
<p>配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 900秒内如果有1个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">900</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 300秒内如果有10个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">300</span> <span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 60秒内如果有10000个key被修改则执行BGSAVE</span>
</span></span><span class="line"><span class="cl">save <span class="m">60</span> <span class="m">10000</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//修改计数器,之前说过每次对键的操作会记录dirty flag，此时可以用来判断是否需要BGSAVE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//上一次执行保存的时间,和上面配合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">time_t</span> <span class="n">lastsave</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//记录保存条件的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">saveparam</span> <span class="o">*</span><span class="n">saveparams</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">saveparam</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 秒数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">time_t</span> <span class="n">seconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改的key的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">changes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>检查是否需要BGSAVE的判断是在serverCron里面的，每次执行都会检查是否需要执行BGSAVE，如果需要则执行。</p>
<h5 id="rdb文件结构">RDB文件结构</h5>
<p><img src="https://pic2.zhimg.com/80/v2-1bdd8f1ecbb3ecfb3533caaa81e355fd_720w.webp" alt=""></p>
<p>可以有多个database，每个database里面是[SELECT,db_number,key_value_pairs]</p>
<p>key_value_pairs里面是[TYPE,key,value],如果是带过期时间的话[EXPIRETIME_MS,ms,TYPE,Key,Value]</p>
<h4 id="aof">AOF</h4>
<h4 id="实现">实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//AOF缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">aof_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>命令追加：</p>
<p>客户端发出的命令会追加到aof_buf后。</p>
<p>AOF文件的写入和同步</p>
<p>AOF文件的写入判断是在事件处理循环中的flushAppendOnlyFile函数中。</p>
<p>flushAppendOnlyFile根据服务器配置的appendfsync来决定是否需要同步。</p>
<ul>
<li>always： 每次都把aof_buf缓冲区里面的内容写入并同步到AOF文件</li>
<li>everysec：写入到AOF文件，如果距离上次同步超过1sec就同步(syscall fsync)</li>
<li>no： 写入AOF文件，但是不同步</li>
</ul>
<h5 id="载入">载入</h5>
<p>虚拟出一个不带网络连接的客户端一条条指令读取执行。</p>
<h5 id="重写">重写</h5>
<p>其实就和rocksdb的compaction差不多</p>
<p>值得注意的是后台重写，子进程fork之后会有一个AOF重写缓冲区，在重写过程中命令会被同时写到AOF缓冲和AOF重写缓冲区。在子进程重写完后会给父进程发送一个信号，父进程接受到信号后会把AOF重写缓冲区的内容写到AOF文件中并替换旧的。</p>
<h3 id="事件">事件</h3>
<p>事件分为文件事件（fd）和时间事件</p>
<h4 id="文件事件">文件事件</h4>
<p>i/o多路复用处理事件可以看我的另一篇文章[interview-linux]</p>
<h5 id="事件类型">事件类型</h5>
<ol>
<li>AE_READABLE 可读事件(优先级高)</li>
<li>AE_WRITEABLE 可写事件</li>
</ol>
<h5 id="文件事件处理器">文件事件处理器</h5>
<ol>
<li>连接应答处理器</li>
<li>命令请求处理器</li>
<li>命令回复处理器</li>
</ol>
<p>完整流程：</p>
<p>服务器启动时将监听套接字的AE_READABLE的处理事件设为连接应答处理器&hellip;建立连接（创建客户端fd并将该fd的AE_READBABLE与应答处理器关联还有AE_WRITABLE同理），之后就可以正常处理对应事件了，注意当命令结果全部写回套接字时，AE_WRITABLE会被解除对应事件的关联。</p>
<h4 id="时间事件">时间事件</h4>
<p>主要有两类：</p>
<ol>
<li>
<p>定时事件</p>
</li>
<li>
<p>周期事件</p>
</li>
</ol>
<h5 id="实现-1">实现</h5>
<p>time_event包含3个属性：id(全局唯一)，when(毫秒)，timeProc(回调函数)</p>
<p>根据timeProc的返回值判断定时or定期</p>
<p>定时：返回ae.h/AE_NOMORE
定期：返回别的</p>
<p>所有time_event结构体包含在一个无序链表中（新事件插入到表头），每次都会遍历这个链表，如果when小于当前时间则执行对应的回调函数。</p>
<p>时间事件应用示例：serverCron函数</p>
<p>serverCron函数作用</p>
<ul>
<li>更新统计信息</li>
<li>是否删除过期键值对</li>
<li>是否进行持久化</li>
<li>主从是否同步</li>
<li>是否关闭客户端连接</li>
</ul>
<h4 id="事件调度">事件调度</h4>
<p>就是一个循环，先获取最近的一个事件（有可能已经过去），设置timeinterval（可能0），在这个time-interval里面找文件事件，然后分别处理这些事件。</p>
<h3 id="clientserver">client&amp;server</h3>
<h4 id="client">client</h4>
<p>CLIENT LIST来显示client信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisClient</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//-1代表伪客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//name 用CLIENT setname来设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 标记状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">querybuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命令参数数组，每个都是一个字符串对象【set】 【key】 【&#34;value&#34;】
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命令参数数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向当前正在执行的命令对象,是通过argv的第0个值在command字典里面找的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">redisCommand</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 固定输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">REDIS_REPLY_CHUNK_BYTES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//buf数组已使用字节数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">bufpos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//不固定输出缓冲区,多个字符串构成的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span> <span class="o">*</span><span class="n">reply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//身份验证 0 代表未通过，1代表通过。使用AUTH password 来验证
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">authenticated</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//时间相关的记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//伪客户端一直存在，直到server被关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisClient</span> <span class="o">*</span><span class="n">lua_client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="客户端的创建和关闭">客户端的创建和关闭</h5>
<h6 id="创建">创建</h6>
<p>如果是通过网络，那就会调用连接应答处理器来将一个CLient添加到redisServer的client链表末尾</p>
<h6 id="关闭">关闭</h6>
<p>关闭的原因有很多</p>
<ol>
<li>客户端主动退出</li>
<li>被Client kill杀死</li>
<li>timeout超时，但是主从复制，或者是pubsub的客户端不会超时</li>
<li>输入输出缓冲区溢出</li>
</ol>
<h4 id="server">server</h4>
<p>一个命令的执行流程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisCommand</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">redisCommmandProc</span><span class="o">*</span> <span class="n">proc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//参数个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">arity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//字符串表示的FLAG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">sflags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//实际FLAG
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>客户端键入<code> SET KEY VALUE</code></li>
<li>客户端翻译成协议格式</li>
<li>发送到服务端，服务端解析到对应CLient结构的argv和argc
<ol>
<li>命令执行器(1)查找命令实现（在命令表字典里面找{&ldquo;SET&rdquo;,*redisCommand}）</li>
<li>命令执行器(2) 执行预备操作
<ul>
<li>检查cmd指针是不是NULL</li>
<li>检查命令的参数个数是否正确</li>
<li>检查身份验证</li>
<li>等等</li>
</ul>
</li>
<li>命令执行器(3) 执行命令
<ul>
<li>读取键值对</li>
<li>执行命令</li>
<li>返回结果</li>
</ul>
</li>
<li>命令执行器(4) 执行后续操作
<ul>
<li>AOF</li>
<li>判断是否需要记录为慢查询</li>
</ul>
</li>
</ol>
</li>
</ol>
<h5 id="servercron函数">serverCron函数</h5>
<ul>
<li>更新时间，redisServer结构中有两个属性分别是unixtime和mstime，分别记录了秒和毫秒，这是为了减少获取时间的系统调用次数。这两个值被用来操作时间精度要求不高的功能（LRU时间更新，打印日志）</li>
<li>更新统计信息，比如命中率，命中次数，miss次数，命令执行次数，命令执行耗时等等</li>
<li>是否删除过期键值对，这个在上面已经说过了</li>
<li>是否进行持久化，这个也在上面说过了</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《Golang 编译器代码浅析》阅读</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/13/category/golang-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B5%85%E6%9E%90%E9%98%85%E8%AF%BB/</link>
      <pubDate>Mon, 13 Nov 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/13/category/golang-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A3%E7%A0%81%E6%B5%85%E6%9E%90%E9%98%85%E8%AF%BB/</guid>
      <description>Golang 编译器代码浅析</description>
      <content:encoded><![CDATA[<p><a href="https://gocompiler.shizhz.me/">Golang 编译器代码浅析</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-base-structure</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-base-structure/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-base-structure/</guid>
      <description>记录golang中的底层数据结构 slice 基础的东西比如len，cap，ptr这些东西就不说了 从slice中获取内存地址和从内存中构造slice 从s</description>
      <content:encoded><![CDATA[<h1 id="记录golang中的底层数据结构">记录golang中的底层数据结构</h1>
<h2 id="slice">slice</h2>
<p>基础的东西比如len，cap，ptr这些东西就不说了
<img src="https://img.halfrost.com/Blog/ArticleImage/57_2.png" alt="go slice"></p>
<h3 id="从slice中获取内存地址和从内存中构造slice">从slice中获取内存地址和从内存中构造slice</h3>
<h4 id="从slice中获取内存地址">从slice中获取内存地址</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></div><h4 id="从内存中构造slice">从内存中构造slice</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s1</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">addr</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cap</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}{</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s1</span><span class="p">))</span>
</span></span></code></pre></div><p>或者使用go的反射包中的SliceHeader</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">o</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)((</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Cap</span> <span class="p">=</span> <span class="nx">length</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Len</span> <span class="p">=</span> <span class="nx">length</span>
</span></span><span class="line"><span class="cl"><span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Data</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p>BTW 为了看懂上面的代码我还去学了下unsafe包(还是蛮简单的)</p>
</blockquote>
<p>值得注意的是reflect.SliceHeader已经被弃用了，下面是go的官方解释</p>
<blockquote>
<p>SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.</p>
</blockquote>
<p>其实就是uintptr是不能保证数据不被GC掉，然后SliceHeader已经被移到unsafe里面去了。</p>
<h3 id="空切片和nil切片的区别">空切片和nil切片的区别</h3>
<p>空切片
<img src="https://img.halfrost.com/Blog/ArticleImage/57_7.png" alt="空"></p>
<p>nil切片
<img src="https://img.halfrost.com/Blog/ArticleImage/57_8.png" alt="nil切片"></p>
<p>一个是指向一个空的数组，一个是指向nil</p>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<h2 id="map">map</h2>
<p>比较复杂，见另一篇文章。</p>
<h3 id="参考">参考</h3>
<ol>
<li><a href="https://eddycjy.com/posts/go/map-con/">Go 为什么不在语言层面支持 map 并发？</a></li>
</ol>
<h2 id="syncmap">sync.map</h2>
<p>为了并发的map而被设计出来，在两种情况下他的性能是最好的</p>
<ol>
<li>when the entry for a given key is only ever written once but read many times, as in caches that only grow.</li>
<li>when multiple goroutines read, write, and overwrite entries for disjoint sets of keys.</li>
</ol>
<p>同时定义了两大类操作：</p>
<ol>
<li>Load, LoadAndDelete, LoadOrStore, Swap, CompareAndSwap, and CompareAndDelete are read operations;</li>
<li>Delete, LoadAndDelete, Store, and Swap are write operations;</li>
</ol>
<p>而且<strong>LoadOrStore is a write operation when it returns loaded set to false; CompareAndSwap is a write operation when it returns swapped set to true; and CompareAndDelete is a write operation when it returns deleted set to true.</strong></p>
<p>在go的内存模型中<em>Map arranges that a write operation “synchronizes before” any read operation that observes the effect of the write</em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//即使old设成nil也不能判断空的是删除成功，所以返回true的语义很强（本身存在key，并且和old一样）
</span></span></span><span class="line"><span class="cl"><span class="c1">//CompareAndDelete deletes the entry for key if its value is equal to old. The old value must be of a comparable type.
</span></span></span><span class="line"><span class="cl"><span class="c1">//If there is no current value for key in the map, CompareAndDelete returns false (even if the old value is the nil interface value).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">CompareAndDelete</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">deleted</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//nil是不可比较的，所以同样不可以把 old设成nil
</span></span></span><span class="line"><span class="cl"><span class="c1">//CompareAndSwap swaps the old and new values for key if the value stored in the map is equal to old. The old value must be of a comparable type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">any</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//无法从返回值中得到信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//这个倒是和普通map挺像的
</span></span></span><span class="line"><span class="cl"><span class="c1">//Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Load</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//本来在单线程的话是可以分两个操作的，但是在并发场景下就只能合在一起形成新的primitive
</span></span></span><span class="line"><span class="cl"><span class="c1">//LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadAndDelete</span><span class="p">(</span><span class="nx">key</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//和上面差不多
</span></span></span><span class="line"><span class="cl"><span class="c1">//LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">actual</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//遍历的方式，可以在其中删除map中的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//常规
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">any</span><span class="p">)</span> <span class="p">(</span><span class="nx">previous</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="channel">channel</h2>
<h3 id="数据结构">数据结构</h3>
<h3 id="参考-1">参考</h3>
<ol>
<li><a href="https://www.bilibili.com/video/BV1uv4y187p6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7d9aad84add3e8bea9beb1d04c53f57e">go channel视频</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-pprof</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-pprof/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-pprof/</guid>
      <description>简单介绍 是什么 pprof 是用于可视化和分析性能分析数据的工具 pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告） profile.proto 是一个</description>
      <content:encoded><![CDATA[<h2 id="简单介绍">简单介绍</h2>
<blockquote>
<p>是什么
pprof 是用于可视化和分析性能分析数据的工具</p>
</blockquote>
<blockquote>
<p>pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）</p>
</blockquote>
<blockquote>
<p>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p>
</blockquote>
<blockquote>
<p>支持什么使用模式</p>
</blockquote>
<blockquote>
<ul>
<li>Report generation：报告生成</li>
<li>nteractive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
</blockquote>
<blockquote>
<p>可以做什么</p>
<ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">pprof实战</a></li>
<li><a href="https://howieyuen.github.io/docs/golang/tools/pprof/">pprof</a></li>
<li><a href="https://github.com/eddycjy/blog/blob/master/content/posts/go/tools/2018-09-15-go-tool-pprof.md">煎鱼大佬的博客</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-snowflake</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-snowflake/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-snowflake/</guid>
      <description>雪花算法 1.第一位 占用1bit，其值始终是0，没有实际作用。 2.时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。 3.工作机器i</description>
      <content:encoded><![CDATA[<h1 id="雪花算法">雪花算法</h1>
<p><img src="https://pic4.zhimg.com/80/v2-0ca4a4125b1cbda69cfa972b1e568ffb_720w.webp" alt=""></p>
<p>1.第一位 占用1bit，其值始终是0，没有实际作用。 2.时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。 3.工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。 4.序列号 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p>
<blockquote>
<p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢：： 同一毫秒的ID数量 = 1024 X 4096 = 4194304</p>
</blockquote>
<h2 id="这里的代码实现是基于osproxy的">这里的代码实现是基于osproxy的</h2>
<h3 id="变量和类型">变量和类型</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">snowFlake</span> <span class="o">*</span><span class="nx">Snowflake</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">twepoch</span>            <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1417937700000</span><span class="p">)</span> <span class="c1">// Unix纪元时间戳
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">workerIdBits</span>       <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>              <span class="c1">// 机器ID所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">datacenterBits</span>     <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>              <span class="c1">// 数据中心ID所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxWorkerId</span>        <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">workerIdBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">maxDatacenterId</span>    <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">datacenterBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequenceBits</span>       <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="c1">// 序列号所占位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">workerIdShift</span>      <span class="p">=</span> <span class="nx">sequenceBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">datacenterIdShift</span>  <span class="p">=</span> <span class="nx">sequenceBits</span> <span class="o">+</span> <span class="nx">workerIdBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">timestampLeftShift</span> <span class="p">=</span> <span class="nx">sequenceBits</span> <span class="o">+</span> <span class="nx">workerIdBits</span> <span class="o">+</span> <span class="nx">datacenterBits</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequenceMask</span>       <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">^</span> <span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">sequenceBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Snowflake</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mu</span>            <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastTimestamp</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">workerId</span>      <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">datacenterId</span>  <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sequence</span>      <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="初始化">初始化</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">InitSnowFlake</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//这里只有一个数据中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//使用ip来标识每台机器，可能可以根据mac地址来表示，然后通过网关ip来标识数据中心
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// get local ip
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ip</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetOutBoundIP</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// get workId from redis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">workId</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lgRedis</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">plugins</span><span class="p">.</span><span class="nx">LangGoRedis</span><span class="p">).</span><span class="nf">NewRedis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ipExist</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">).</span><span class="nf">Val</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ipExist</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">curWorkId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workId</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">curWorkId</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//在redis中存{ip:workerID}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//而且记录workerID的key是一个自增的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">newWorkId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Incr</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">WorkID</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lgRedis</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ip</span><span class="p">,</span> <span class="nx">newWorkId</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workId</span> <span class="p">=</span> <span class="nx">newWorkId</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newSnowFlake</span><span class="p">(</span><span class="nx">workId</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">snowFlake</span> <span class="p">=</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSnowFlake</span><span class="p">(</span><span class="nx">workerId</span><span class="p">,</span> <span class="nx">datacenterId</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Snowflake</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">workerId</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">workerId</span> <span class="p">&gt;</span> <span class="nx">maxWorkerId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;worker id out of range&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">datacenterId</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">datacenterId</span> <span class="p">&gt;</span> <span class="nx">maxDatacenterId</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;datacenter id out of range&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Snowflake</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastTimestamp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">workerId</span><span class="p">:</span>      <span class="nx">workerId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">datacenterId</span><span class="p">:</span>  <span class="nx">datacenterId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sequence</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="生成">生成</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NextId .
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sf</span> <span class="o">*</span><span class="nx">Snowflake</span><span class="p">)</span> <span class="nf">NextId</span><span class="p">()</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//毫秒级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">timestamp</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//时钟回拨，在用雪花算法的id作为递增主键的时候是一个严重的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">timestamp</span> <span class="p">&lt;</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;clock moved backwards&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//同一时间就用sequence来区分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">timestamp</span> <span class="o">==</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="p">=</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">sequenceMask</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果sequence用完了，就等待下一毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 时钟回拨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">timestamp</span> <span class="o">&lt;=</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">timestamp</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000000</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">sf</span><span class="p">.</span><span class="nx">lastTimestamp</span> <span class="p">=</span> <span class="nx">timestamp</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//拼接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 相当于
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">id</span> <span class="o">:=</span> <span class="p">((</span><span class="nx">timestamp</span> <span class="o">-</span> <span class="nx">twepoch</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">timestampLeftShift</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">datacenterId</span> <span class="o">&lt;&lt;</span> <span class="nx">datacenterIdShift</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="nx">sf</span><span class="p">.</span><span class="nx">workerId</span> <span class="o">&lt;&lt;</span> <span class="nx">workerIdShift</span><span class="p">)</span> <span class="p">|</span> <span class="nx">sf</span><span class="p">.</span><span class="nx">sequence</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">id</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="总结">总结</h3>
<p>实现得还是很精巧的，而且在初始化其实也有合理的入参，配合redis的自增来实现全局唯一id。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/qinguoyi/osproxy#%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5osproxy">osproxy</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>golang-unsafe</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-unsafe/</link>
      <pubDate>Thu, 09 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/09/category/golang-unsafe/</guid>
      <description>unsafe包介绍 首先，unsafe正如其名是不安全的。 来自go语言官方文档的警告 unsafe包的文档是这么说的： 导入unsafe的软件包可</description>
      <content:encoded><![CDATA[<h2 id="unsafe包介绍">unsafe包介绍</h2>
<p>首先，unsafe正如其名是不安全的。</p>
<blockquote>
<p>来自go语言官方文档的警告</p>
</blockquote>
<blockquote>
<p>unsafe包的文档是这么说的：</p>
</blockquote>
<blockquote>
<p>导入unsafe的软件包可能不可移植，并且不受Go 1兼容性指南的保护。</p>
</blockquote>
<blockquote>
<p>Go 1 兼容性指南这么说：</p>
</blockquote>
<blockquote>
<p>导入unsafe软件包可能取决于Go实现的内部属性。 我们保留对可能导致程序崩溃的实现进行更改的权利。</p>
</blockquote>
<p>golang里面的三个指针类型</p>
<ul>
<li>*类型:普通指针类型，用于传递对象地址，不能进行指针运算。</li>
<li>unsafe.Pointer:通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换到某一类型的普通指针）。</li>
<li>uintptr:用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。</li>
</ul>
<h3 id="unsafe包里面">unsafe包里面</h3>
<p>函数：</p>
<p>func Alignof（variable ArbitraryType）uintptr</p>
<p>func Offsetof（selector ArbitraryType）uintptr</p>
<p>func Sizeof（variable ArbitraryType）uintptr</p>
<p>这里，ArbitraryType不是一个真正的类型，它只是一个占位符。与Golang中的大多数函数不同，上述三个函数的调用将始终在编译时求值，而不是运行时。 这意味着它们的返回结果可以分配给常量。</p>
<p>func String(ptr *byte, len IntegerType) string //(go 1.20)</p>
<p>func StringData(str string) *byte //(go 1.20)</p>
<p>这里只讲后两个新加的函数，StringData用于从string中获取地址，String函数用于从特定的字符串地址中截取len长度的子字符串。</p>
<p>类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其实和上面String的两个函数一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">func</span> <span class="nf">Slice</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="nx">ArbitraryType</span><span class="p">,</span> <span class="nx">len</span> <span class="nx">IntegerType</span><span class="p">)</span> <span class="p">[]</span><span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">SliceData</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">ArbitraryType</span><span class="p">)</span> <span class="o">*</span><span class="nx">ArbitraryType</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//SliceData returns a pointer to the underlying array of the argument slice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">//If cap(slice) &gt; 0, SliceData returns &amp;slice[:1][0].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//If slice == nil, SliceData returns nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//Otherwise, SliceData returns a non-nil pointer to an unspecified memory address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">IntegerType</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//其实就是封装了地址偏移函数，以前是要转成uintptr然后计算再转回来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">Pointer</span><span class="p">,</span> <span class="nx">len</span> <span class="nx">IntegerType</span><span class="p">)</span> <span class="nx">Pointer</span>
</span></span></code></pre></div><h2 id="参考">参考</h2>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1192566">Go里面的unsafe包详解 </a></li>
<li><a href="https://www.cnblogs.com/-wenli/p/12682477.html">pointer和uintptr</a></li>
<li><a href="https://www.cnblogs.com/-wenli/p/12681044.html">如何得到一个对象的内存大小</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>redis bloom-filter</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/11/08/category/bloom-filter/</link>
      <pubDate>Wed, 08 Nov 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/11/08/category/bloom-filter/</guid>
      <description>原理 参考 布隆过滤器如何实现?</description>
      <content:encoded><![CDATA[<h2 id="原理">原理</h2>
<h2 id="参考">参考</h2>
<p><a href="https://www.zhihu.com/question/389604738/answer/3152180842">布隆过滤器如何实现?</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>leetcode_record3&#43;顶级线段树</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/10/31/category/leetcode_record3/</link>
      <pubDate>Tue, 31 Oct 2023 08:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/10/31/category/leetcode_record3/</guid>
      <description>2003. 每棵子树内缺失的最小基因值 这题只给了parent数组，不像以往的题目给了根节点，以及对应的树结构。所以首先就是要建树，后面才好后序遍历。 然</description>
      <content:encoded><![CDATA[<h4 id="2003-每棵子树内缺失的最小基因值httpsleetcodecnproblemssmallest-missing-genetic-value-in-each-subtreedescriptionenvtypedaily-questionenvid2023-10-31"><a href="https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/description/?envType=daily-question&amp;envId=2023-10-31">2003. 每棵子树内缺失的最小基因值</a></h4>
<p>这题只给了parent数组，不像以往的题目给了根节点，以及对应的树结构。所以首先就是要建树，后面才好后序遍历。</p>
<p>然后就是怎么保存子树信息，并结合到父节点上。这里用到了一个unordered_set，保存子树中出现的基因值，然后从2开始遍历，找到第一个不在子树中的基因值，就是当前节点的答案。</p>
<p>然后有意思的点在于，实际上只需要从基因值为1的节点开始向上遍历到根就可以了。</p>
<p>有点巧妙了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">smallestMissingValueSubtree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">parents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 不存在基因值为 1 的点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 建树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">g</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// 标记基因值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">son</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">son</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dfs</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 缺失的最小基因值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">it</span> <span class="o">-</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">vis</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">mex</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// node 子树包含这个基因值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">mex</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">mex</span><span class="p">;</span> <span class="c1">// 缺失的最小基因值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">];</span> <span class="c1">// 往上走
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 作者：灵茶山艾府
</span></span></span><span class="line"><span class="cl"><span class="c1">// 链接：https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/
</span></span></span><span class="line"><span class="cl"><span class="c1">// 来源：力扣（LeetCode）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span></code></pre></div><h4 id="2926-平衡子序列的最大和httpsleetcodecnproblemsmaximum-balanced-subsequence-sumdescription"><a href="https://leetcode.cn/problems/maximum-balanced-subsequence-sum/description/">2926. 平衡子序列的最大和</a></h4>
<p>以前就听说过线段树的威名，这次终于见到了，打算做几道题彻底吃透。</p>
<h5 id="首先看点参考资料">首先看点参考资料：</h5>
<ol>
<li>
<p><a href="https://jogchat.com/shuati/%E7%A1%85%E8%B0%B7%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%B9%8B-%E7%BA%BF%E6%AE%B5%E6%A0%91%E3%80%81%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.php">硅谷面试经典算法之-线段树、树状数组</a></p>
</li>
<li>
<p><a href="https://oi-wiki.org/ds/seg/">线段树</a>
<img src="https://s2.loli.net/2023/11/07/kiuHgMyKtjcXRCq.png" alt="image.png"></p>
</li>
</ol>
<p>看到一个有趣的trick：</p>
<p>定义lowbit(x)为x的二进制表达式中最右边的1所对应的值。</p>
<p>比如，1234的二进制是0100 1101 0010  lowbit(1234)=2，在程序的实现中，</p>
<p>Lowbit(x)=x&amp;-x;（为什么这样写呢？因为计算机内部采用补码表示，-x是x按位取反，尾数+1的结果）</p>
<p>这和计算一个数中1的个数有异曲同工之妙！！！(赞)</p>
<h5 id="建立">建立</h5>
<p>代码：</p>
<h6 id="大致建立递归">大致建立（递归）</h6>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     *@param start, end: Denote an segment / interval
</span></span></span><span class="line"><span class="cl"><span class="cm">     *@return: The root of Segment Tree
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="n">SegmentTreeNode</span> <span class="o">*</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">SegmentTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SegmentTreeNode</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">((</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h6 id="例题">例题</h6>
<blockquote>
<p>Range Sum Query - Mutable<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>The update(i, val) function modifies nums by updating the element at index i to val.<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>Example:<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>Given nums = [1, 3, 5]<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>sumRange(0, 2) -&gt; 9
update(1, 2)
sumRange(0, 2) -&gt; 8</p>
</blockquote>
<p>线段树代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">SegmentTreeNode</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">SegmentTreeNode</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="nf">SegmentTreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SegmentTreeNode</span> <span class="n">root</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>    
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">update</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">SegmentTreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">start</span> <span class="o">==</span> <span class="n">position</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">==</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="na">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span><span class="n">position</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">position</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">position</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">sumRange</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="n">SegmentTreeNode</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">start</span> <span class="o">==</span> <span class="n">lo</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="na">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">sumRange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">sumRange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">sumRange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span> <span class="o">+</span> <span class="n">sumRange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">SegmentTreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span><span class="n">lo</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">SegmentTreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SegmentTreeNode</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Your NumArray object will be instantiated and called as such:
</span></span></span><span class="line"><span class="cl"><span class="c1">// NumArray numArray = new NumArray(nums);
</span></span></span><span class="line"><span class="cl"><span class="c1">// numArray.sumRange(0, 1);
</span></span></span><span class="line"><span class="cl"><span class="c1">// numArray.update(1, 10);
</span></span></span><span class="line"><span class="cl"><span class="c1">// numArray.sumRange(1, 2);
</span></span></span></code></pre></div><p>然而实际上，由于值域一般都很大，所以需要动态开点的技术。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @Description: 线段树（动态开点）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @Author: LFool
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @Date 2022/6/7 09:15
</span></span></span><span class="line"><span class="cl"><span class="cm"> **/</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SegmentTreeDynamic</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="n">add</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">1e9</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span><span class="o">.</span><span class="na">add</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushDown</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">mid</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span> <span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushUp</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pushDown</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">mid</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="n">ans</span> <span class="o">+=</span> <span class="n">query</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span> <span class="n">ans</span> <span class="o">+=</span> <span class="n">query</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">pushUp</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">pushDown</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">leftNum</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rightNum</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">add</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="na">add</span> <span class="o">*</span> <span class="n">leftNum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="na">add</span> <span class="o">*</span> <span class="n">rightNum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">add</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="na">add</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">add</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="na">add</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">.</span><span class="na">add</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 作者：LFool⚡
</span></span></span><span class="line"><span class="cl"><span class="c1">// 链接：https://leetcode.cn/problems/range-module/
</span></span></span><span class="line"><span class="cl"><span class="c1">// 来源：力扣（LeetCode）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span></code></pre></div><p>特别的，c++里面new操作比较重，所以一般会有一个这个板子来管理内存</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//arraylist 以SIZE为周期分配内存，delete的内存也可以被回收有点牛的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CachedObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size_t</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">T</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">add</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">CachedObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">CachedObj</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">size_t</span> <span class="n">SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span><span class="o">-&gt;</span><span class="n">CachedObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">*</span> <span class="n">CachedObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">size_t</span> <span class="n">CachedObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CachedObj</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h5 id="例题-1">例题</h5>
<p><a href="https://leetcode.cn/problems/range-module/solutions/1612955/by-lfool-eo50/?envType=daily-question&amp;envId=2023-11-12">线段树例题</a></p>
<h5 id="bit-树状数组-binary-indexed-tree">BIT 树状数组 Binary Indexed Tree</h5>
<h6 id="引入">引入</h6>
<p>利用数组实现前缀和，查询本来是 O(1)，但是对于频繁更新的数组，每次重新计算前缀和，时间复杂度 O(n)。此时树状数组的优势便立即显现。</p>
<p><img src="https://s2.loli.net/2023/11/07/lDrtoVABvh4We2s.png" alt="image.png">
<img src="https://s2.loli.net/2023/11/07/DBIfX4TZrQmuFNl.png" alt="image.png"></p>
<p>例如上图中 A 和 B 都是数组。A 数组正常存储数据，B 数组是树状数组。</p>
<ol>
<li>节点意义</li>
</ol>
<p>在树状数组中，所有的奇数下标的节点的含义是叶子节点，表示单点，它存的值是原数组相同下标存的值。例如上图中 B1，B3，B5，B7 分别存的值是 A1，A3，A5，A7。所有的偶数下标的节点均是父节点。父节点内存的是区间和。例如 B4 内存的是 B1 + B2 + B3 + A4 = A1 + A2 + A3 + A4。这个区间的左边界是该父节点最左边叶子节点对应的下标，右边界就是自己的下标。例如 B8 表示的区间左边界是 B1，右边界是 B8，所以它表示的区间和是 A1 + A2 + …… + A8。</p>
<ol start="2">
<li>代码</li>
</ol>
<p><strong>全是字字珠玑</strong></p>
<p>x如果为左子结点，则父结点的编号是x+lowbit(x)，</p>
<p>x如果为右子结点，则父结点的编号是x-lowbit(x)</p>
<p>Time Complexity - O(nlogn) build，  O(logn) update， O(logn) rangeSum，  Space Complexity - O(n)</p>
<p>很 有意思的构建，以数组nums = {1, 2, 3, 4, 5, 6, 7, 8}为例，这个数组长度为8。 跟dynamic programming的预处理很像，我们先建立一个长度为nums.length + 1 = 9的数组BIT。接下来遍历数组nums，对BIT数组进行update(i + 1, nums[i])。这里BIT数组每个值BIT[i]代表nums数组里在i之前的部分元素和。原理是像自然数可以被表示为2n的和一样，把nums数组 里到0到i的sum表示成2n的和，从而导致update和rangeSum都可以用O(logn)的时间求出来。这里构建的时候可以有几种写法，主要就 是利用当前i的least significante 1来确定到底BIT[i]要保存多少原数组的值。这里借用algorithmist的原话”Every index in the cumulative sum array, say i, is responsible for the cumulative sum from the index i to (i - (1&laquo;r) + 1)。” 构建过程中可以用 (i &amp; -i)来找到least significate 1，之后来进行i = i + (i &amp; -i)来尝试从小到大计算下一个BIT数组中被影响的元素。 而rangeSum的时候则使用i = i - (i &amp; -i)来从大到小查找从0到i - 1的sum。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumArray</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">BIT</span><span class="o">[];</span>               <span class="c1">// Binary Indexed Tree = Fenwick Tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">BIT</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">init</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">BIT</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">BIT</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">init</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">delta</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">getSum</span><span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">getSum</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">BIT</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h6 id="参考">参考</h6>
<ol>
<li><a href="https://halfrost.com/binary_indexed_tree/">聊聊树状数组 Binary Indexed Tree</a></li>
</ol>
<h5 id="回到这个题">回到这个题</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 树状数组模板（维护前缀最大值）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">BIT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BIT</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">LLONG_MIN</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="nf">pre_max</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="n">LLONG_MIN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">&amp;=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxBalancedSubsequenceSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 离散化 nums[i]-i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">sort</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 去重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">BIT</span> <span class="n">t</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// j 为 nums[i]-i 离散化后的值（从 1 开始）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">long</span> <span class="kt">long</span> <span class="n">f</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">pre_max</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="mi">0LL</span><span class="p">)</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">t</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">pre_max</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>他其实是用dp的思想，但是用树状数组来维护前缀最大值，这样就可以在O(logn)的时间内求出前缀最大值，而不用每次都遍历一遍。</p>
<p>这个思路其实和逆序对差不多（逆序对也是BIT的经典题目，通过逆序来找小一个数的前缀和，就能找到比目前这个数小的数目<a href="https://www.cnblogs.com/COLIN-LIGHTNING/p/8621294.html">可以看这个</a>）</p>
<p>这题的话通过正序dp来累积最大值，每次在状态转移的时候可以在logn时间找到前面的最大值来更新现在的。</p>
<p>还要学一下这个离散化的写法，复制-&gt;排序-&gt;去重。然后用下标来表示原来的值。</p>
<p>只能说太亏贼了</p>
<h5 id="差分数组">差分数组</h5>
<p>上面的两个都是单点更新，区间查询。但是有时候我们需要区间更新，单点查询。这时候就需要差分数组了。</p>
<p>其实原理很简单，更新的区间就是在开始和结尾记录一下，然后查单点的话就是一次遍历就能获取所有点的值。</p>
<h4 id="lru和lfu">LRU和LFU</h4>
<p>其实这两个之前都写过</p>
<p>LRU：双向列表加map</p>
<p>LFU：两个map加多个双向列表</p>
<p>但是还是看看这个：<a href="https://halfrost.com/lru_lfu_interview/">究极顶级的LRU&amp;LFU</a></p>
<h4 id="floyd">Floyd</h4>
<p>floyd算法用于计算图中两点之间的最短路径</p>
<p>核心思想就dp</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">dfs<span class="o">(</span>k,i,j<span class="o">)=</span>min<span class="o">(</span>dfs<span class="o">(</span>k−1,i,j<span class="o">)</span>,dfs<span class="o">(</span>k−1,i,k<span class="o">)</span>+dfs<span class="o">(</span>k−1,k,j<span class="o">))</span>
</span></span></code></pre></div><h4 id="分组循环">分组循环</h4>
<p>每日一题遇到的<a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/description/?envType=daily-question&amp;envId=2023-11-16">2760. 最长奇偶子数组</a></p>
<p>我的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">longestAlternatingSubarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">r</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">l</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&gt;=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">!=</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">&amp;&amp;</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">r</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">l</span><span class="o">=</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;=</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>优雅的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">longestAlternatingSubarray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 直接跳过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 记录这一组的开始位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 开始位置已经满足要求，从下一个位置开始判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从 start 到 i-1 是满足题目要求的子数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">作者：灵茶山艾府</span>
</span></span><span class="line"><span class="cl"><span class="err">链接：</span><span class="nl">https</span><span class="p">:</span><span class="c1">//leetcode.cn/problems/longest-even-odd-subarray-with-threshold/
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">来源：力扣（</span><span class="n">LeetCode</span><span class="err">）</span>
</span></span><span class="line"><span class="cl"><span class="err">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
</span></span></code></pre></div><p>模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nl">n</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">and</span> <span class="p">...</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># 从 start 到 i-1 是一组
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp"># 下一组从 i 开始，无需 i += 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="err">作者：灵茶山艾府</span>
</span></span><span class="line"><span class="cl"><span class="err">链接：</span><span class="nl">https</span><span class="p">:</span><span class="c1">//leetcode.cn/problems/longest-even-odd-subarray-with-threshold/
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">来源：力扣（</span><span class="n">LeetCode</span><span class="err">）</span>
</span></span><span class="line"><span class="cl"><span class="err">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span>
</span></span></code></pre></div><h4 id="689-三个无重叠子数组的最大和httpsleetcodecnproblemsmaximum-sum-of-3-non-overlapping-subarraysdescriptionenvtypedaily-questionenvid2023-11-19"><a href="https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/description/?envType=daily-question&amp;envId=2023-11-19">689. 三个无重叠子数组的最大和</a></h4>
<p>算最大和其实很简单，但是推算位置还是没见过的。其实说难也不难，就是通过dp最大值往后倒推，看这个值是前面那个值推过来的。如果说字典序的话，就是看dp的顺序。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>rocksdb原理</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/10/17/category/rocksdb-principal/</link>
      <pubDate>Tue, 17 Oct 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/10/17/category/rocksdb-principal/</guid>
      <description>基本概念 版本(Version)：这个是RocksDB内部概念。一个版本包含某个时间点的所有存活SST文件。一旦一个落盘或者压缩完成，由于存活</description>
      <content:encoded><![CDATA[<h4 id="基本概念">基本概念</h4>
<ul>
<li>
<p>版本(Version)：这个是RocksDB内部概念。一个版本包含某个时间点的所有存活SST文件。一旦一个落盘或者压缩完成，由于存活SST文件发生了变化，一个新的“版本”会被创建。一个旧的“版本”还会被仍在进行的读请求或者压缩工作使用。旧的版本最终会被回收。</p>
</li>
<li>
<p>超级版本(super version)：RocksDB的内部概念。一个超级版本包含一个特定时间的 的 一个SST文件列表（一个“版本”）以及一个存活memtable的列表。不管是压缩还是落盘，抑或是一个memtable切换，都会生成一个新的“超级版本”。一个旧的“超级版本”会被继续用于正在进行的读请求。旧的超级版本最终会在不再需要的时候被回收掉。</p>
</li>
<li>
<p>对two_write_queues的解释 When we have two write queues (two_write_queues=true) then the primary write queue can write to both WAL and memtable and the 2nd one can write only to the WAL, which will be used for writing the commit marker in WritePrepared transactions. In this case the primary queue (and its PreReleaseCallback callback) is always used for prepare entires and the 2nd queue (and its PreReleaseCallback callback) is always used only for commits. This i) avoids race condition between the two queues, ii) maintains the in-order addition to PreparedHeap, and iii) simplifies the code by avoiding concurrent insertion to CommitCache (and the code that is called upon each eviction from it).</p>
</li>
</ul>
<h4 id="transaction">transaction</h4>
<p>暂时没有总结什么，看<a href="https://whoiami.github.io/ROCKSDB_TRANSACTION_2PC">2PC</a>和<a href="https://whoiami.github.io/ROCKSDB_TRANSACTION">transaction</a>就差不多了。</p>
<h4 id="pipeline">pipeline</h4>
<p>pipeline write</p>
<p>【默认情况】</p>
<p>单一的write thread队列，队首writer成为leader，并负责写WAL以及memtable</p>
<p>【pipeline write】</p>
<p>只有一个writer的情况下，要先写WAL，再写memtbale</p>
<p>如果有多个writer，默认情况就需要先写完WAL，在写memtable</p>
<p>启用pipeline之后，前一个writer写完WAL就可以写memtbale，而后一个writer开始写他的WAL</p>
<p>开启方式：Options.enable_pipeline_write=true</p>
<p>提升：20%性能提升</p>
<h4 id="merge">Merge</h4>
<p>Merge 本质上就是一个 read-modify-write的原子操作。</p>
<p>code is all you need</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="c1">// A &#39;model&#39; merge operator with uint64 addition semantics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">UInt64AddOperator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AssociativeMergeOperator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Merge</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">existing_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">new_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// assuming 0 if no existing value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">uint64_t</span> <span class="n">existing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">existing_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Deserialize</span><span class="p">(</span><span class="o">*</span><span class="n">existing_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">existing</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// if existing_value is corrupted, treat it as 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Log</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;existing value corruption&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">existing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">uint64_t</span> <span class="n">oper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oper</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// if operand is corrupted, treat it as 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">Log</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;operand value corruption&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">oper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="k">new</span> <span class="o">=</span> <span class="n">existing</span> <span class="o">+</span> <span class="n">oper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">new_value</span> <span class="o">=</span> <span class="n">Serialize</span><span class="p">(</span><span class="k">new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>        <span class="c1">// always return true for this, since we treat all errors as &#34;zero&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">Name</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;UInt64AddOperator&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Implement &#39;add&#39; directly with the new Merge operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">MergeBasedCounters</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RocksCounters</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">MergeBasedCounters</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DB</span><span class="o">&gt;</span> <span class="n">db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// mapped to a leveldb Merge operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Add</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="n">serialized</span> <span class="o">=</span> <span class="n">Serialize</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">db_</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="n">merge_option_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">serialized</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// How to use it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DB</span><span class="o">*</span> <span class="n">dbp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">merge_operator</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">UInt64AddOperator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&#34;/tmp/db&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DB</span><span class="o">&gt;</span> <span class="n">db</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">MergeBasedCounters</span> <span class="nf">counters</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">counters</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">counters</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
</span></span></code></pre></div><p>AssociativeMergeOperator适用于比较简单的情景，也就是说，如果你的merge操作是满足结合律的，那么就可以使用AssociativeMergeOperator。</p>
<p>但是如果是复杂一点的，比如说data是json字符串，但是merge的时候只是对其中的一个子结构进行修改，那么就需要使用MergeOperator。</p>
<p>值得注意的是，put和merge并不会在invoke的时候就立刻执行，而是会stack，在get的时候才执行，而在stack的时候就是PartialMerge的时候了。</p>
<p>接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="c1">// The Merge Operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Essentially, a MergeOperator specifies the SEMANTICS of a merge, which only
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// client knows. It could be numeric addition, list append, string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// concatenation, edit data structure, ... , anything.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// The library, on the other hand, is concerned with the exercise of this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// interface, at the right time (during get, iteration, compaction...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">MergeOperator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="o">~</span><span class="n">MergeOperator</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Gives the client a way to express the read -&gt; modify -&gt; write semantics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// key:         (IN) The key that&#39;s associated with this merge operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// existing:    (IN) null indicates that the key does not exist before this op
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// operand_list:(IN) the sequence of merge operations to apply, front() first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// new_value:  (OUT) Client is responsible for filling the merge result here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// logger:      (IN) Client could use this to log errors during merge.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Return true on success. Return false failure / error / corruption.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">FullMerge</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">existing_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">operand_list</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">new_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="nc">MergeOperationInput</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">struct</span> <span class="nc">MergeOperationOutput</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">FullMergeV2</span><span class="p">(</span><span class="k">const</span> <span class="n">MergeOperationInput</span><span class="o">&amp;</span> <span class="n">merge_in</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="n">MergeOperationOutput</span><span class="o">*</span> <span class="n">merge_out</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// This function performs merge(left_op, right_op)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// when both the operands are themselves merge operation types.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Save the result in *new_value and return true. If it is impossible
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// or infeasible to combine the two operations, return false instead.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">PartialMerge</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">left_operand</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">right_operand</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">new_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// The name of the MergeOperator. Used to check for MergeOperator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// mismatches (i.e., a DB created with one MergeOperator is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// accessed using a different MergeOperator)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">Name</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Determines whether the MergeOperator can be called with just a single
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// merge operand.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Override and return true for allowing a single operand. FullMergeV2 and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// PartialMerge/PartialMergeMulti should be implemented accordingly to handle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// a single operand.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">AllowSingleOperand</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span></code></pre></div><p>示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// A &#39;model&#39; pseudo-code merge operator with json update semantics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We pretend we have some in-memory data-structure (called JsonDataStructure) for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// parsing and serializing json strings.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">class</span> <span class="nc">JsonMergeOperator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MergeOperator</span> <span class="p">{</span>          <span class="c1">// not associative
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">FullMerge</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">existing_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">operand_list</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">new_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">JsonDataStructure</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">existing_value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">obj</span><span class="p">.</span><span class="n">ParseFrom</span><span class="p">(</span><span class="n">existing_value</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">IsInvalid</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">Log</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;Invalid json string after parsing: %s&#34;</span><span class="p">,</span> <span class="n">existing_value</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">operand_list</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">auto</span> <span class="n">split_vector</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#34; = &#34;</span><span class="p">);</span>      <span class="c1">// &#34;xyz[0] = 5&#34; might return [&#34;xyz[0]&#34;, 5] as an std::vector, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">obj</span><span class="p">.</span><span class="n">SelectFromHierarchy</span><span class="p">(</span><span class="n">split_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="n">split_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">IsInvalid</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Log</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;Invalid json after parsing operand: %s&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">obj</span><span class="p">.</span><span class="n">SerializeTo</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Partial-merge two operands if and only if the two operands
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// both update the same value. If so, take the &#34;later&#34; operand.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">PartialMerge</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">left_operand</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">right_operand</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">new_value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">Logger</span><span class="o">*</span> <span class="n">logger</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">split_vector1</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">left_operand</span><span class="p">,</span> <span class="s">&#34; = &#34;</span><span class="p">);</span>   <span class="c1">// &#34;xyz[0] = 5&#34; might return [&#34;xyz[0]&#34;, 5] as an std::vector, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">split_vector2</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">right_operand</span><span class="p">,</span> <span class="s">&#34; = &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If the two operations update the same value, just take the later one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">split_vector1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">split_vector2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">new_value</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">(</span><span class="n">right_operand</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">right_operand</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">Name</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s">&#34;JsonMergeOperator&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// How to use it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DB</span><span class="o">*</span> <span class="n">dbp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">merge_operator</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">JsonMergeOperator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">DB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="s">&#34;/tmp/db&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DB</span><span class="o">&gt;</span> <span class="n">db_</span><span class="p">(</span><span class="n">dbp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Put/store the json string into to the database
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">db_</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">put_option_</span><span class="p">,</span> <span class="s">&#34;json_obj_key&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">             <span class="s">&#34;{ employees: [ {first_name: john, last_name: doe}, {first_name: adam, last_name: smith}] }&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Use the &#34;merge operator&#34; to incrementally update the value of the json string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">db_</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="n">merge_option_</span><span class="p">,</span> <span class="s">&#34;json_obj_key&#34;</span><span class="p">,</span> <span class="s">&#34;employees[1].first_name = lucy&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">db_</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="n">merge_option_</span><span class="p">,</span> <span class="s">&#34;json_obj_key&#34;</span><span class="p">,</span> <span class="s">&#34;employees[0].last_name = dow&#34;</span><span class="p">);</span>
</span></span></code></pre></div><h4 id="compaction-filter">Compaction Filter</h4>
<p>Compaction Filter是用来在compaction的时候执行一些自定义操作比如：根据ttl删除值，删除特定范围的键值对等等。</p>
<p>接口可以在rocksdb/compaction_filter.h文件里面找到.</p>
<p>有两种方式可以使用compaction filter:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">options</span><span class="p">.</span><span class="n">compaction_filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CustomCompactionFilter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">options</span><span class="p">.</span><span class="n">compaction_filter_factory</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">CustomCompactionFilterFactory</span><span class="p">());</span>
</span></span></code></pre></div><p>这两种方式对并发有不同的要求：</p>
<ol>
<li>compaction_filter: 一个compaction filter实例会被多个线程共享，所以需要保证线程安全。</li>
<li>compaction_filter_factory: 每个线程会有一个compaction filter实例，所以不需要保证线程安全。</li>
</ol>
<blockquote>
<p>Compaction filter will not be invoked during flush, despite arguably flush is a special type of compaction.
When merge is being used, compaction filter is invoked per merge operand. The result of compaction filter is applied to the merge operand before merge operator is invoked.</p>
</blockquote>
<p>有两套API来实现compaction filter:</p>
<ol>
<li>Filter/FilterMergeOperand 作用有限</li>
<li>FilterV2 changing the value, or dropping a range of keys starting from the current key.</li>
</ol>
<h4 id="reference">Reference</h4>
<p><a href="https://segmentfault.com/a/1190000041198407">简单介绍</a>
<a href="https://wanghenshui.github.io/rocksdb-doc-cn/">rocksdb文档的翻译</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker-images</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/10/15/category/docker-images/</link>
      <pubDate>Sun, 15 Oct 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/10/15/category/docker-images/</guid>
      <description>介绍容器和镜像</description>
      <content:encoded><![CDATA[<p><a href="https://www.cnblogs.com/koktlzz/p/14365025.html">介绍容器和镜像</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go-redis-note</title>
      <link>https://blog.yehaohui.com/zh-cn/2023/10/08/category/go-redis-note/</link>
      <pubDate>Sun, 08 Oct 2023 13:01:23 +0800</pubDate>
      
      <guid>https://blog.yehaohui.com/zh-cn/2023/10/08/category/go-redis-note/</guid>
      <description>记录go-redis使用过程中的一些事项 分布式锁(一上来就是大菜) 最近在阅读两个项目的时候都发现了分布式锁： osproxy： 分片上传时抢锁 r</description>
      <content:encoded><![CDATA[<h2 id="记录go-redis使用过程中的一些事项">记录go-redis使用过程中的一些事项</h2>
<h3 id="分布式锁一上来就是大菜">分布式锁(一上来就是大菜)</h3>
<p>最近在阅读两个项目的时候都发现了分布式锁：</p>
<ol>
<li>osproxy： 分片上传时抢锁</li>
<li>redis-tool： 本来就是教你redis操作的。。。。。。</li>
</ol>
<p>redis的事务和原子性可以看<a href="https://blog.yehaohui.com/zh-cn/2023/09/13/category/redis_basic/">这里记录的一些文章</a></p>
<p>分布式锁的应用场景: <a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/11%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F.md">分布式锁有哪些应用场景和实现？</a></p>
<p>于是记录一下go-redis中的实践：</p>
<p>要注意的几个点：</p>
<ol>
<li>是否可重入</li>
<li>释放锁的方式</li>
</ol>
<h4 id="首先来看看osproxy中是怎么做的">首先来看看osproxy中是怎么做的</h4>
<p>首先是调用接口的例子，这里是一个分片上传的例子，需要抢锁，然后判断是否已经上传过了，如果上传过了就直接返回成功，如果没有上传过就去上传，上传成功后再去释放锁，因为实际上Web 服务器在处理请求的时候是并发的，所以需要抢锁，防止多个请求同时上传同一个文件的同一个分片，这样就会导致文件上传失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">lgRedis</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">plugins</span><span class="p">.</span><span class="nx">LangGoRedis</span><span class="p">).</span><span class="nf">NewRedis</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">createLock</span> <span class="o">:=</span> <span class="nx">base</span><span class="p">.</span><span class="nf">NewRedisLock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">lgRedis</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;multi-part-%d-%d-%s&#34;</span><span class="p">,</span> <span class="nx">uid</span><span class="p">,</span> <span class="nx">chunkNum</span><span class="p">,</span> <span class="nx">md5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">flag</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">createLock</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">flag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lgLogger</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;上传多文件抢锁失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">web</span><span class="p">.</span><span class="nf">InternalError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;上传多文件抢锁失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">partInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">repo</span><span class="p">.</span><span class="nf">NewMultiPartInfoRepo</span><span class="p">().</span><span class="nf">GetPartInfo</span><span class="p">(</span><span class="nx">lgDB</span><span class="p">,</span> <span class="nx">uid</span><span class="p">,</span> <span class="nx">chunkNum</span><span class="p">,</span> <span class="nx">md5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lgLogger</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="nf">Error</span><span class="p">(</span><span class="s">&#34;多文件上传，查询分片信息失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">web</span><span class="p">.</span><span class="nf">InternalError</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;内部异常&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">partInfo</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">web</span><span class="p">.</span><span class="nf">Success</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">createLock</span><span class="p">.</span><span class="nf">Release</span><span class="p">()</span>
</span></span></code></pre></div><p>接下来看一下<code> RedisLock</code>的实现</p>
<p>创建RedisLock，获取锁其实就是通过Eval命令去执行lua脚本。</p>
<p>关键就是这个lua脚本通过获取key的值判断是否与自己线程的唯一id对应，如果对应就返回OK，如果不对应就尝试set(不存在才set)，然后通过判断返回值来判断是否获取到锁。</p>
<p>注意这里还可以完成可重入锁的功能。</p>
<p>释放锁的时候，通过判断key的值是否与自己线程的唯一id对应，如果对应就删除key，如果不对应(过期或者被别的占了)就返回0。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">letters</span>     <span class="p">=</span> <span class="s">&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lockCommand</span> <span class="p">=</span> <span class="s">`if redis.call(&#34;GET&#34;, KEYS[1]) == ARGV[1] then
</span></span></span><span class="line"><span class="cl"><span class="s">                      redis.call(&#34;SET&#34;, KEYS[1], ARGV[1], &#34;PX&#34;, ARGV[2])
</span></span></span><span class="line"><span class="cl"><span class="s">                      return &#34;OK&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">                   else
</span></span></span><span class="line"><span class="cl"><span class="s">                       return redis.call(&#34;SET&#34;, KEYS[1], ARGV[1], &#34;NX&#34;, &#34;PX&#34;, ARGV[2])
</span></span></span><span class="line"><span class="cl"><span class="s">                   end`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">delCommand</span> <span class="p">=</span> <span class="s">`if redis.call(&#34;GET&#34;, KEYS[1]) == ARGV[1] then
</span></span></span><span class="line"><span class="cl"><span class="s">                      return redis.call(&#34;DEL&#34;, KEYS[1])
</span></span></span><span class="line"><span class="cl"><span class="s">                  else
</span></span></span><span class="line"><span class="cl"><span class="s">                      return 0
</span></span></span><span class="line"><span class="cl"><span class="s">                  end`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">randomLen</span> <span class="p">=</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 默认超时时间，防止死锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tolerance</span>       <span class="p">=</span> <span class="mi">500</span> <span class="c1">// milliseconds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">millisPerSecond</span> <span class="p">=</span> <span class="mi">1000</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// NewRedisLock returns a RedisLock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewRedisLock</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">store</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">RedisLock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RedisLock</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ctx</span><span class="p">:</span>   <span class="nx">c</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">store</span><span class="p">:</span> <span class="nx">store</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获取锁时，锁的值通过随机字符串生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 实际上go-zero提供更加高效的随机字符串生成方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 见core/stringx/random.go：Randn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">id</span><span class="p">:</span> <span class="nf">randomStr</span><span class="p">(</span><span class="nx">randomLen</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Acquire acquires the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rl</span> <span class="o">*</span><span class="nx">RedisLock</span><span class="p">)</span> <span class="nf">Acquire</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 获取过期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">seconds</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">rl</span><span class="p">.</span><span class="nx">seconds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 默认锁过期时间为500ms，防止死锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="o">*</span><span class="nx">rl</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">lockCommand</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">rl</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rl</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">seconds</span><span class="p">)</span><span class="o">*</span><span class="nx">millisPerSecond</span> <span class="o">+</span> <span class="nx">tolerance</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;lock failed %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">resp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">resp</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">reply</span> <span class="o">==</span> <span class="s">&#34;OK&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Unknown reply when acquiring lock for %s: %v&#34;</span><span class="p">,</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Release releases the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1">// 释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rl</span> <span class="o">*</span><span class="nx">RedisLock</span><span class="p">)</span> <span class="nf">Release</span><span class="p">()</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Eval</span><span class="p">(</span><span class="o">*</span><span class="nx">rl</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">delCommand</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">rl</span><span class="p">.</span><span class="nx">key</span><span class="p">},</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">rl</span><span class="p">.</span><span class="nx">id</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">res</span><span class="p">.</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">reply</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">resp</span><span class="p">).(</span><span class="kt">int64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">reply</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="接下来看看redis-tool中是怎么做的">接下来看看redis-tool中是怎么做的</h4>
<p>首先看调用基本也是传一个client和key。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Options</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Addr</span><span class="p">:</span>     <span class="s">&#34;localhost:6378&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Password</span><span class="p">:</span> <span class="s">&#34;123456&#34;</span><span class="p">,</span> <span class="c1">// no password set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">DB</span><span class="p">:</span>       <span class="mi">0</span><span class="p">,</span>        <span class="c1">// use default DB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">disLock</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tools</span><span class="p">.</span><span class="nf">NewRedisLock</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="s">&#34;lock resource&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">succ</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">disLock</span><span class="p">.</span><span class="nf">TryLock</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">succ</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">disLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>实现起来,unlock方法其实也是基于上面的那个lua脚本(compare and delete)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rl</span> <span class="o">*</span><span class="nx">RedisLock</span><span class="p">)</span> <span class="nf">TryLock</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">succ</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">Client</span><span class="p">.</span><span class="nf">SetNX</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">uuid</span><span class="p">,</span> <span class="nx">defaultExp</span><span class="p">).</span><span class="nf">Result</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">succ</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rl</span><span class="p">.</span><span class="nx">cancelFunc</span> <span class="p">=</span> <span class="nx">cancel</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rl</span><span class="p">.</span><span class="nf">refresh</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">succ</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rl</span> <span class="o">*</span><span class="nx">RedisLock</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">NewTools</span><span class="p">(</span><span class="nx">rl</span><span class="p">.</span><span class="nx">Client</span><span class="p">).</span><span class="nf">Cad</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">rl</span><span class="p">.</span><span class="nx">uuid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">resp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rl</span><span class="p">.</span><span class="nf">cancelFunc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>